diff -urN a/extra/config/Makefile b/extra/config/Makefile
--- a/extra/config/Makefile	2005-04-18 23:59:49.000000000 +0800
+++ b/extra/config/Makefile	2012-04-10 13:55:23.000000000 +0800
@@ -82,7 +82,10 @@
 
 ifdef LKC_GENPARSER
 
-%.tab.c %.tab.h: %.y
+%.tab.c: %.y
+	bison -t -d -v -b $* -p $(notdir $*) $<
+
+%.tab.h: %.y
 	bison -t -d -v -b $* -p $(notdir $*) $<
 
 lex.%.c: %.l
diff -urN a/extra/config/util.c b/extra/config/util.c
--- a/extra/config/util.c	2005-04-18 23:59:49.000000000 +0800
+++ b/extra/config/util.c	2012-04-10 13:55:23.000000000 +0800
@@ -44,7 +44,7 @@
 		else
 			fprintf(out, "\t%s\n", file->name);
 	}
-	fprintf(out, "\n.config include/linux/autoconf.h: $(deps_config)\n\n$(deps_config):\n");
+	fprintf(out, "\n.config include/linux/config.h: $(deps_config)\n\n$(deps_config):\n");
 	fclose(out);
 	rename("..config.tmp", name);
 	return 0;
diff -urN a/extra/Configs/Config.in b/extra/Configs/Config.in
--- a/extra/Configs/Config.in	2007-01-26 07:01:55.000000000 +0700
+++ b/extra/Configs/Config.in	2012-04-17 19:36:16.000000000 +0800
@@ -1129,7 +1129,7 @@
 	depends on HAVE_SHARED
 	depends on TARGET_arm || TARGET_frv || TARGET_i386 || TARGET_mips || TARGET_powerpc
 	select FORCE_SHAREABLE_TEXT_SEGMENTS if BUILD_UCLIBC_LDSO
-	default y
+	default n
 	help
 	  If you answer Y here, ldd and iconv are built as ET_DYN/PIE executables.
 	  It requires gcc-3.4 and binutils-2.15 (for arm 2.16) or later.
diff -urN a/extra/Configs/Config.mips b/extra/Configs/Config.mips
--- a/extra/Configs/Config.mips	2004-01-16 20:38:10.000000000 +0700
+++ b/extra/Configs/Config.mips	2012-04-10 13:55:23.000000000 +0800
@@ -12,7 +12,7 @@
 
 config ARCH_CFLAGS
 	string
-	default "-mno-split-addresses"
+	default "-ffast-math -fforce-addr -fno-stack-protector"
 
 config ARCH_LDFLAGS
 	string
@@ -22,7 +22,7 @@
 
 config ARCH_SUPPORTS_BIG_ENDIAN
 	bool
-	default y
+	default n
 
 config ARCH_SUPPORTS_LITTLE_ENDIAN
 	bool
@@ -30,7 +30,7 @@
 
 choice
 	prompt "Target Processor Architecture"
-	default CONFIG_MIPS_ISA_1
+	default CONFIG_MIPS_ISA_2
 	help
 	  This selects the instruction set architecture of your MIPS CPU. This
 	  information is used for optimizing purposes. To build a library that
diff -urN a/extra/scripts/gen_bits_syscall_h.sh b/extra/scripts/gen_bits_syscall_h.sh
--- a/extra/scripts/gen_bits_syscall_h.sh	2002-10-28 15:33:08.000000000 +0700
+++ b/extra/scripts/gen_bits_syscall_h.sh	2012-04-10 13:55:23.000000000 +0800
@@ -25,7 +25,8 @@
   echo "#endif" ; echo ;
   sed -ne 's/^UCLIBC_\([A-Za-z0-9_]*\) *\(.*\)/#undef __NR_\1\
 #define __NR_\1 \2\
-#define SYS_\1 __NR_\1/gp'
+#define SYS_\1 __NR_\1/gp' \
+     -e 's/^UNDEFUCLIBC_\([A-Za-z0-9_]*\).*/#undef __NR_\1/gp'
   echo ;
   echo "#endif" ;
 )
diff -urN a/extra/scripts/getent b/extra/scripts/getent
--- a/extra/scripts/getent	2007-01-26 07:01:55.000000000 +0700
+++ b/extra/scripts/getent	2012-04-10 13:55:23.000000000 +0800
@@ -1,5 +1,5 @@
 #!/bin/sh
-# $Header: /var/cvs/uClibc/extra/scripts/getent,v 1.2 2005/02/02 14:18:01 solar Exp $
+# $Header: /home/cvsroot/RT288x_SDK/source/lib/extra/scripts/getent,v 1.1.1.1 2007-01-09 06:46:09 steven Exp $
 
 search_entry() {
   if [ -e "$1" ] ; then
diff -urN a/.gitignore b/.gitignore
--- a/.gitignore	1970-01-01 07:00:00.000000000 +0700
+++ b/.gitignore	2012-09-07 04:56:33.000000000 +0800
@@ -0,0 +1,8 @@
+*.os
+*.oS
+*.dep
+*.a
+*.o
+*.depend
+lib
+.config*
diff -urN a/include/assert.h b/include/assert.h
--- a/include/assert.h	2007-01-26 06:57:59.000000000 +0700
+++ b/include/assert.h	2012-04-10 13:55:23.000000000 +0800
@@ -55,7 +55,7 @@
 
 __END_DECLS
 
-# define assert(expr) \
+#define	assert(expr)							      \
   (__ASSERT_VOID_CAST ((expr) ? 0 :					      \
 		       (__assert (__STRING(expr), __FILE__, __LINE__,    \
 				       __ASSERT_FUNCTION), 0)))
@@ -67,7 +67,7 @@
    it demangles C++ function names.  */
 # if defined __cplusplus ? __GNUC_PREREQ (2, 6) : __GNUC_PREREQ (2, 4)
 #   define __ASSERT_FUNCTION	__PRETTY_FUNCTION__
-# else
+#  else
 #  if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
 #   define __ASSERT_FUNCTION	__func__
 #  else
diff -urN a/include/boot1_arch.h b/include/boot1_arch.h
--- a/include/boot1_arch.h	1970-01-01 07:00:00.000000000 +0700
+++ b/include/boot1_arch.h	2012-04-10 13:55:23.000000000 +0800
@@ -0,0 +1,38 @@
+/* Any assmbly language/system dependent hacks needed to setup boot1.c so it
+ * will work as expected and cope with whatever platform specific wierdness is
+ * needed for this architecture.
+ */
+
+asm("" \
+"	.text\n"			\
+"	.globl	_dl_boot\n"		\
+"_dl_boot:\n"				\
+"	.set noreorder\n"		\
+"	bltzal $0, 0f\n"		\
+"	nop\n"				\
+"0:	.cpload $31\n"			\
+"	.set reorder\n"			\
+"	la $4, _DYNAMIC\n"		\
+"	sw $4, -0x7ff0($28)\n"	        \
+"	move $4, $29\n"			\
+"	la $8, coff\n"			\
+"	.set noreorder\n"		\
+"	bltzal $0, coff\n"		\
+"	nop\n"				\
+"coff:	subu $8, $31, $8\n"		\
+"	.set reorder\n"			\
+"	la $25, _dl_boot2\n"	        \
+"	addu $25, $8\n"			\
+"	jalr $25\n"			\
+"	lw $4, 0($29)\n"		\
+"	la $5, 4($29)\n"		\
+"	sll $6, $4, 2\n"		\
+"	addu $6, $6, $5\n"		\
+"	addu $6, $6, 4\n"		\
+"	la $7, _dl_elf_main\n"		\
+"	lw $25, 0($7)\n"		\
+"	jr $25\n"			\
+);
+
+#define _dl_boot _dl_boot2
+#define LD_BOOT(X)   static void __attribute__ ((unused)) _dl_boot (X)
diff -urN a/include/langinfo.h b/include/langinfo.h
--- a/include/langinfo.h	2004-09-07 16:44:19.000000000 +0800
+++ b/include/langinfo.h	2012-04-10 13:55:23.000000000 +0800
@@ -614,7 +614,7 @@
 # include <xlocale.h>
 
 /* Just like nl_langinfo but get the information from the locale object L.  */
-#ifdef __UCLIBC_MJN3_ONLY__
+#if 0
 #warning "mjn3 FIXME: nl_langinfo_l has a prototype but isn't defined."
 #endif
 extern char *nl_langinfo_l (nl_item __item, __locale_t l);
diff -urN a/include/libintl.h b/include/libintl.h
--- a/include/libintl.h	2004-09-07 16:53:33.000000000 +0800
+++ b/include/libintl.h	2012-04-10 13:55:23.000000000 +0800
@@ -34,7 +34,7 @@
 
 __BEGIN_DECLS
 
-#ifdef __UCLIBC_MJN3_ONLY__
+#if 0
 #warning "mjn3 FIXME: gettext has a prototype but isn't defined."
 #warning "mjn3 FIXME: __OPTIMIZE__ is never defined."
 #endif
diff -urN a/include/limits.h b/include/limits.h
--- a/include/limits.h	2001-09-27 13:21:15.000000000 +0800
+++ b/include/limits.h	2012-04-10 13:55:23.000000000 +0800
@@ -34,7 +34,7 @@
 
 /* If we are not using GNU CC we have to define all the symbols ourself.
    Otherwise use gcc's definitions (see below).  */
-#if !defined __GNUC__ || __GNUC__ < 2
+#if !defined __GNUC__ || __GNUC__ < 2 || __GNUC__ > 3
 
 /* We only protect from multiple inclusion here, because all the other
    #include's protect themselves, and in GCC 2 we may #include_next through
@@ -121,7 +121,9 @@
     the definitions from gcc's header.  */
 #if defined __GNUC__ && !defined _GCC_LIMITS_H_
 /* `_GCC_LIMITS_H_' is what GCC's file defines.  */
+#if !defined __GNUC__ || __GNUC__ < 4
 # include_next <limits.h>
+#endif
 
 /* The <limits.h> files in some gcc versions don't define LLONG_MIN,
    LLONG_MAX, and ULLONG_MAX.  Instead only the values gcc defined for
diff -urN a/include/math.h b/include/math.h
--- a/include/math.h	2001-11-22 21:04:29.000000000 +0700
+++ b/include/math.h	2012-04-10 13:55:23.000000000 +0800
@@ -115,7 +115,7 @@
 
 
 /* ISO C99 defines some generic macros which work on any data type.  */
-#if __USE_ISOC99
+#ifdef __USE_ISOC99
 
 /* Get the architecture specific values describing the floating-point
    evaluation.  The following symbols will get defined:
@@ -351,7 +351,7 @@
 #endif
 
 
-#if __USE_ISOC99
+#ifdef __USE_ISOC99
 /* ISO C99 defines some macros to compare number while taking care
    for unordered numbers.  Since many FPUs provide special
    instructions to support these operations and these tests are
diff -urN a/include/net/pppio.h b/include/net/pppio.h
--- a/include/net/pppio.h	1970-01-01 07:00:00.000000000 +0700
+++ b/include/net/pppio.h	2012-04-10 13:55:23.000000000 +0800
@@ -0,0 +1,99 @@
+/*
+ * pppio.h - ioctl and other misc. definitions for STREAMS modules.
+ *
+ * Copyright (c) 1994 The Australian National University.
+ * All rights reserved.
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation is hereby granted, provided that the above copyright
+ * notice appears in all copies.  This software is provided without any
+ * warranty, express or implied. The Australian National University
+ * makes no representations about the suitability of this software for
+ * any purpose.
+ *
+ * IN NO EVENT SHALL THE AUSTRALIAN NATIONAL UNIVERSITY BE LIABLE TO ANY
+ * PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
+ * THE AUSTRALIAN NATIONAL UNIVERSITY HAVE BEEN ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * THE AUSTRALIAN NATIONAL UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
+ * ON AN "AS IS" BASIS, AND THE AUSTRALIAN NATIONAL UNIVERSITY HAS NO
+ * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS,
+ * OR MODIFICATIONS.
+ *
+ * $Id: pppio.h,v 1.1 2005/12/07 14:01:53 kaohj Exp $
+ */
+
+#define _PPPIO(n)	(('p' << 8) + (n))
+
+#define PPPIO_NEWPPA	_PPPIO(130)	/* allocate a new PPP unit */
+#define PPPIO_GETSTAT	_PPPIO(131)	/* get PPP statistics */
+#define PPPIO_GETCSTAT	_PPPIO(132)	/* get PPP compression stats */
+#define PPPIO_MTU	_PPPIO(133)	/* set max transmission unit */
+#define PPPIO_MRU	_PPPIO(134)	/* set max receive unit */
+#define PPPIO_CFLAGS	_PPPIO(135)	/* set/clear/get compression flags */
+#define PPPIO_XCOMP	_PPPIO(136)	/* alloc transmit compressor */
+#define PPPIO_RCOMP	_PPPIO(137)	/* alloc receive decompressor */
+#define PPPIO_XACCM	_PPPIO(138)	/* set transmit asyncmap */
+#define PPPIO_RACCM	_PPPIO(139)	/* set receive asyncmap */
+#define PPPIO_VJINIT	_PPPIO(140)	/* initialize VJ comp/decomp */
+#define PPPIO_ATTACH	_PPPIO(141)	/* attach to a ppa (without putmsg) */
+#define PPPIO_LASTMOD	_PPPIO(142)	/* mark last ppp module */
+#define PPPIO_GCLEAN	_PPPIO(143)	/* get 8-bit-clean flags */
+#define PPPIO_DEBUG	_PPPIO(144)	/* request debug information */
+#define PPPIO_BIND	_PPPIO(145)	/* bind to SAP */
+#define PPPIO_NPMODE	_PPPIO(146)	/* set mode for handling data pkts */
+#define PPPIO_GIDLE	_PPPIO(147)	/* get time since last data pkt */
+#define PPPIO_PASSFILT	_PPPIO(148)	/* set filter for packets to pass */
+#define PPPIO_ACTIVEFILT _PPPIO(149)	/* set filter for "link active" pkts */
+
+/*
+ * Values for PPPIO_CFLAGS
+ */
+#define COMP_AC		0x1		/* compress address/control */
+#define DECOMP_AC	0x2		/* decompress address/control */
+#define COMP_PROT	0x4		/* compress PPP protocol */
+#define DECOMP_PROT	0x8		/* decompress PPP protocol */
+
+#define COMP_VJC	0x10		/* compress TCP/IP headers */
+#define COMP_VJCCID	0x20		/* compress connection ID as well */
+#define DECOMP_VJC	0x40		/* decompress TCP/IP headers */
+#define DECOMP_VJCCID	0x80		/* accept compressed connection ID */
+
+#define CCP_ISOPEN	0x100		/* look at CCP packets */
+#define CCP_ISUP	0x200		/* do packet comp/decomp */
+#define CCP_ERROR	0x400		/* (status) error in packet decomp */
+#define CCP_FATALERROR	0x800		/* (status) fatal error ditto */
+#define CCP_COMP_RUN	0x1000		/* (status) seen CCP ack sent */
+#define CCP_DECOMP_RUN	0x2000		/* (status) seen CCP ack rcvd */
+
+/*
+ * Values for 8-bit-clean flags.
+ */
+#define RCV_B7_0	1		/* have rcvd char with bit 7 = 0 */
+#define RCV_B7_1	2		/* have rcvd char with bit 7 = 1 */
+#define RCV_EVNP	4		/* have rcvd char with even parity */
+#define RCV_ODDP	8		/* have rcvd char with odd parity */
+
+/*
+ * Values for the first byte of M_CTL messages passed between
+ * PPP modules.
+ */
+#define PPPCTL_OERROR	0xe0		/* output error [up] */
+#define PPPCTL_IERROR	0xe1		/* input error (e.g. FCS) [up] */
+#define PPPCTL_MTU	0xe2		/* set MTU [down] */
+#define PPPCTL_MRU	0xe3		/* set MRU [down] */
+#define PPPCTL_UNIT	0xe4		/* note PPP unit number [down] */
+
+/*
+ * Values for the integer argument to PPPIO_DEBUG.
+ */
+#define PPPDBG_DUMP	0x10000		/* print out debug info now */
+#define PPPDBG_LOG	0x100		/* log various things */
+#define PPPDBG_DRIVER	0		/* identifies ppp driver as target */
+#define PPPDBG_IF	1		/* identifies ppp network i/f target */
+#define PPPDBG_COMP	2		/* identifies ppp compression target */
+#define PPPDBG_AHDLC	3		/* identifies ppp async hdlc target */
diff -urN a/include/net/slcompress.h b/include/net/slcompress.h
--- a/include/net/slcompress.h	1970-01-01 07:00:00.000000000 +0700
+++ b/include/net/slcompress.h	2012-04-10 13:55:23.000000000 +0800
@@ -0,0 +1,148 @@
+/*
+ * Definitions for tcp compression routines.
+ *
+ * $Id: slcompress.h,v 1.1 2005/12/07 14:01:53 kaohj Exp $
+ *
+ * Copyright (c) 1989 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by the University of California, Berkeley.  The name of the
+ * University may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Van Jacobson (van@helios.ee.lbl.gov), Dec 31, 1989:
+ *	- Initial distribution.
+ */
+
+#ifndef _SLCOMPRESS_H_
+#define _SLCOMPRESS_H_
+
+#define MAX_STATES 16		/* must be > 2 and < 256 */
+#define MAX_HDR MLEN		/* XXX 4bsd-ism: should really be 128 */
+
+/*
+ * Compressed packet format:
+ *
+ * The first octet contains the packet type (top 3 bits), TCP
+ * 'push' bit, and flags that indicate which of the 4 TCP sequence
+ * numbers have changed (bottom 5 bits).  The next octet is a
+ * conversation number that associates a saved IP/TCP header with
+ * the compressed packet.  The next two octets are the TCP checksum
+ * from the original datagram.  The next 0 to 15 octets are
+ * sequence number changes, one change per bit set in the header
+ * (there may be no changes and there are two special cases where
+ * the receiver implicitly knows what changed -- see below).
+ * 
+ * There are 5 numbers which can change (they are always inserted
+ * in the following order): TCP urgent pointer, window,
+ * acknowlegement, sequence number and IP ID.  (The urgent pointer
+ * is different from the others in that its value is sent, not the
+ * change in value.)  Since typical use of SLIP links is biased
+ * toward small packets (see comments on MTU/MSS below), changes
+ * use a variable length coding with one octet for numbers in the
+ * range 1 - 255 and 3 octets (0, MSB, LSB) for numbers in the
+ * range 256 - 65535 or 0.  (If the change in sequence number or
+ * ack is more than 65535, an uncompressed packet is sent.)
+ */
+
+/*
+ * Packet types (must not conflict with IP protocol version)
+ *
+ * The top nibble of the first octet is the packet type.  There are
+ * three possible types: IP (not proto TCP or tcp with one of the
+ * control flags set); uncompressed TCP (a normal IP/TCP packet but
+ * with the 8-bit protocol field replaced by an 8-bit connection id --
+ * this type of packet syncs the sender & receiver); and compressed
+ * TCP (described above).
+ *
+ * LSB of 4-bit field is TCP "PUSH" bit (a worthless anachronism) and
+ * is logically part of the 4-bit "changes" field that follows.  Top
+ * three bits are actual packet type.  For backward compatibility
+ * and in the interest of conserving bits, numbers are chosen so the
+ * IP protocol version number (4) which normally appears in this nibble
+ * means "IP packet".
+ */
+
+/* packet types */
+#define TYPE_IP 0x40
+#define TYPE_UNCOMPRESSED_TCP 0x70
+#define TYPE_COMPRESSED_TCP 0x80
+#define TYPE_ERROR 0x00
+
+/* Bits in first octet of compressed packet */
+#define NEW_C	0x40	/* flag bits for what changed in a packet */
+#define NEW_I	0x20
+#define NEW_S	0x08
+#define NEW_A	0x04
+#define NEW_W	0x02
+#define NEW_U	0x01
+
+/* reserved, special-case values of above */
+#define SPECIAL_I (NEW_S|NEW_W|NEW_U)		/* echoed interactive traffic */
+#define SPECIAL_D (NEW_S|NEW_A|NEW_W|NEW_U)	/* unidirectional data */
+#define SPECIALS_MASK (NEW_S|NEW_A|NEW_W|NEW_U)
+
+#define TCP_PUSH_BIT 0x10
+
+
+/*
+ * "state" data for each active tcp conversation on the wire.  This is
+ * basically a copy of the entire IP/TCP header from the last packet
+ * we saw from the conversation together with a small identifier
+ * the transmit & receive ends of the line use to locate saved header.
+ */
+struct cstate {
+	struct cstate *cs_next;	/* next most recently used cstate (xmit only) */
+	u_short cs_hlen;	/* size of hdr (receive only) */
+	u_char cs_id;		/* connection # associated with this state */
+	u_char cs_filler;
+	union {
+		char csu_hdr[MAX_HDR];
+		struct ip csu_ip;	/* ip/tcp hdr from most recent packet */
+	} slcs_u;
+};
+#define cs_ip slcs_u.csu_ip
+#define cs_hdr slcs_u.csu_hdr
+
+/*
+ * all the state data for one serial line (we need one of these
+ * per line).
+ */
+struct slcompress {
+	struct cstate *last_cs;	/* most recently used tstate */
+	u_char last_recv;	/* last rcvd conn. id */
+	u_char last_xmit;	/* last sent conn. id */
+	u_short flags;
+#ifndef SL_NO_STATS
+	int sls_packets;	/* outbound packets */
+	int sls_compressed;	/* outbound compressed packets */
+	int sls_searches;	/* searches for connection state */
+	int sls_misses;		/* times couldn't find conn. state */
+	int sls_uncompressedin;	/* inbound uncompressed packets */
+	int sls_compressedin;	/* inbound compressed packets */
+	int sls_errorin;	/* inbound unknown type packets */
+	int sls_tossed;		/* inbound packets tossed because of error */
+#endif
+	struct cstate tstate[MAX_STATES];	/* xmit connection states */
+	struct cstate rstate[MAX_STATES];	/* receive connection states */
+};
+/* flag values */
+#define SLF_TOSS 1		/* tossing rcvd frames because of input err */
+
+void	sl_compress_init __P((struct slcompress *));
+void	sl_compress_setup __P((struct slcompress *, int));
+u_int	sl_compress_tcp __P((struct mbuf *,
+	    struct ip *, struct slcompress *, int));
+int	sl_uncompress_tcp __P((u_char **, int, u_int, struct slcompress *));
+int	sl_uncompress_tcp_core __P((u_char *, int, int, u_int,
+	    struct slcompress *, u_char **, u_int *));
+
+#endif /* _SLCOMPRESS_H_ */
diff -urN a/include/net/vjcompress.h b/include/net/vjcompress.h
--- a/include/net/vjcompress.h	1970-01-01 07:00:00.000000000 +0700
+++ b/include/net/vjcompress.h	2012-04-10 13:55:23.000000000 +0800
@@ -0,0 +1,144 @@
+/*
+ * Definitions for tcp compression routines.
+ *
+ * $Id: vjcompress.h,v 1.1 2005/12/07 14:01:53 kaohj Exp $
+ *
+ * Copyright (c) 1989 Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms are permitted
+ * provided that the above copyright notice and this paragraph are
+ * duplicated in all such forms and that any documentation,
+ * advertising materials, and other materials related to such
+ * distribution and use acknowledge that the software was developed
+ * by the University of California, Berkeley.  The name of the
+ * University may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ *	Van Jacobson (van@helios.ee.lbl.gov), Dec 31, 1989:
+ *	- Initial distribution.
+ */
+
+#ifndef _VJCOMPRESS_H_
+#define _VJCOMPRESS_H_
+
+#define MAX_STATES 16		/* must be > 2 and < 256 */
+#define MAX_HDR	   128
+
+/*
+ * Compressed packet format:
+ *
+ * The first octet contains the packet type (top 3 bits), TCP
+ * 'push' bit, and flags that indicate which of the 4 TCP sequence
+ * numbers have changed (bottom 5 bits).  The next octet is a
+ * conversation number that associates a saved IP/TCP header with
+ * the compressed packet.  The next two octets are the TCP checksum
+ * from the original datagram.  The next 0 to 15 octets are
+ * sequence number changes, one change per bit set in the header
+ * (there may be no changes and there are two special cases where
+ * the receiver implicitly knows what changed -- see below).
+ * 
+ * There are 5 numbers which can change (they are always inserted
+ * in the following order): TCP urgent pointer, window,
+ * acknowlegement, sequence number and IP ID.  (The urgent pointer
+ * is different from the others in that its value is sent, not the
+ * change in value.)  Since typical use of SLIP links is biased
+ * toward small packets (see comments on MTU/MSS below), changes
+ * use a variable length coding with one octet for numbers in the
+ * range 1 - 255 and 3 octets (0, MSB, LSB) for numbers in the
+ * range 256 - 65535 or 0.  (If the change in sequence number or
+ * ack is more than 65535, an uncompressed packet is sent.)
+ */
+
+/*
+ * Packet types (must not conflict with IP protocol version)
+ *
+ * The top nibble of the first octet is the packet type.  There are
+ * three possible types: IP (not proto TCP or tcp with one of the
+ * control flags set); uncompressed TCP (a normal IP/TCP packet but
+ * with the 8-bit protocol field replaced by an 8-bit connection id --
+ * this type of packet syncs the sender & receiver); and compressed
+ * TCP (described above).
+ *
+ * LSB of 4-bit field is TCP "PUSH" bit (a worthless anachronism) and
+ * is logically part of the 4-bit "changes" field that follows.  Top
+ * three bits are actual packet type.  For backward compatibility
+ * and in the interest of conserving bits, numbers are chosen so the
+ * IP protocol version number (4) which normally appears in this nibble
+ * means "IP packet".
+ */
+
+/* packet types */
+#define TYPE_IP 0x40
+#define TYPE_UNCOMPRESSED_TCP 0x70
+#define TYPE_COMPRESSED_TCP 0x80
+#define TYPE_ERROR 0x00
+
+/* Bits in first octet of compressed packet */
+#define NEW_C	0x40	/* flag bits for what changed in a packet */
+#define NEW_I	0x20
+#define NEW_S	0x08
+#define NEW_A	0x04
+#define NEW_W	0x02
+#define NEW_U	0x01
+
+/* reserved, special-case values of above */
+#define SPECIAL_I (NEW_S|NEW_W|NEW_U)		/* echoed interactive traffic */
+#define SPECIAL_D (NEW_S|NEW_A|NEW_W|NEW_U)	/* unidirectional data */
+#define SPECIALS_MASK (NEW_S|NEW_A|NEW_W|NEW_U)
+
+#define TCP_PUSH_BIT 0x10
+
+
+/*
+ * "state" data for each active tcp conversation on the wire.  This is
+ * basically a copy of the entire IP/TCP header from the last packet
+ * we saw from the conversation together with a small identifier
+ * the transmit & receive ends of the line use to locate saved header.
+ */
+struct cstate {
+    struct cstate *cs_next;	/* next most recently used state (xmit only) */
+    u_short cs_hlen;		/* size of hdr (receive only) */
+    u_char cs_id;		/* connection # associated with this state */
+    u_char cs_filler;
+    union {
+	char csu_hdr[MAX_HDR];
+	struct ip csu_ip;	/* ip/tcp hdr from most recent packet */
+    } vjcs_u;
+};
+#define cs_ip vjcs_u.csu_ip
+#define cs_hdr vjcs_u.csu_hdr
+
+/*
+ * all the state data for one serial line (we need one of these per line).
+ */
+struct vjcompress {
+    struct cstate *last_cs;	/* most recently used tstate */
+    u_char last_recv;		/* last rcvd conn. id */
+    u_char last_xmit;		/* last sent conn. id */
+    u_short flags;
+#ifndef VJ_NO_STATS
+    struct vjstat stats;
+#endif
+    struct cstate tstate[MAX_STATES];	/* xmit connection states */
+    struct cstate rstate[MAX_STATES];	/* receive connection states */
+};
+
+/* flag values */
+#define VJF_TOSS 1		/* tossing rcvd frames because of input err */
+
+extern void  vj_compress_init __P((struct vjcompress *comp, int max_state));
+extern u_int vj_compress_tcp __P((struct ip *ip, u_int mlen,
+				struct vjcompress *comp, int compress_cid_flag,
+				u_char **vjhdrp));
+extern void  vj_uncompress_err __P((struct vjcompress *comp));
+extern int   vj_uncompress_uncomp __P((u_char *buf, int buflen,
+				struct vjcompress *comp));
+extern int   vj_uncompress_tcp __P((u_char *buf, int buflen, int total_len,
+				struct vjcompress *comp, u_char **hdrp,
+				u_int *hlenp));
+
+#endif /* _VJCOMPRESS_H_ */
diff -urN a/include/netdb.h b/include/netdb.h
--- a/include/netdb.h	2004-09-08 11:07:17.000000000 +0800
+++ b/include/netdb.h	2012-09-07 04:56:33.000000000 +0800
@@ -401,6 +401,9 @@
 # define AI_PASSIVE	0x0001	/* Socket address is intended for `bind'.  */
 # define AI_CANONNAME	0x0002	/* Request for canonical name.  */
 # define AI_NUMERICHOST	0x0004	/* Don't use name resolution.  */
+# define AI_V4MAPPED	0x0008  /* IPv4 mapped addresses are acceptable.  */
+# define AI_ALL		0x0010	/* Return IPv4 mapped and IPv6 addresses.  */
+# define AI_ADDRCONFIG	0x0020	/* Use host config to choose ret addr type. */
 
 /* Error values for `getaddrinfo' function.  */
 # define EAI_BADFLAGS	  -1	/* Invalid value for `ai_flags' field.  */
diff -urN a/include/nl_types.h b/include/nl_types.h
--- a/include/nl_types.h	2004-09-07 19:13:06.000000000 +0800
+++ b/include/nl_types.h	2012-04-10 13:55:23.000000000 +0800
@@ -30,7 +30,7 @@
 
 __BEGIN_DECLS
 
-#ifdef __UCLIBC_MJN3_ONLY__
+#if 0
 #warning "mjn3 FIXME: None of these prototypes have implementations."
 #endif
 
diff -urN a/include/paths.h b/include/paths.h
--- a/include/paths.h	2003-06-18 03:19:39.000000000 +0800
+++ b/include/paths.h	2012-04-10 13:55:23.000000000 +0800
@@ -40,6 +40,7 @@
 
 #define	_PATH_BSHELL	"/bin/sh"
 #define	_PATH_CONSOLE	"/dev/console"
+#define	_PATH_TTY	"/dev/tty"
 #define	_PATH_CSHELL	"/bin/csh"
 #define	_PATH_DEVDB	"/var/run/dev.db"
 #define	_PATH_DEVNULL	"/dev/null"
@@ -57,7 +58,6 @@
 #define	_PATH_RWHODIR	"/var/spool/rwho"
 #define	_PATH_SENDMAIL	"/usr/sbin/sendmail"
 #define	_PATH_SHELLS	"/etc/shells"
-#define	_PATH_TTY	"/dev/tty"
 #define	_PATH_UNIX	"/boot/vmlinux"
 #define	_PATH_UTMP	"/var/run/utmp"
 #define	_PATH_VI	"/usr/bin/vi"
diff -urN a/include/sys/cdefs.h b/include/sys/cdefs.h
--- a/include/sys/cdefs.h	2005-07-02 22:34:39.000000000 +0800
+++ b/include/sys/cdefs.h	2012-04-10 13:55:23.000000000 +0800
@@ -42,7 +42,8 @@
    gcc 2.8.x and egcs.  For gcc 3.2 and up we even mark C functions
    as non-throwing using a function attribute since programs can use
    the -fexceptions options for C code as well.  */
-# if 0 //!defined __cplusplus && __GNUC_PREREQ (3, 3)
+/* !defined __cplusplus && __GNUC_PREREQ (3, 3) */
+# if 0 
 #  define __THROW	__attribute__ ((__nothrow__))
 #  define __NTH(fct)	__attribute__ ((__nothrow__)) fct
 # else
@@ -128,6 +129,10 @@
 
 
 /* Fortify support.  */
+#ifndef __USE_FORTIFY_LEVEL
+#define __USE_FORTIFY_LEVEL 0
+#endif
+
 #define __bos(ptr) __builtin_object_size (ptr, __USE_FORTIFY_LEVEL > 1)
 #define __bos0(ptr) __builtin_object_size (ptr, 0)
 #define __warndecl(name, msg) extern void name (void)
diff -urN a/include/sys/epoll.h b/include/sys/epoll.h
--- a/include/sys/epoll.h	2005-01-06 10:06:49.000000000 +0700
+++ b/include/sys/epoll.h	2012-04-10 13:55:23.000000000 +0800
@@ -70,7 +70,7 @@
 {
   uint32_t events;	/* Epoll events */
   epoll_data_t data;	/* User data variable */
-} __attribute__ ((__packed__));
+};
 
 
 __BEGIN_DECLS
diff -urN a/include/sys/queue.h b/include/sys/queue.h
--- a/include/sys/queue.h	2002-05-02 21:41:43.000000000 +0800
+++ b/include/sys/queue.h	2012-09-07 04:56:33.000000000 +0800
@@ -1,4 +1,4 @@
-/*
+/*-
  * Copyright (c) 1991, 1993
  *	The Regents of the University of California.  All rights reserved.
  *
@@ -26,216 +26,593 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- *	@(#)queue.h	8.3 (Berkeley) 12/13/93
+ *	@(#)queue.h	8.5 (Berkeley) 8/20/94
+ * $FreeBSD: src/sys/sys/queue.h,v 1.68 2006/10/24 11:20:29 ru Exp $
  */
 
-#ifndef	_SYS_QUEUE_H
-#define	_SYS_QUEUE_H 1
+#ifndef _SYS_QUEUE_H_
+#define	_SYS_QUEUE_H_
+
+#include <sys/cdefs.h>
 
 /*
- * This file defines three types of data structures: lists, tail queues,
- * and circular queues.
+ * This file defines four types of data structures: singly-linked lists,
+ * singly-linked tail queues, lists and tail queues.
+ *
+ * A singly-linked list is headed by a single forward pointer. The elements
+ * are singly linked for minimum space and pointer manipulation overhead at
+ * the expense of O(n) removal for arbitrary elements. New elements can be
+ * added to the list after an existing element or at the head of the list.
+ * Elements being removed from the head of the list should use the explicit
+ * macro for this purpose for optimum efficiency. A singly-linked list may
+ * only be traversed in the forward direction.  Singly-linked lists are ideal
+ * for applications with large datasets and few or no removals or for
+ * implementing a LIFO queue.
+ *
+ * A singly-linked tail queue is headed by a pair of pointers, one to the
+ * head of the list and the other to the tail of the list. The elements are
+ * singly linked for minimum space and pointer manipulation overhead at the
+ * expense of O(n) removal for arbitrary elements. New elements can be added
+ * to the list after an existing element, at the head of the list, or at the
+ * end of the list. Elements being removed from the head of the tail queue
+ * should use the explicit macro for this purpose for optimum efficiency.
+ * A singly-linked tail queue may only be traversed in the forward direction.
+ * Singly-linked tail queues are ideal for applications with large datasets
+ * and few or no removals or for implementing a FIFO queue.
  *
  * A list is headed by a single forward pointer (or an array of forward
  * pointers for a hash table header). The elements are doubly linked
  * so that an arbitrary element can be removed without a need to
- * traverse the list. New elements can be added to the list after
- * an existing element or at the head of the list. A list may only be
- * traversed in the forward direction.
+ * traverse the list. New elements can be added to the list before
+ * or after an existing element or at the head of the list. A list
+ * may only be traversed in the forward direction.
  *
  * A tail queue is headed by a pair of pointers, one to the head of the
  * list and the other to the tail of the list. The elements are doubly
  * linked so that an arbitrary element can be removed without a need to
- * traverse the list. New elements can be added to the list after
- * an existing element, at the head of the list, or at the end of the
- * list. A tail queue may only be traversed in the forward direction.
- *
- * A circle queue is headed by a pair of pointers, one to the head of the
- * list and the other to the tail of the list. The elements are doubly
- * linked so that an arbitrary element can be removed without a need to
- * traverse the list. New elements can be added to the list before or after
- * an existing element, at the head of the list, or at the end of the list.
- * A circle queue may be traversed in either direction, but has a more
- * complex end of list detection.
+ * traverse the list. New elements can be added to the list before or
+ * after an existing element, at the head of the list, or at the end of
+ * the list. A tail queue may be traversed in either direction.
  *
  * For details on the use of these macros, see the queue(3) manual page.
+ *
+ *
+ *				SLIST	LIST	STAILQ	TAILQ
+ * _HEAD			+	+	+	+
+ * _HEAD_INITIALIZER		+	+	+	+
+ * _ENTRY			+	+	+	+
+ * _INIT			+	+	+	+
+ * _EMPTY			+	+	+	+
+ * _FIRST			+	+	+	+
+ * _NEXT			+	+	+	+
+ * _PREV			-	-	-	+
+ * _LAST			-	-	+	+
+ * _FOREACH			+	+	+	+
+ * _FOREACH_SAFE		+	+	+	+
+ * _FOREACH_REVERSE		-	-	-	+
+ * _FOREACH_REVERSE_SAFE	-	-	-	+
+ * _INSERT_HEAD			+	+	+	+
+ * _INSERT_BEFORE		-	+	-	+
+ * _INSERT_AFTER		+	+	+	+
+ * _INSERT_TAIL			-	-	+	+
+ * _CONCAT			-	-	+	+
+ * _REMOVE_HEAD			+	-	+	-
+ * _REMOVE			+	+	+	+
+ *
  */
+#ifdef QUEUE_MACRO_DEBUG
+/* Store the last 2 places the queue element or head was altered */
+struct qm_trace {
+	char * lastfile;
+	int lastline;
+	char * prevfile;
+	int prevline;
+};
+
+#define	TRACEBUF	struct qm_trace trace;
+#define	TRASHIT(x)	do {(x) = (void *)-1;} while (0)
+
+#define	QMD_TRACE_HEAD(head) do {					\
+	(head)->trace.prevline = (head)->trace.lastline;		\
+	(head)->trace.prevfile = (head)->trace.lastfile;		\
+	(head)->trace.lastline = __LINE__;				\
+	(head)->trace.lastfile = __FILE__;				\
+} while (0)
+
+#define	QMD_TRACE_ELEM(elem) do {					\
+	(elem)->trace.prevline = (elem)->trace.lastline;		\
+	(elem)->trace.prevfile = (elem)->trace.lastfile;		\
+	(elem)->trace.lastline = __LINE__;				\
+	(elem)->trace.lastfile = __FILE__;				\
+} while (0)
+
+#else
+#define	QMD_TRACE_ELEM(elem)
+#define	QMD_TRACE_HEAD(head)
+#define	TRACEBUF
+#define	TRASHIT(x)
+#endif	/* QUEUE_MACRO_DEBUG */
 
 /*
- * List definitions.
+ * Singly-linked List declarations.
  */
-#define LIST_HEAD(name, type)						\
+#define	SLIST_HEAD(name, type)						\
 struct name {								\
-	struct type *lh_first;	/* first element */			\
+	struct type *slh_first;	/* first element */			\
 }
 
-#define LIST_ENTRY(type)						\
+#define	SLIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define	SLIST_ENTRY(type)						\
 struct {								\
-	struct type *le_next;	/* next element */			\
-	struct type **le_prev;	/* address of previous next element */	\
+	struct type *sle_next;	/* next element */			\
 }
 
 /*
- * List functions.
+ * Singly-linked List functions.
+ */
+#define	SLIST_EMPTY(head)	((head)->slh_first == NULL)
+
+#define	SLIST_FIRST(head)	((head)->slh_first)
+
+#define	SLIST_FOREACH(var, head, field)					\
+	for ((var) = SLIST_FIRST((head));				\
+	    (var);							\
+	    (var) = SLIST_NEXT((var), field))
+
+#define	SLIST_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = SLIST_FIRST((head));				\
+	    (var) && ((tvar) = SLIST_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	SLIST_FOREACH_PREVPTR(var, varp, head, field)			\
+	for ((varp) = &SLIST_FIRST((head));				\
+	    ((var) = *(varp)) != NULL;					\
+	    (varp) = &SLIST_NEXT((var), field))
+
+#define	SLIST_INIT(head) do {						\
+	SLIST_FIRST((head)) = NULL;					\
+} while (0)
+
+#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
+	SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field);	\
+	SLIST_NEXT((slistelm), field) = (elm);				\
+} while (0)
+
+#define	SLIST_INSERT_HEAD(head, elm, field) do {			\
+	SLIST_NEXT((elm), field) = SLIST_FIRST((head));			\
+	SLIST_FIRST((head)) = (elm);					\
+} while (0)
+
+#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)
+
+#define	SLIST_REMOVE(head, elm, type, field) do {			\
+	if (SLIST_FIRST((head)) == (elm)) {				\
+		SLIST_REMOVE_HEAD((head), field);			\
+	}								\
+	else {								\
+		struct type *curelm = SLIST_FIRST((head));		\
+		while (SLIST_NEXT(curelm, field) != (elm))		\
+			curelm = SLIST_NEXT(curelm, field);		\
+		SLIST_NEXT(curelm, field) =				\
+		    SLIST_NEXT(SLIST_NEXT(curelm, field), field);	\
+	}								\
+	TRASHIT((elm)->field.sle_next);					\
+} while (0)
+
+#define	SLIST_REMOVE_HEAD(head, field) do {				\
+	SLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field);	\
+} while (0)
+
+/*
+ * Singly-linked Tail queue declarations.
  */
-#define	LIST_INIT(head) {						\
-	(head)->lh_first = NULL;					\
+#define	STAILQ_HEAD(name, type)						\
+struct name {								\
+	struct type *stqh_first;/* first element */			\
+	struct type **stqh_last;/* addr of last next element */		\
 }
 
-#define LIST_INSERT_AFTER(listelm, elm, field) {			\
-	if (((elm)->field.le_next = (listelm)->field.le_next) != NULL)	\
-		(listelm)->field.le_next->field.le_prev =		\
-		    &(elm)->field.le_next;				\
-	(listelm)->field.le_next = (elm);				\
-	(elm)->field.le_prev = &(listelm)->field.le_next;		\
+#define	STAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).stqh_first }
+
+#define	STAILQ_ENTRY(type)						\
+struct {								\
+	struct type *stqe_next;	/* next element */			\
 }
 
-#define LIST_INSERT_HEAD(head, elm, field) {				\
-	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
-		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
-	(head)->lh_first = (elm);					\
-	(elm)->field.le_prev = &(head)->lh_first;			\
+/*
+ * Singly-linked Tail queue functions.
+ */
+#define	STAILQ_CONCAT(head1, head2) do {				\
+	if (!STAILQ_EMPTY((head2))) {					\
+		*(head1)->stqh_last = (head2)->stqh_first;		\
+		(head1)->stqh_last = (head2)->stqh_last;		\
+		STAILQ_INIT((head2));					\
+	}								\
+} while (0)
+
+#define	STAILQ_EMPTY(head)	((head)->stqh_first == NULL)
+
+#define	STAILQ_FIRST(head)	((head)->stqh_first)
+
+#define	STAILQ_FOREACH(var, head, field)				\
+	for((var) = STAILQ_FIRST((head));				\
+	   (var);							\
+	   (var) = STAILQ_NEXT((var), field))
+
+
+#define	STAILQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = STAILQ_FIRST((head));				\
+	    (var) && ((tvar) = STAILQ_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	STAILQ_INIT(head) do {						\
+	STAILQ_FIRST((head)) = NULL;					\
+	(head)->stqh_last = &STAILQ_FIRST((head));			\
+} while (0)
+
+#define	STAILQ_INSERT_AFTER(head, tqelm, elm, field) do {		\
+	if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL)\
+		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
+	STAILQ_NEXT((tqelm), field) = (elm);				\
+} while (0)
+
+#define	STAILQ_INSERT_HEAD(head, elm, field) do {			\
+	if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL)	\
+		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
+	STAILQ_FIRST((head)) = (elm);					\
+} while (0)
+
+#define	STAILQ_INSERT_TAIL(head, elm, field) do {			\
+	STAILQ_NEXT((elm), field) = NULL;				\
+	*(head)->stqh_last = (elm);					\
+	(head)->stqh_last = &STAILQ_NEXT((elm), field);			\
+} while (0)
+
+#define	STAILQ_LAST(head, type, field)					\
+	(STAILQ_EMPTY((head)) ?						\
+		NULL :							\
+	        ((struct type *)(void *)				\
+		((char *)((head)->stqh_last) - __offsetof(struct type, field))))
+
+#define	STAILQ_NEXT(elm, field)	((elm)->field.stqe_next)
+
+#define	STAILQ_REMOVE(head, elm, type, field) do {			\
+	if (STAILQ_FIRST((head)) == (elm)) {				\
+		STAILQ_REMOVE_HEAD((head), field);			\
+	}								\
+	else {								\
+		struct type *curelm = STAILQ_FIRST((head));		\
+		while (STAILQ_NEXT(curelm, field) != (elm))		\
+			curelm = STAILQ_NEXT(curelm, field);		\
+		if ((STAILQ_NEXT(curelm, field) =			\
+		     STAILQ_NEXT(STAILQ_NEXT(curelm, field), field)) == NULL)\
+			(head)->stqh_last = &STAILQ_NEXT((curelm), field);\
+	}								\
+	TRASHIT((elm)->field.stqe_next);				\
+} while (0)
+
+#define	STAILQ_REMOVE_HEAD(head, field) do {				\
+	if ((STAILQ_FIRST((head)) =					\
+	     STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL)		\
+		(head)->stqh_last = &STAILQ_FIRST((head));		\
+} while (0)
+
+/*
+ * List declarations.
+ */
+#define	LIST_HEAD(name, type)						\
+struct name {								\
+	struct type *lh_first;	/* first element */			\
 }
 
-#define LIST_REMOVE(elm, field) {					\
-	if ((elm)->field.le_next != NULL)				\
-		(elm)->field.le_next->field.le_prev = 			\
-		    (elm)->field.le_prev;				\
-	*(elm)->field.le_prev = (elm)->field.le_next;			\
+#define	LIST_HEAD_INITIALIZER(head)					\
+	{ NULL }
+
+#define	LIST_ENTRY(type)						\
+struct {								\
+	struct type *le_next;	/* next element */			\
+	struct type **le_prev;	/* address of previous next element */	\
 }
 
 /*
- * Tail queue definitions.
+ * List functions.
  */
-#define TAILQ_HEAD(name, type)						\
+
+#if (defined(_KERNEL) && defined(INVARIANTS))
+#define	QMD_LIST_CHECK_HEAD(head, field) do {				\
+	if (LIST_FIRST((head)) != NULL &&				\
+	    LIST_FIRST((head))->field.le_prev !=			\
+	     &LIST_FIRST((head)))					\
+		panic("Bad list head %p first->prev != head", (head));	\
+} while (0)
+
+#define	QMD_LIST_CHECK_NEXT(elm, field) do {				\
+	if (LIST_NEXT((elm), field) != NULL &&				\
+	    LIST_NEXT((elm), field)->field.le_prev !=			\
+	     &((elm)->field.le_next))					\
+	     	panic("Bad link elm %p next->prev != elm", (elm));	\
+} while (0)
+
+#define	QMD_LIST_CHECK_PREV(elm, field) do {				\
+	if (*(elm)->field.le_prev != (elm))				\
+		panic("Bad link elm %p prev->next != elm", (elm));	\
+} while (0)
+#else
+#define	QMD_LIST_CHECK_HEAD(head, field)
+#define	QMD_LIST_CHECK_NEXT(elm, field)
+#define	QMD_LIST_CHECK_PREV(elm, field)
+#endif /* (_KERNEL && INVARIANTS) */
+
+#define	LIST_EMPTY(head)	((head)->lh_first == NULL)
+
+#define	LIST_FIRST(head)	((head)->lh_first)
+
+#define	LIST_FOREACH(var, head, field)					\
+	for ((var) = LIST_FIRST((head));				\
+	    (var);							\
+	    (var) = LIST_NEXT((var), field))
+
+#define	LIST_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = LIST_FIRST((head));				\
+	    (var) && ((tvar) = LIST_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	LIST_INIT(head) do {						\
+	LIST_FIRST((head)) = NULL;					\
+} while (0)
+
+#define	LIST_INSERT_AFTER(listelm, elm, field) do {			\
+	QMD_LIST_CHECK_NEXT(listelm, field);				\
+	if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL)\
+		LIST_NEXT((listelm), field)->field.le_prev =		\
+		    &LIST_NEXT((elm), field);				\
+	LIST_NEXT((listelm), field) = (elm);				\
+	(elm)->field.le_prev = &LIST_NEXT((listelm), field);		\
+} while (0)
+
+#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
+	QMD_LIST_CHECK_PREV(listelm, field);				\
+	(elm)->field.le_prev = (listelm)->field.le_prev;		\
+	LIST_NEXT((elm), field) = (listelm);				\
+	*(listelm)->field.le_prev = (elm);				\
+	(listelm)->field.le_prev = &LIST_NEXT((elm), field);		\
+} while (0)
+
+#define	LIST_INSERT_HEAD(head, elm, field) do {				\
+	QMD_LIST_CHECK_HEAD((head), field);				\
+	if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)	\
+		LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);\
+	LIST_FIRST((head)) = (elm);					\
+	(elm)->field.le_prev = &LIST_FIRST((head));			\
+} while (0)
+
+#define	LIST_NEXT(elm, field)	((elm)->field.le_next)
+
+#define	LIST_REMOVE(elm, field) do {					\
+	QMD_LIST_CHECK_NEXT(elm, field);				\
+	QMD_LIST_CHECK_PREV(elm, field);				\
+	if (LIST_NEXT((elm), field) != NULL)				\
+		LIST_NEXT((elm), field)->field.le_prev = 		\
+		    (elm)->field.le_prev;				\
+	*(elm)->field.le_prev = LIST_NEXT((elm), field);		\
+	TRASHIT((elm)->field.le_next);					\
+	TRASHIT((elm)->field.le_prev);					\
+} while (0)
+
+/*
+ * Tail queue declarations.
+ */
+#define	TAILQ_HEAD(name, type)						\
 struct name {								\
 	struct type *tqh_first;	/* first element */			\
 	struct type **tqh_last;	/* addr of last next element */		\
+	TRACEBUF							\
 }
 
-#define TAILQ_ENTRY(type)						\
+#define	TAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).tqh_first }
+
+#define	TAILQ_ENTRY(type)						\
 struct {								\
 	struct type *tqe_next;	/* next element */			\
 	struct type **tqe_prev;	/* address of previous next element */	\
+	TRACEBUF							\
 }
 
 /*
  * Tail queue functions.
  */
-#define	TAILQ_INIT(head) {						\
-	(head)->tqh_first = NULL;					\
-	(head)->tqh_last = &(head)->tqh_first;				\
-}
-
-#define TAILQ_INSERT_HEAD(head, elm, field) {				\
-	if (((elm)->field.tqe_next = (head)->tqh_first) != NULL)	\
-		(elm)->field.tqe_next->field.tqe_prev =			\
-		    &(elm)->field.tqe_next;				\
+#if (defined(_KERNEL) && defined(INVARIANTS))
+#define	QMD_TAILQ_CHECK_HEAD(head, field) do {				\
+	if (!TAILQ_EMPTY(head) &&					\
+	    TAILQ_FIRST((head))->field.tqe_prev !=			\
+	     &TAILQ_FIRST((head)))					\
+		panic("Bad tailq head %p first->prev != head", (head));	\
+} while (0)
+
+#define	QMD_TAILQ_CHECK_TAIL(head, field) do {				\
+	if (*(head)->tqh_last != NULL)					\
+	    	panic("Bad tailq NEXT(%p->tqh_last) != NULL", (head)); 	\
+} while (0)
+
+#define	QMD_TAILQ_CHECK_NEXT(elm, field) do {				\
+	if (TAILQ_NEXT((elm), field) != NULL &&				\
+	    TAILQ_NEXT((elm), field)->field.tqe_prev !=			\
+	     &((elm)->field.tqe_next))					\
+		panic("Bad link elm %p next->prev != elm", (elm));	\
+} while (0)
+
+#define	QMD_TAILQ_CHECK_PREV(elm, field) do {				\
+	if (*(elm)->field.tqe_prev != (elm))				\
+		panic("Bad link elm %p prev->next != elm", (elm));	\
+} while (0)
+#else
+#define	QMD_TAILQ_CHECK_HEAD(head, field)
+#define	QMD_TAILQ_CHECK_TAIL(head, headname)
+#define	QMD_TAILQ_CHECK_NEXT(elm, field)
+#define	QMD_TAILQ_CHECK_PREV(elm, field)
+#endif /* (_KERNEL && INVARIANTS) */
+
+#define	TAILQ_CONCAT(head1, head2, field) do {				\
+	if (!TAILQ_EMPTY(head2)) {					\
+		*(head1)->tqh_last = (head2)->tqh_first;		\
+		(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;	\
+		(head1)->tqh_last = (head2)->tqh_last;			\
+		TAILQ_INIT((head2));					\
+		QMD_TRACE_HEAD(head1);					\
+		QMD_TRACE_HEAD(head2);					\
+	}								\
+} while (0)
+
+#define	TAILQ_EMPTY(head)	((head)->tqh_first == NULL)
+
+#define	TAILQ_FIRST(head)	((head)->tqh_first)
+
+#define	TAILQ_FOREACH(var, head, field)					\
+	for ((var) = TAILQ_FIRST((head));				\
+	    (var);							\
+	    (var) = TAILQ_NEXT((var), field))
+
+#define	TAILQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = TAILQ_FIRST((head));				\
+	    (var) && ((tvar) = TAILQ_NEXT((var), field), 1);		\
+	    (var) = (tvar))
+
+#define	TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
+	for ((var) = TAILQ_LAST((head), headname);			\
+	    (var);							\
+	    (var) = TAILQ_PREV((var), headname, field))
+
+#define	TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
+	for ((var) = TAILQ_LAST((head), headname);			\
+	    (var) && ((tvar) = TAILQ_PREV((var), headname, field), 1);	\
+	    (var) = (tvar))
+
+#define	TAILQ_INIT(head) do {						\
+	TAILQ_FIRST((head)) = NULL;					\
+	(head)->tqh_last = &TAILQ_FIRST((head));			\
+	QMD_TRACE_HEAD(head);						\
+} while (0)
+
+#define	TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	QMD_TAILQ_CHECK_NEXT(listelm, field);				\
+	if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL)\
+		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
+		    &TAILQ_NEXT((elm), field);				\
+	else {								\
+		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
+		QMD_TRACE_HEAD(head);					\
+	}								\
+	TAILQ_NEXT((listelm), field) = (elm);				\
+	(elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field);		\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+	QMD_TRACE_ELEM(&listelm->field);				\
+} while (0)
+
+#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
+	QMD_TAILQ_CHECK_PREV(listelm, field);				\
+	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
+	TAILQ_NEXT((elm), field) = (listelm);				\
+	*(listelm)->field.tqe_prev = (elm);				\
+	(listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field);		\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+	QMD_TRACE_ELEM(&listelm->field);				\
+} while (0)
+
+#define	TAILQ_INSERT_HEAD(head, elm, field) do {			\
+	QMD_TAILQ_CHECK_HEAD(head, field);				\
+	if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL)	\
+		TAILQ_FIRST((head))->field.tqe_prev =			\
+		    &TAILQ_NEXT((elm), field);				\
 	else								\
-		(head)->tqh_last = &(elm)->field.tqe_next;		\
-	(head)->tqh_first = (elm);					\
-	(elm)->field.tqe_prev = &(head)->tqh_first;			\
-}
-
-#define TAILQ_INSERT_TAIL(head, elm, field) {				\
-	(elm)->field.tqe_next = NULL;					\
+		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
+	TAILQ_FIRST((head)) = (elm);					\
+	(elm)->field.tqe_prev = &TAILQ_FIRST((head));			\
+	QMD_TRACE_HEAD(head);						\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+} while (0)
+
+#define	TAILQ_INSERT_TAIL(head, elm, field) do {			\
+	QMD_TAILQ_CHECK_TAIL(head, field);				\
+	TAILQ_NEXT((elm), field) = NULL;				\
 	(elm)->field.tqe_prev = (head)->tqh_last;			\
 	*(head)->tqh_last = (elm);					\
-	(head)->tqh_last = &(elm)->field.tqe_next;			\
-}
-
-#define TAILQ_INSERT_AFTER(head, listelm, elm, field) {			\
-	if (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\
-		(elm)->field.tqe_next->field.tqe_prev = 		\
-		    &(elm)->field.tqe_next;				\
-	else								\
-		(head)->tqh_last = &(elm)->field.tqe_next;		\
-	(listelm)->field.tqe_next = (elm);				\
-	(elm)->field.tqe_prev = &(listelm)->field.tqe_next;		\
-}
-
-#define TAILQ_REMOVE(head, elm, field) {				\
-	if (((elm)->field.tqe_next) != NULL)				\
-		(elm)->field.tqe_next->field.tqe_prev = 		\
+	(head)->tqh_last = &TAILQ_NEXT((elm), field);			\
+	QMD_TRACE_HEAD(head);						\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+} while (0)
+
+#define	TAILQ_LAST(head, headname)					\
+	(*(((struct headname *)((head)->tqh_last))->tqh_last))
+
+#define	TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
+
+#define	TAILQ_PREV(elm, headname, field)				\
+	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
+
+#define	TAILQ_REMOVE(head, elm, field) do {				\
+	QMD_TAILQ_CHECK_NEXT(elm, field);				\
+	QMD_TAILQ_CHECK_PREV(elm, field);				\
+	if ((TAILQ_NEXT((elm), field)) != NULL)				\
+		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
 		    (elm)->field.tqe_prev;				\
-	else								\
+	else {								\
 		(head)->tqh_last = (elm)->field.tqe_prev;		\
-	*(elm)->field.tqe_prev = (elm)->field.tqe_next;			\
-}
+		QMD_TRACE_HEAD(head);					\
+	}								\
+	*(elm)->field.tqe_prev = TAILQ_NEXT((elm), field);		\
+	TRASHIT((elm)->field.tqe_next);					\
+	TRASHIT((elm)->field.tqe_prev);					\
+	QMD_TRACE_ELEM(&(elm)->field);					\
+} while (0)
 
-/*
- * Circular queue definitions.
- */
-#define CIRCLEQ_HEAD(name, type)					\
-struct name {								\
-	struct type *cqh_first;		/* first element */		\
-	struct type *cqh_last;		/* last element */		\
-}
 
-#define CIRCLEQ_ENTRY(type)						\
-struct {								\
-	struct type *cqe_next;		/* next element */		\
-	struct type *cqe_prev;		/* previous element */		\
-}
+#ifdef _KERNEL
 
 /*
- * Circular queue functions.
+ * XXX insque() and remque() are an old way of handling certain queues.
+ * They bogusly assumes that all queue heads look alike.
  */
-#define	CIRCLEQ_INIT(head) {						\
-	(head)->cqh_first = (void *)(head);				\
-	(head)->cqh_last = (void *)(head);				\
-}
 
-#define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) {		\
-	(elm)->field.cqe_next = (listelm)->field.cqe_next;		\
-	(elm)->field.cqe_prev = (listelm);				\
-	if ((listelm)->field.cqe_next == (void *)(head))		\
-		(head)->cqh_last = (elm);				\
-	else								\
-		(listelm)->field.cqe_next->field.cqe_prev = (elm);	\
-	(listelm)->field.cqe_next = (elm);				\
-}
+struct quehead {
+	struct quehead *qh_link;
+	struct quehead *qh_rlink;
+};
 
-#define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) {		\
-	(elm)->field.cqe_next = (listelm);				\
-	(elm)->field.cqe_prev = (listelm)->field.cqe_prev;		\
-	if ((listelm)->field.cqe_prev == (void *)(head))		\
-		(head)->cqh_first = (elm);				\
-	else								\
-		(listelm)->field.cqe_prev->field.cqe_next = (elm);	\
-	(listelm)->field.cqe_prev = (elm);				\
-}
+#ifdef __CC_SUPPORTS___INLINE
 
-#define CIRCLEQ_INSERT_HEAD(head, elm, field) {				\
-	(elm)->field.cqe_next = (head)->cqh_first;			\
-	(elm)->field.cqe_prev = (void *)(head);				\
-	if ((head)->cqh_last == (void *)(head))				\
-		(head)->cqh_last = (elm);				\
-	else								\
-		(head)->cqh_first->field.cqe_prev = (elm);		\
-	(head)->cqh_first = (elm);					\
-}
+static __inline void
+insque(void *a, void *b)
+{
+	struct quehead *element = (struct quehead *)a,
+		 *head = (struct quehead *)b;
 
-#define CIRCLEQ_INSERT_TAIL(head, elm, field) {				\
-	(elm)->field.cqe_next = (void *)(head);				\
-	(elm)->field.cqe_prev = (head)->cqh_last;			\
-	if ((head)->cqh_first == (void *)(head))			\
-		(head)->cqh_first = (elm);				\
-	else								\
-		(head)->cqh_last->field.cqe_next = (elm);		\
-	(head)->cqh_last = (elm);					\
+	element->qh_link = head->qh_link;
+	element->qh_rlink = head;
+	head->qh_link = element;
+	element->qh_link->qh_rlink = element;
 }
 
-#define	CIRCLEQ_REMOVE(head, elm, field) {				\
-	if ((elm)->field.cqe_next == (void *)(head))			\
-		(head)->cqh_last = (elm)->field.cqe_prev;		\
-	else								\
-		(elm)->field.cqe_next->field.cqe_prev =			\
-		    (elm)->field.cqe_prev;				\
-	if ((elm)->field.cqe_prev == (void *)(head))			\
-		(head)->cqh_first = (elm)->field.cqe_next;		\
-	else								\
-		(elm)->field.cqe_prev->field.cqe_next =			\
-		    (elm)->field.cqe_next;				\
+static __inline void
+remque(void *a)
+{
+	struct quehead *element = (struct quehead *)a;
+
+	element->qh_link->qh_rlink = element->qh_rlink;
+	element->qh_rlink->qh_link = element->qh_link;
+	element->qh_rlink = 0;
 }
-#endif	/* sys/queue.h */
+
+#else /* !__CC_SUPPORTS___INLINE */
+
+void	insque(void *a, void *b);
+void	remque(void *a);
+
+#endif /* __CC_SUPPORTS___INLINE */
+
+#endif /* _KERNEL */
+
+#endif /* !_SYS_QUEUE_H_ */
diff -urN a/include/sys/quota.h b/include/sys/quota.h
--- a/include/sys/quota.h	2002-01-03 11:00:09.000000000 +0700
+++ b/include/sys/quota.h	2012-04-10 13:55:23.000000000 +0800
@@ -31,7 +31,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * Version: $Id: quota.h,v 1.1 2002/01/03 04:00:09 andersen Exp $
+ * Version: $Id: quota.h,v 1.1.1.1 2007-01-09 06:46:10 steven Exp $
  */
 
 #ifndef _SYS_QUOTA_H
diff -urN a/include/sys/syscall.h b/include/sys/syscall.h
--- a/include/sys/syscall.h	2007-02-02 09:24:29.000000000 +0700
+++ b/include/sys/syscall.h	2012-04-10 13:55:23.000000000 +0800
@@ -31,7 +31,7 @@
 #include <features.h>
 #include <bits/sysnum.h>
 #if defined _LIBC
-# include <bits/syscalls.h>
+#include <bits/syscalls.h>
 #endif
 
 #endif
diff -urN a/include/sys/syslog.h b/include/sys/syslog.h
--- a/include/sys/syslog.h	2001-09-27 13:21:15.000000000 +0800
+++ b/include/sys/syslog.h	2012-04-10 13:55:23.000000000 +0800
@@ -67,10 +67,13 @@
 				/* mark "facility" */
 #define	INTERNAL_MARK	LOG_MAKEPRI(LOG_NFACILITIES, 0)
 typedef struct _code {
-	char	*c_name;
-	int	c_val;
+	const char      *c_name;
+	int             c_val;
 } CODE;
 
+#ifdef SYSLOG_NAMES_CONST
+const
+#endif
 CODE prioritynames[] =
   {
     { "alert", LOG_ALERT },
@@ -119,6 +122,9 @@
 #define	LOG_FAC(p)	(((p) & LOG_FACMASK) >> 3)
 
 #ifdef SYSLOG_NAMES
+#ifdef SYSLOG_NAMES_CONST
+const
+#endif
 CODE facilitynames[] =
   {
     { "auth", LOG_AUTH },
diff -urN a/include/time.h b/include/time.h
--- a/include/time.h	2005-04-28 21:11:29.000000000 +0800
+++ b/include/time.h	2012-04-10 13:55:23.000000000 +0800
@@ -287,7 +287,6 @@
 
 /* Defined in localtime.c.  */
 #ifdef __UCLIBC_MJN3_ONLY__
-#warning "mjn3 FIXME: __tzname, __daylight, and __timezone have a prototype but are not defined."
 extern char *__tzname[2];	/* Current timezone names.  */
 extern int __daylight;		/* If daylight-saving time is ever in use.  */
 extern long int __timezone;	/* Seconds west of UTC.  */
@@ -355,7 +354,6 @@
 extern int clock_settime (clockid_t __clock_id, __const struct timespec *__tp) __THROW;
 
 #ifdef __UCLIBC_MJN3_ONLY__
-#warning "mjn3 FIXME: a bunch of unimplemented function prototypes."
 #  ifdef __USE_XOPEN2K
 /* High-resolution sleep with the specified clock.
 
@@ -394,7 +392,6 @@
 
 
 #ifdef __UCLIBC_MJN3_ONLY__
-#warning "mjn3 FIXME: a bunch of unimplemented function prototypes."
 # ifdef __USE_XOPEN_EXTENDED
 /* Set to one of the following values to indicate an error.
      1  the DATEMSK environment variable is null or undefined,
diff -urN a/ldso/include/dl-string.h b/ldso/include/dl-string.h
--- a/ldso/include/dl-string.h	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/include/dl-string.h	2012-04-10 13:55:23.000000000 +0800
@@ -115,36 +115,36 @@
 
 static __always_inline char * _dl_strrchr(const char *str, int c)
 {
-	register char *prev = 0;
-	register char *ptr = (char *) str-1;
+    register char *prev = 0;
+    register char *ptr = (char *) str-1;
 
-	while (*++ptr != '\0') {
-		if (*ptr == c)
-			prev = ptr;
-	}
-	if (c == '\0')
-		return(ptr);
-	return(prev);
+    while (*++ptr != '\0') {
+	if (*ptr == c)
+	    prev = ptr;
+    }
+    if (c == '\0')
+	return(ptr);
+    return(prev);
 }
 
 static __always_inline char * _dl_strstr(const char *s1, const char *s2)
 {
-	register const char *s = s1;
-	register const char *p = s2;
+    register const char *s = s1;
+    register const char *p = s2;
 
-	do {
+    do {
 		if (!*p)
-			return (char *) s1;;
-		if (*p == *s) {
-			++p;
-			++s;
-		} else {
-			p = s2;
+	    return (char *) s1;;
+	if (*p == *s) {
+	    ++p;
+	    ++s;
+	} else {
+	    p = s2;
 			if (!*s)
-				return NULL;
-			s = ++s1;
-		}
-	} while (1);
+	      return NULL;
+	    s = ++s1;
+	}
+    } while (1);
 }
 
 static __always_inline void * _dl_memcpy(void * dst, const void * src, size_t len)
@@ -176,28 +176,28 @@
 /* Will generate smaller and faster code due to loop unrolling.*/
 static __always_inline void * _dl_memset(void *to, int c, size_t n)
 {
-	unsigned long chunks;
-	unsigned long *tmp_to;
+        unsigned long chunks;
+        unsigned long *tmp_to;
 	unsigned char *tmp_char;
 
-	chunks = n / 4;
-	tmp_to = to + n;
-	c = c << 8 | c;
-	c = c << 16 | c;
-	if (!chunks)
-		goto lessthan4;
-	do {
-		*--tmp_to = c;
-	} while (--chunks);
-lessthan4:
-	n = n % 4;
+        chunks = n / 4;
+        tmp_to = to + n;
+        c = c << 8 | c;
+        c = c << 16 | c;
+        if (!chunks)
+                goto lessthan4;
+        do {
+                *--tmp_to = c;
+        } while (--chunks);
+ lessthan4:
+        n = n % 4;
 	if (!n)
 		return to;
-	tmp_char = (unsigned char *)tmp_to;
-	do {
-		*--tmp_char = c;
-	} while (--n);
-	return to;
+        tmp_char = (unsigned char *)tmp_to;
+        do {
+                *--tmp_char = c;
+        } while (--n);
+        return to;
 }
 #else
 static __always_inline void * _dl_memset(void * str,int c,size_t len)
@@ -256,9 +256,9 @@
 	do {
 		char temp = i & 0xf;
 		if (temp <= 0x09)
-			*--p = '0' + temp;
+		    *--p = '0' + temp;
 		else
-			*--p = 'a' - 0x0a + temp;
+		    *--p = 'a' - 0x0a + temp;
 		i >>= 4;
 	} while (i > 0);
 	*--p = 'x';
diff -urN a/ldso/include/dl-syscall.h b/ldso/include/dl-syscall.h
--- a/ldso/include/dl-syscall.h	2007-01-28 12:51:31.000000000 +0700
+++ b/ldso/include/dl-syscall.h	2012-04-10 13:55:23.000000000 +0800
@@ -65,11 +65,11 @@
 
 #define __NR__dl_write __NR_write
 static inline _syscall3(unsigned long, _dl_write, int, fd,
-                        const void *, buf, unsigned long, count);
+	    const void *, buf, unsigned long, count);
 
 #define __NR__dl_read __NR_read
 static inline _syscall3(unsigned long, _dl_read, int, fd,
-                        const void *, buf, unsigned long, count);
+	    const void *, buf, unsigned long, count);
 
 #define __NR__dl_mprotect __NR_mprotect
 static inline _syscall3(int, _dl_mprotect, const void *, addr,
@@ -133,9 +133,9 @@
 /* first try mmap(), syscall6() style */
 #if defined(__UCLIBC_MMAP_HAS_6_ARGS__) && defined(__NR_mmap)
 
-# define __NR__dl_mmap __NR_mmap
+#define __NR__dl_mmap __NR_mmap
 static inline _syscall6(void *, _dl_mmap, void *, start, size_t, length,
-                        int, prot, int, flags, int, fd, off_t, offset);
+		int, prot, int, flags, int, fd, off_t, offset);
 
 /* then try mmap2() */
 #elif defined(__NR_mmap2)
@@ -164,10 +164,10 @@
 /* finally, fall back to mmap(), syscall1() style */
 #elif defined(__NR_mmap)
 
-# define __NR__dl_mmap_real __NR_mmap
+#define __NR__dl_mmap_real __NR_mmap
 static inline _syscall1(void *, _dl_mmap_real, unsigned long *, buffer);
 static inline void * _dl_mmap(void * addr, unsigned long size, int prot,
-                              int flags, int fd, unsigned long offset)
+		int flags, int fd, unsigned long offset)
 {
 	unsigned long buffer[6];
 
@@ -181,7 +181,7 @@
 }
 
 #else
-# error "Your architecture doesn't seem to provide mmap() !?"
+#error "Your architecture doesn't seem to provide mmap() !?"
 #endif
 
 #endif /* _LD_SYSCALL_H_ */
diff -urN a/ldso/ldso/cris/dl-startup.h b/ldso/ldso/cris/dl-startup.h
--- a/ldso/ldso/cris/dl-startup.h	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/cris/dl-startup.h	2012-04-10 13:55:23.000000000 +0800
@@ -29,13 +29,13 @@
 "	.globl _start\n"		\
 "	.type _start,@function\n"	\
 "_start:\n"				\
-"	move.d	$sp,$r10\n"		\
-"	move.d	$pc,$r9\n"		\
-"	add.d	_dl_start - ., $r9\n"	\
-"	jsr	$r9\n"			\
-"	moveq	0,$r8\n"		\
-"	move	$r8,$srp\n"		\
-"	jump	$r10\n"			\
+"	move.d $sp,$r10\n"		\
+"	move.d $pc,$r9\n"		\
+"	add.d _dl_start - ., $r9\n"	\
+"	jsr $r9\n"			\
+"	moveq 0,$r8\n"			\
+"	move $r8,$srp\n"		\
+"	jump $r10\n"			\
 "	.size _start,.-_start\n"	\
 "	.previous\n"			\
 );
diff -urN a/ldso/ldso/cris/resolve.S b/ldso/ldso/cris/resolve.S
--- a/ldso/ldso/cris/resolve.S	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/cris/resolve.S	2012-04-10 13:55:23.000000000 +0800
@@ -56,33 +56,33 @@
 #else
 
 _dl_linux_resolve:
-	push	$r13
-	push	$r12
-	push	$r11
-	push	$r10
-	push	$r9
-	push	$r0
-	push	$srp
-	move.d	[$sp+7*4],$r11
-	move	$mof,$r10
+	push $r13
+	push $r12
+	push $r11
+	push $r10
+	push $r9
+	push $r0
+	push $srp
+	move.d [$sp+7*4],$r11
+	move $mof,$r10
 #ifdef __PIC__
-	move.d	$pc,$r0
-	sub.d	.:GOTOFF,$r0
-	move.d	_dl_linux_resolver:PLTG,$r9
-	add.d	$r0,$r9
-	jsr	$r9
+	move.d $pc,$r0
+	sub.d .:GOTOFF,$r0
+	move.d _dl_linux_resolver:PLTG,$r9
+	add.d $r0,$r9
+	jsr $r9
 #else
-	jsr	_dl_linux_resolver
+	jsr _dl_linux_resolver
 #endif
-	move.d	$r10,[$sp+7*4]
-	pop	$srp
-	pop	$r0
-	pop	$r9
-	pop	$r10
-	pop	$r11
-	pop	$r12
-	pop	$r13
-	jump	[$sp+]
+	move.d $r10,[$sp+7*4]
+	pop $srp
+	pop $r0
+	pop $r9
+	pop $r10
+	pop $r11
+	pop $r12
+	pop $r13
+	jump [$sp+]
 
 #endif /* __arch_v32 */
 
diff -urN a/ldso/ldso/dl-elf.c b/ldso/ldso/dl-elf.c
--- a/ldso/ldso/dl-elf.c	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/dl-elf.c	2012-04-10 13:55:23.000000000 +0800
@@ -115,13 +115,13 @@
 #endif
 
 
-void
+void 
 _dl_protect_relro (struct elf_resolve *l)
 {
 	ElfW(Addr) start = ((l->loadaddr + l->relro_addr)
-			    & ~(_dl_pagesize - 1));
+			    & PAGE_ALIGN);
 	ElfW(Addr) end = ((l->loadaddr + l->relro_addr + l->relro_size)
-			  & ~(_dl_pagesize - 1));
+			  & PAGE_ALIGN);
 	_dl_if_debug_dprint("RELRO protecting %s:  start:%x, end:%x\n", l->libname, start, end);
 	if (start != end &&
 	    _dl_mprotect ((void *) start, end - start, PROT_READ) < 0) {
@@ -169,7 +169,7 @@
 	/* Replace colons with zeros in path_list */
 	/* : at the beginning or end of path maps to CWD */
 	/* :: anywhere maps CWD */
-	/* "" maps to CWD */
+	/* "" maps to CWD */ 
 	done = 0;
 	path_n = path;
 	do {
@@ -351,7 +351,7 @@
 	int i, flags, piclib, infile;
 	ElfW(Addr) relro_addr = 0;
 	size_t relro_size = 0;
-	struct stat st;
+		struct stat st;
 
 	libaddr = 0;
 	infile = _dl_open(libname, O_RDONLY, 0);
@@ -449,7 +449,7 @@
 		ppnt++;
 	}
 
-	maxvma = (maxvma + ADDR_ALIGN) & ~ADDR_ALIGN;
+	maxvma = (maxvma + ADDR_ALIGN) & PAGE_ALIGN;
 	minvma = minvma & ~0xffffU;
 
 	flags = MAP_PRIVATE /*| MAP_DENYWRITE */ ;
@@ -650,7 +650,7 @@
 		return goof;
 	tpnt = rpnt->dyn;
 
-	if(!(tpnt->init_flag & RELOCS_DONE))
+	if(!(tpnt->init_flag & RELOCS_DONE)) 
 		_dl_if_debug_dprint("relocation processing: %s\n", tpnt->libname);
 
 	if (unlikely(tpnt->dynamic_info[UNSUPPORTED_RELOC_TYPE])) {
@@ -685,7 +685,7 @@
 	if (tpnt->dynamic_info[DT_JMPREL] &&
 	    (!(tpnt->init_flag & JMP_RELOCS_DONE) ||
 	     (now_flag && !(tpnt->rtld_flags & now_flag)))) {
-		tpnt->rtld_flags |= now_flag;
+		tpnt->rtld_flags |= now_flag; 
 		if (!(tpnt->rtld_flags & RTLD_NOW)) {
 			_dl_parse_lazy_relocation_information(rpnt,
 					tpnt->dynamic_info[DT_JMPREL],
diff -urN a/ldso/ldso/dl-startup.c b/ldso/ldso/dl-startup.c
--- a/ldso/ldso/dl-startup.c	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/dl-startup.c	2012-04-10 13:55:23.000000000 +0800
@@ -234,7 +234,7 @@
 		for (indx = 0; indx < INDX_MAX; indx++) {
 			unsigned int i;
 			unsigned long *reloc_addr;
-			unsigned long symbol_addr;
+			unsigned long symbol_addr __maybe_unused;
 			int symtab_index;
 			ElfW(Sym) *sym;
 			ELF_RELOC *rpnt;
diff -urN a/ldso/ldso/ldso.c b/ldso/ldso/ldso.c
--- a/ldso/ldso/ldso.c	2007-01-28 12:51:31.000000000 +0700
+++ b/ldso/ldso/ldso.c	2012-04-10 13:55:23.000000000 +0800
@@ -688,7 +688,7 @@
 		ElfW(Ehdr) *epnt = (ElfW(Ehdr) *) auxvt[AT_BASE].a_un.a_val;
 		ElfW(Phdr) *myppnt = (ElfW(Phdr) *) (load_addr + epnt->e_phoff);
 		int j;
-
+		
 		tpnt = _dl_add_elf_hash_table(tpnt->libname, (char *)load_addr,
 					      tpnt->dynamic_info,
 					      (unsigned long)tpnt->dynamic_addr,
diff -urN a/ldso/ldso/m68k/elfinterp.c b/ldso/ldso/m68k/elfinterp.c
--- a/ldso/ldso/m68k/elfinterp.c	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/m68k/elfinterp.c	2012-04-10 13:55:23.000000000 +0800
@@ -98,7 +98,7 @@
 #endif
 		*got_addr = new_addr;
 
-	return (unsigned int)new_addr;
+  return (unsigned int)new_addr;
 }
 
 static int
@@ -176,12 +176,12 @@
 	reloc_type = ELF_R_TYPE(rpnt->r_info);
 	symtab_index = ELF_R_SYM(rpnt->r_info);
 	sym = &symtab[symtab_index];
-	symbol_addr = 0;
+		symbol_addr = 0;
 	symname = strtab + sym->st_name;
 
-	if (symtab_index) {
+		if (symtab_index) {
 		symbol_addr = (ElfW(Addr))_dl_find_hash(symname, scope, tpnt,
-							    elf_machine_type_class(reloc_type));
+			               elf_machine_type_class(reloc_type));
 		/*
 		 * We want to allow undefined references to weak symbols - this
 		 * might have been intentional.  We should not be linking local
@@ -189,50 +189,50 @@
 		 */
 		if (unlikely(!symbol_addr && ELF_ST_BIND(sym->st_info) != STB_WEAK)) {
 			_dl_dprintf(2, "%s: can't resolve symbol '%s'\n", _dl_progname, symname);
-			_dl_exit(1);
+				_dl_exit (1);
 		};
-	}
+			}
 
 #if defined (__SUPPORT_LD_DEBUG__)
 	old_val = *reloc_addr;
 #endif
 
 	switch (reloc_type) {
-		case R_68K_NONE:
-			break;
-		case R_68K_8:
-			*(char *) reloc_addr = symbol_addr + rpnt->r_addend;
-			break;
-		case R_68K_16:
-			*(short *) reloc_addr = symbol_addr + rpnt->r_addend;
-			break;
-		case R_68K_32:
+			case R_68K_NONE:
+				break;
+			case R_68K_8:
+				*(char *) reloc_addr = symbol_addr + rpnt->r_addend;
+				break;
+			case R_68K_16:
+				*(short *) reloc_addr = symbol_addr + rpnt->r_addend;
+				break;
+			case R_68K_32:
+				*reloc_addr = symbol_addr + rpnt->r_addend;
+				break;
+			case R_68K_PC8:
+				*(char *) reloc_addr = (symbol_addr + rpnt->r_addend
+				                       - (unsigned int) reloc_addr);
+				break;
+			case R_68K_PC16:
+				*(short *) reloc_addr = (symbol_addr + rpnt->r_addend
+				                        - (unsigned int) reloc_addr);
+				break;
+			case R_68K_PC32:
+				*reloc_addr = (symbol_addr + rpnt->r_addend
+				              - (unsigned int) reloc_addr);
+				break;
+			case R_68K_GLOB_DAT:
+			case R_68K_JMP_SLOT:
 			*reloc_addr = symbol_addr + rpnt->r_addend;
-			break;
-		case R_68K_PC8:
-			*(char *) reloc_addr = (symbol_addr + rpnt->r_addend
-			                       - (unsigned int) reloc_addr);
-			break;
-		case R_68K_PC16:
-			*(short *) reloc_addr = (symbol_addr + rpnt->r_addend
-			                        - (unsigned int) reloc_addr);
-			break;
-		case R_68K_PC32:
-			*reloc_addr = (symbol_addr + rpnt->r_addend
-			              - (unsigned int) reloc_addr);
-			break;
-		case R_68K_GLOB_DAT:
-		case R_68K_JMP_SLOT:
-			*reloc_addr = symbol_addr + rpnt->r_addend;
-			break;
+				break;
 		/* handled by elf_machine_relative()
-		case R_68K_RELATIVE:
-			*reloc_addr = ((unsigned int) tpnt->loadaddr
-			              / * Compatibility kludge.  * /
-			              + (rpnt->r_addend ? : *reloc_addr));
+			case R_68K_RELATIVE:
+				*reloc_addr = ((unsigned int) tpnt->loadaddr
+				              /* Compatibility kludge.  */
+				              + (rpnt->r_addend ? : *reloc_addr));
 		*/
-			break;
-		case R_68K_COPY:
+				break;
+			case R_68K_COPY:
 			if (symbol_addr) {
 #if defined (__SUPPORT_LD_DEBUG__)
 				if (_dl_debug_move)
@@ -246,9 +246,9 @@
 				            sym->st_size);
 			} else
 				_dl_dprintf(_dl_debug_file, "no symbol_addr to copy !?\n");
-			break;
+				break;
 
-		default:
+			default:
 			return -1;	/* Calls _dl_exit(1). */
 	}
 
@@ -292,8 +292,8 @@
 			*reloc_addr += (unsigned int) tpnt->loadaddr;
 			break;
 		default:
-			_dl_exit(1);
-	}
+				_dl_exit (1);
+		}
 
 #if defined (__SUPPORT_LD_DEBUG__)
 	if (_dl_debug_reloc && _dl_debug_detail)
@@ -315,7 +315,7 @@
 #else
 	_dl_parse_relocation_information(rpnt, rel_addr, rel_size);
 #endif
-}
+	}
 
 int
 _dl_parse_relocation_information(struct dyn_elf *rpnt,
diff -urN a/ldso/ldso/m68k/resolve.S b/ldso/ldso/m68k/resolve.S
--- a/ldso/ldso/m68k/resolve.S	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/m68k/resolve.S	2012-04-10 13:55:23.000000000 +0800
@@ -12,7 +12,7 @@
 	move.l %a0, -(%sp)
 	move.l %a1, -(%sp)
 	# Call the real address resolver.
-	jbsr _dl_linux_resolver
+	jbsr	_dl_linux_resolver
 	# Restore register %a0 and %a1.
 	move.l (%sp)+, %a1
 	move.l (%sp)+, %a0
diff -urN a/ldso/ldso/mips/dl-sysdep.h b/ldso/ldso/mips/dl-sysdep.h
--- a/ldso/ldso/mips/dl-sysdep.h	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/mips/dl-sysdep.h	2012-04-10 13:55:23.000000000 +0800
@@ -64,9 +64,9 @@
 void _dl_perform_mips_global_got_relocations(struct elf_resolve *tpnt, int lazy);
 
 /* 4096 bytes alignment */
-#define PAGE_ALIGN 0xfffff000
-#define ADDR_ALIGN 0xfff
-#define OFFS_ALIGN 0x7ffff000
+#define ADDR_ALIGN (_dl_pagesize - 1)
+#define PAGE_ALIGN (~ADDR_ALIGN)
+#define OFFS_ALIGN (PAGE_ALIGN & ~(1ul << (sizeof(_dl_pagesize) * 8 - 1)))
 
 #define elf_machine_type_class(type)		ELF_RTYPE_CLASS_PLT
 /* MIPS does not have COPY relocs */
diff -urN a/ldso/ldso/mips/elfinterp.c b/ldso/ldso/mips/elfinterp.c
--- a/ldso/ldso/mips/elfinterp.c	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/mips/elfinterp.c	2012-04-10 13:55:23.000000000 +0800
@@ -99,7 +99,6 @@
 	unsigned long i;
 	unsigned long *got;
 	unsigned long *reloc_addr=NULL;
-	unsigned long symbol_addr;
 	int reloc_type, symtab_index;
 	struct elf_resolve *tpnt = xpnt->dyn;
 #if defined (__SUPPORT_LD_DEBUG__)
@@ -117,9 +116,8 @@
 	for (i = 0; i < rel_size; i++, rpnt++) {
 		reloc_addr = (unsigned long *) (tpnt->loadaddr +
 			(unsigned long) rpnt->r_offset);
-		reloc_type = ELF32_R_TYPE(rpnt->r_info);
-		symtab_index = ELF32_R_SYM(rpnt->r_info);
-		symbol_addr = 0;
+		reloc_type = ELF_R_TYPE(rpnt->r_info);
+		symtab_index = ELF_R_SYM(rpnt->r_info);
 
 		debug_sym(symtab,strtab,symtab_index);
 		debug_reloc(symtab,strtab,rpnt);
diff -urN a/ldso/ldso/powerpc/dl-sysdep.h b/ldso/ldso/powerpc/dl-sysdep.h
--- a/ldso/ldso/powerpc/dl-sysdep.h	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/powerpc/dl-sysdep.h	2012-04-10 13:55:23.000000000 +0800
@@ -93,7 +93,7 @@
 static inline Elf32_Addr * __attribute__ ((const))
 ppc_got (void)
 {
-	Elf32_Addr *got;
+  Elf32_Addr *got;
 #ifdef HAVE_ASM_PPC_REL16
 	asm ("	bcl 20,31,1f\n"
 	     "1:mflr %0\n"
@@ -101,8 +101,8 @@
 	     "	addi %0,%0,_GLOBAL_OFFSET_TABLE_-1b@l\n"
 	     : "=b" (got) : : "lr");
 #else
-	asm (" bl _GLOBAL_OFFSET_TABLE_-4@local"
-	     : "=l" (got));
+  asm (" bl _GLOBAL_OFFSET_TABLE_-4@local"
+       : "=l"(got));
 #endif
 	return got;
 }
diff -urN a/ldso/ldso/powerpc/elfinterp.c b/ldso/ldso/powerpc/elfinterp.c
--- a/ldso/ldso/powerpc/elfinterp.c	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/powerpc/elfinterp.c	2012-04-10 13:55:23.000000000 +0800
@@ -157,31 +157,31 @@
 	if (tpnt->dynamic_info[DT_PPC_GOT_IDX] != 0) {
 		*reloc_addr = finaladdr;
 	} else {
-		delta = finaladdr - (Elf32_Word)reloc_addr;
-		if (delta<<6>>6 == delta) {
-			*reloc_addr = OPCODE_B(delta);
-		} else if (finaladdr <= 0x01fffffc) {
-			*reloc_addr = OPCODE_BA (finaladdr);
-		} else {
-			/* Warning: we don't handle double-sized PLT entries */
-			Elf32_Word *plt, *data_words, index, offset;
-
-			plt = (Elf32_Word *)tpnt->dynamic_info[DT_PLTGOT];
-			offset = reloc_addr - plt;
-			index = (offset - PLT_INITIAL_ENTRY_WORDS)/2;
-			data_words = (Elf32_Word *)tpnt->data_words;
-			reloc_addr += 1;
+	delta = finaladdr - (Elf32_Word)reloc_addr;
+	if (delta<<6>>6 == delta) {
+		*reloc_addr = OPCODE_B(delta);
+	} else if (finaladdr <= 0x01fffffc) {
+		*reloc_addr = OPCODE_BA (finaladdr);
+	} else {
+		/* Warning: we don't handle double-sized PLT entries */
+		Elf32_Word *plt, *data_words, index, offset;
 
-			data_words[index] = finaladdr;
-			PPC_SYNC;
-			*reloc_addr =  OPCODE_B ((PLT_LONGBRANCH_ENTRY_WORDS - (offset+1)) * 4);
-		}
+		plt = (Elf32_Word *)tpnt->dynamic_info[DT_PLTGOT];
+		offset = reloc_addr - plt;
+		index = (offset - PLT_INITIAL_ENTRY_WORDS)/2;
+		data_words = (Elf32_Word *)tpnt->data_words;
+		reloc_addr += 1;
 
-		/* instructions were modified */
-		PPC_DCBST(reloc_addr);
+		data_words[index] = finaladdr;
 		PPC_SYNC;
-		PPC_ICBI(reloc_addr);
-		PPC_ISYNC;
+		*reloc_addr =  OPCODE_B ((PLT_LONGBRANCH_ENTRY_WORDS - (offset+1)) * 4);
+	}
+
+	/* instructions were modified */
+	PPC_DCBST(reloc_addr);
+	PPC_SYNC;
+	PPC_ICBI(reloc_addr);
+	PPC_ISYNC;
 	}
 	return finaladdr;
 }
@@ -232,29 +232,29 @@
 			*reloc_addr = finaladdr;
 			goto out_nocode; /* No code code modified */
 		} else {
-			Elf32_Sword delta = finaladdr - (Elf32_Word)reloc_addr;
-			if (delta<<6>>6 == delta) {
-				*reloc_addr = OPCODE_B(delta);
-			} else if (finaladdr <= 0x01fffffc) {
-				*reloc_addr = OPCODE_BA (finaladdr);
-			} else {
-				/* Warning: we don't handle double-sized PLT entries */
-				Elf32_Word *plt, *data_words, index, offset;
-
-				plt = (Elf32_Word *)tpnt->dynamic_info[DT_PLTGOT];
-				offset = reloc_addr - plt;
-				index = (offset - PLT_INITIAL_ENTRY_WORDS)/2;
-				data_words = (Elf32_Word *)tpnt->data_words;
-
-				data_words[index] = finaladdr;
-				reloc_addr[0] = OPCODE_LI(11,index*4);
-				reloc_addr[1] = OPCODE_B((PLT_LONGBRANCH_ENTRY_WORDS - (offset+1)) * 4);
-
-				/* instructions were modified */
-				PPC_DCBST(reloc_addr+1);
-				PPC_SYNC;
-				PPC_ICBI(reloc_addr+1);
-			}
+		Elf32_Sword delta = finaladdr - (Elf32_Word)reloc_addr;
+		if (delta<<6>>6 == delta) {
+			*reloc_addr = OPCODE_B(delta);
+		} else if (finaladdr <= 0x01fffffc) {
+			*reloc_addr = OPCODE_BA (finaladdr);
+		} else {
+			/* Warning: we don't handle double-sized PLT entries */
+			Elf32_Word *plt, *data_words, index, offset;
+
+			plt = (Elf32_Word *)tpnt->dynamic_info[DT_PLTGOT];
+			offset = reloc_addr - plt;
+			index = (offset - PLT_INITIAL_ENTRY_WORDS)/2;
+			data_words = (Elf32_Word *)tpnt->data_words;
+
+			data_words[index] = finaladdr;
+			reloc_addr[0] = OPCODE_LI(11,index*4);
+			reloc_addr[1] = OPCODE_B((PLT_LONGBRANCH_ENTRY_WORDS - (offset+1)) * 4);
+
+			/* instructions were modified */
+			PPC_DCBST(reloc_addr+1);
+			PPC_SYNC;
+			PPC_ICBI(reloc_addr+1);
+		}
 		}
 		break;
 	}
diff -urN a/ldso/ldso/sparc/dl-startup.h b/ldso/ldso/sparc/dl-startup.h
--- a/ldso/ldso/sparc/dl-startup.h	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/sparc/dl-startup.h	2012-04-10 13:55:23.000000000 +0800
@@ -74,4 +74,4 @@
 		break; \
 	default: \
 		_dl_exit(1); \
-}
+	}
diff -urN a/ldso/ldso/sparc/dl-sysdep.h b/ldso/ldso/sparc/dl-sysdep.h
--- a/ldso/ldso/sparc/dl-sysdep.h	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/sparc/dl-sysdep.h	2012-04-10 13:55:23.000000000 +0800
@@ -148,7 +148,7 @@
 elf_machine_relative (Elf32_Addr load_off, const Elf32_Addr rel_addr,
 		      Elf32_Word relative_count)
 {
-	Elf32_Rela * rpnt = (void *)rel_addr;
+	 Elf32_Rela * rpnt = (void *)rel_addr;
 	--rpnt;
 	do {
 		Elf32_Addr *const reloc_addr = (void *) (load_off + (++rpnt)->r_offset);
diff -urN a/ldso/ldso/sparc/elfinterp.c b/ldso/ldso/sparc/elfinterp.c
--- a/ldso/ldso/sparc/elfinterp.c	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/sparc/elfinterp.c	2012-04-10 13:55:23.000000000 +0800
@@ -33,11 +33,11 @@
 an ELF sharable library or a linux style of shared library. */
 
 /* Disclaimer:  I have never seen any AT&T source code for SVr4, nor have
-	 I ever taken any courses on internals.  This program was developed using
-	 information available through the book "UNIX SYSTEM V RELEASE 4,
-	 Programmers guide: Ansi C and Programming Support Tools", which did
-	 a more than adequate job of explaining everything required to get this
-	 working. */
+   I ever taken any courses on internals.  This program was developed using
+   information available through the book "UNIX SYSTEM V RELEASE 4,
+   Programmers guide: Ansi C and Programming Support Tools", which did
+   a more than adequate job of explaining everything required to get this
+   working. */
 
 /* Some SPARC opcodes we need to use for self-modifying code.  */
 #define OPCODE_NOP	0x01000000 /* nop */
@@ -52,32 +52,32 @@
 unsigned long
 _dl_linux_resolver(struct elf_resolve *tpnt, int reloc_entry)
 {
-	int reloc_type;
+  int reloc_type;
 	ELF_RELOC *this_reloc;
-	char *strtab;
+  char * strtab;
 	ElfW(Sym) *symtab;
-	int symtab_index;
+  int symtab_index;
 	char *rel_addr;
-	char *new_addr;
-	char **got_addr;
+  char * new_addr;
+  char ** got_addr;
 	ElfW(Addr) instr_addr;
 	char *symname;
 
 	rel_addr = (char *)tpnt->dynamic_info[DT_JMPREL];
-	/*
-	 * Generate the correct relocation index into the .rela.plt section.
-	 */
-	reloc_entry = (reloc_entry >> 10) - 0xc;
+  /*
+   * Generate the correct relocation index into the .rela.plt section.
+   */
+  reloc_entry = (reloc_entry >> 10) - 0xc;
 
 	this_reloc = (ELF_RELOC *)(rel_addr + reloc_entry);
 	reloc_type = ELF_R_TYPE(this_reloc->r_info);
 	symtab_index = ELF_R_SYM(this_reloc->r_info);
 
 	symtab = (ElfW(Sym) *)tpnt->dynamic_info[DT_SYMTAB];
-	strtab = (char *)tpnt->dynamic_info[DT_STRTAB];
+  strtab = (char *)tpnt->dynamic_info[DT_STRTAB];
 	symname = strtab + symtab[symtab_index].st_name;
 
-	if (unlikely(reloc_type != R_SPARC_JMP_SLOT)) {
+  if (unlikely(reloc_type != R_SPARC_JMP_SLOT)) {
 		_dl_dprintf(2, "%s: Incorrect relocation type in jump relocations\n",
 			          _dl_progname);
 		_dl_exit(1);
@@ -85,11 +85,11 @@
 
 	/* Address of the jump instruction to fix up. */
 	instr_addr = (this_reloc->r_offset + tpnt->loadaddr);
-	got_addr = (char **)instr_addr;
+  got_addr = (char **) instr_addr;
 
-	/* Get the address of the GOT entry */
+  /* Get the address of the GOT entry */
 	new_addr = _dl_find_hash(symname, tpnt->symbol_scope, tpnt, ELF_RTYPE_CLASS_PLT);
-	if (unlikely(!new_addr)) {
+  if(unlikely(!new_addr)) {
 		_dl_dprintf(2, "%s: Can't resolve symbol '%s'\n", _dl_progname, symname);
 		_dl_exit(1);
 	}
@@ -121,17 +121,17 @@
 			   ELF_RELOC *rpnt, ElfW(Sym) *symtab, char *strtab))
 {
 	unsigned int i;
-	char *strtab;
+  char * strtab;
 	ElfW(Sym) *symtab;
 	ELF_RELOC *rpnt;
-	int symtab_index;
+  int symtab_index;
 
 	/* Parse the relocation information. */
 	rpnt = (ELF_RELOC *)rel_addr;
 	rel_size /= sizeof(ELF_RELOC);
 
 	symtab = (ElfW(Sym) *)tpnt->dynamic_info[DT_SYMTAB];
-	strtab = (char *)tpnt->dynamic_info[DT_STRTAB];
+  strtab = ( char *)tpnt->dynamic_info[DT_STRTAB];
 
 	for (i = 0; i < rel_size; i++, rpnt++) {
 		int res;
@@ -175,8 +175,8 @@
 _dl_do_reloc(struct elf_resolve *tpnt, struct dyn_elf *scope,
 			 ELF_RELOC *rpnt, ElfW(Sym) *symtab, char *strtab)
 {
-	int reloc_type;
-	int symtab_index;
+  int reloc_type;
+  int symtab_index;
 	char *symname;
 	ElfW(Sym) *sym;
 	ElfW(Addr) *reloc_addr;
@@ -189,10 +189,10 @@
 	reloc_type = ELF_R_TYPE(rpnt->r_info);
 	symtab_index = ELF_R_SYM(rpnt->r_info);
 	sym = &symtab[symtab_index];
-	symbol_addr = 0;
+    symbol_addr = 0;
 	symname = strtab + sym->st_name;
 
-	if (symtab_index) {
+    if(symtab_index) {
 		symbol_addr = (ElfW(Addr))_dl_find_hash(symname, scope, tpnt,
 							    elf_machine_type_class(reloc_type));
 		/*
@@ -202,7 +202,7 @@
 		 */
 		if (unlikely(!symbol_addr && ELF_ST_BIND(sym->st_info) != STB_WEAK)) {
 			_dl_dprintf(2, "%s: can't resolve symbol '%s'\n", _dl_progname, symname);
-			_dl_exit(1);
+			_dl_exit (1);
 		}
 	}
 
@@ -212,9 +212,9 @@
 
 	symbol_addr += rpnt->r_addend;	/* Assume copy relocs have zero addend.  */
 
-	switch (reloc_type) {
-		case R_SPARC_NONE:
-			break;
+    switch(reloc_type){
+    case R_SPARC_NONE:
+	break;
 
 #if 0 /* these dont really seem to be useful */
 		case R_SPARC_8:
@@ -222,7 +222,7 @@
 			break;
 		case R_SPARC_16:
 			*(short *) reloc_addr = symbol_addr;
-			break;
+      break;
 		case R_SPARC_DISP8:
 			*(char *) reloc_addr = (symbol_addr) - (Elf32_Addr) reloc_addr;
 			break;
@@ -231,9 +231,9 @@
 			break;
 #endif
 
-		case R_SPARC_DISP32:
+    case R_SPARC_DISP32:
 			*reloc_addr = symbol_addr - (unsigned int) reloc_addr;
-			break;
+      break;
 
 		case R_SPARC_LO10:
 			if (!symbol_addr)
@@ -243,12 +243,12 @@
 			*reloc_addr = (*reloc_addr & ~0x3ff)|(symbol_addr & 0x3ff);
 			break;
 
-		case R_SPARC_GLOB_DAT:
+    case R_SPARC_GLOB_DAT:
 		case R_SPARC_32:
 			*reloc_addr = symbol_addr;
-			break;
+      break;
 
-		case R_SPARC_JMP_SLOT:
+    case R_SPARC_JMP_SLOT:
 /*
 value = symbol_addr;
 value += reloc->r_addend;
@@ -258,26 +258,26 @@
 			reloc_addr[1] = OPCODE_JMP_G1 | ((symbol_addr-(Elf32_Addr)reloc_addr) & 0x3ff);
 			reloc_addr[0] = OPCODE_SETHI_G1 | ((symbol_addr-(Elf32_Addr)reloc_addr) >> 10);
 */
-			reloc_addr[1] = 0x03000000 | ((symbol_addr >> 10) & 0x3fffff);
-			reloc_addr[2] = 0x81c06000 | (symbol_addr & 0x3ff);
-			break;
+      reloc_addr[1] = 0x03000000 | ((symbol_addr >> 10) & 0x3fffff);
+      reloc_addr[2] = 0x81c06000 | (symbol_addr & 0x3ff);
+      break;
 
-		case R_SPARC_RELATIVE:
+    case R_SPARC_RELATIVE:
 			*reloc_addr += tpnt->loadaddr + rpnt->r_addend;
-			break;
+      break;
 
 		case R_SPARC_WDISP30:
 			*reloc_addr = (*reloc_addr & 0xc0000000)|
 			         ((symbol_addr - (unsigned int) reloc_addr) >> 2);
 			break;
 
-		case R_SPARC_HI22:
-			if (!symbol_addr)
-				symbol_addr = tpnt->loadaddr + rpnt->r_addend;
-			else
-				symbol_addr += rpnt->r_addend;
-			*reloc_addr = (*reloc_addr & 0xffc00000) | (symbol_addr >> 10);
-			break;
+    case R_SPARC_HI22:
+      if (!symbol_addr)
+        symbol_addr = tpnt->loadaddr + rpnt->r_addend;
+      else
+	symbol_addr += rpnt->r_addend;
+      *reloc_addr = (*reloc_addr & 0xffc00000)|(symbol_addr >> 10);
+      break;
 
 		case R_SPARC_COPY:
 			if (symbol_addr) {
@@ -294,7 +294,7 @@
 					   sym->st_size);
 			} else
 				_dl_dprintf(_dl_debug_file, "no symbol_addr to copy !?\n");
-			break;
+      break;
 		default:
 			return -1;	/* Calls _dl_exit(1). */
 	}
@@ -334,10 +334,10 @@
 
 	switch (reloc_type) {
 		case R_SPARC_NONE:
-			break;
+      break;
 		case R_SPARC_JMP_SLOT:
-			break;
-		default:
+      break;
+    default:
 			_dl_exit(1);
 	}
 
diff -urN a/ldso/ldso/x86_64/dl-debug.h b/ldso/ldso/x86_64/dl-debug.h
--- a/ldso/ldso/x86_64/dl-debug.h	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/ldso/x86_64/dl-debug.h	2012-04-10 13:55:23.000000000 +0800
@@ -30,8 +30,8 @@
  */
 
 static const char *_dl_reltypes_tab[] = {
-	[ 0] "R_X86_64_NONE",     "R_X86_64_64",       "R_X86_64_PC32",     "R_X86_64_GOT32",
-	[ 4] "R_X86_64_PLT32",    "R_X86_64_COPY",     "R_X86_64_GLOB_DAT", "R_X86_64_JUMP_SLOT",
+	[0] "R_X86_64_NONE",     "R_X86_64_64",       "R_X86_64_PC32",     "R_X86_64_GOT32",
+	[4] "R_X86_64_PLT32",    "R_X86_64_COPY",     "R_X86_64_GLOB_DAT", "R_X86_64_JUMP_SLOT",
 	[ 8] "R_X86_64_RELATIVE", "R_X86_64_GOTPCREL", "R_X86_64_32",       "R_X86_64_32S",
 	[12] "R_X86_64_16",       "R_X86_64_PC16",     "R_X86_64_8",        "R_X86_64_PC8",
 	[16] "R_X86_64_DTPMOD64", "R_X86_64_DTPOFF64", "R_X86_64_TPOFF64",  "R_X86_64_TLSGD",
diff -urN a/ldso/libdl/libdl.c b/ldso/libdl/libdl.c
--- a/ldso/libdl/libdl.c	2007-01-26 07:22:03.000000000 +0700
+++ b/ldso/libdl/libdl.c	2012-04-10 13:55:23.000000000 +0800
@@ -52,8 +52,10 @@
 extern struct r_debug *_dl_debug_addr;
 extern unsigned long _dl_error_number;
 extern void *(*_dl_malloc_function)(size_t);
+#if 0
 extern void _dl_run_init_array(struct elf_resolve *);
 extern void _dl_run_fini_array(struct elf_resolve *);
+#endif
 #ifdef __LDSO_CACHE_SUPPORT__
 int _dl_map_cache(void);
 int _dl_unmap_cache(void);
@@ -175,13 +177,15 @@
 		struct dyn_elf *dpnt;
 		tfrom = NULL;
 		for (dpnt = _dl_symbol_tables; dpnt; dpnt = dpnt->next) {
-			tpnt = dpnt->dyn;
-			if (tpnt->loadaddr < from
-					&& (tfrom == NULL || tfrom->loadaddr < tpnt->loadaddr))
-				tfrom = tpnt;
+		    tpnt = dpnt->dyn;
+		    if (tpnt->loadaddr < from
+				&& (tfrom == NULL || tfrom->loadaddr < tpnt->loadaddr))
+			tfrom = tpnt;
 		}
 	}
-	for(rpnt = _dl_symbol_tables; rpnt && rpnt->next; rpnt=rpnt->next);
+
+	for (rpnt = _dl_symbol_tables; rpnt && rpnt->next; rpnt = rpnt->next)
+		continue;
 
 	relro_ptr = rpnt;
 	now_flag = (flag & RTLD_NOW) ? RTLD_NOW : 0;
@@ -238,10 +242,9 @@
 		runp->tpnt->init_fini = NULL; /* clear any previous dependcies */
 		for (dpnt = (ElfW(Dyn) *) runp->tpnt->dynamic_addr; dpnt->d_tag; dpnt++) {
 			if (dpnt->d_tag == DT_NEEDED) {
-				lpntstr = (char*) (runp->tpnt->dynamic_info[DT_STRTAB] +
-						dpnt->d_un.d_val);
-				_dl_if_debug_print("Trying to load '%s', needed by '%s'\n",
-						lpntstr, runp->tpnt->libname);
+				lpntstr = (char*) (runp->tpnt->dynamic_info[DT_STRTAB] + dpnt->d_un.d_val);
+				_dl_get_last_path_component(lpntstr);
+				_dl_if_debug_print("Trying to load '%s', needed by '%s'\n", lpntstr, runp->tpnt->libname);
 				tpnt1 = _dl_load_shared_library(0, &rpnt, runp->tpnt, lpntstr, 0);
 				if (!tpnt1)
 					goto oops;
@@ -386,8 +389,9 @@
 				(*dl_elf_func) ();
 			}
 		}
-
+#if 0
 		_dl_run_init_array(tpnt);
+#endif
 	}
 #endif /* SHARED */
 
@@ -508,16 +512,16 @@
 			    && need_fini &&
 			    !(tpnt->init_flag & FINI_FUNCS_CALLED)) {
 				tpnt->init_flag |= FINI_FUNCS_CALLED;
-#ifdef SHARED
+#if 0
 				_dl_run_fini_array(tpnt);
 #endif
 
 				if (tpnt->dynamic_info[DT_FINI]) {
-					dl_elf_fini = (int (*)(void)) (tpnt->loadaddr + tpnt->dynamic_info[DT_FINI]);
-					_dl_if_debug_print("running dtors for library %s at '%p'\n",
-							tpnt->libname, dl_elf_fini);
-					(*dl_elf_fini) ();
-				}
+				dl_elf_fini = (int (*)(void)) (tpnt->loadaddr + tpnt->dynamic_info[DT_FINI]);
+				_dl_if_debug_print("running dtors for library %s at '%p'\n",
+						tpnt->libname, dl_elf_fini);
+				(*dl_elf_fini) ();
+			}
 			}
 
 			_dl_if_debug_print("unmapping: %s\n", tpnt->libname);
diff -urN a/ldso/man/ld.so.8 b/ldso/man/ld.so.8
--- a/ldso/man/ld.so.8	2001-04-24 01:43:54.000000000 +0800
+++ b/ldso/man/ld.so.8	1970-01-01 07:00:00.000000000 +0700
@@ -1,113 +0,0 @@
-.TH ld.so 8 "14 March 1998"
-.SH NAME
-ld.so/ld-linux.so \- dynamic linker/loader
-.SH DESCRIPTION
-.B ld.so
-loads the shared libraries needed by a program, prepares the program
-to run, and then runs it.
-Unless explicitly specified via the
-.B \-static
-option to
-.B ld
-during compilation, all Linux programs are incomplete and require 
-further linking at run time.
-.PP
-The necessary shared libraries needed by the program are searched for 
-in the following order
-.IP o
-Using the environment variable
-.B LD_LIBRARY_PATH
-.RB ( LD_AOUT_LIBRARY_PATH
-for a.out programs).
-Except if the executable is a setuid/setgid binary, in which case it
-is ignored.
-.IP o
-From the cache file
-.BR /etc/ld.so.cache
-which contains a compiled list of candidate libraries previously found
-in the augmented library path.
-.IP o
-In the default path
-.BR /usr/lib ,
-and then
-.BR /lib .
-.SH ENVIRONMENT
-.TP
-.B LD_LIBRARY_PATH
-A colon-separated list of directories in which to search for
-ELF libraries at execution-time.
-Similar to the 
-.B PATH
-environment variable.
-.TP
-.B LD_PRELOAD
-A whitespace-separated list of additional, user-specified, ELF shared 
-libraries to be loaded before all others.
-This can be used to selectively override functions in other shared libraries.
-For setuid/setgid ELF binaries, only libraries in the standard search
-directories that are also setgid will be loaded.
-.TP
-.B LD_TRACE_LOADED_OBJECTS
-If present, causes the program to list its dynamic library dependencies,
-as if run by ldd, instead of running normally.
-.TP
-.B LD_BIND_NOW
-If present, causes the dynamic linker to resolve all symbols at program
-startup instead of when they are first referenced.
-.TP
-.B LD_AOUT_LIBRARY_PATH
-A colon-separated list of directories in which to search for
-a.out libraries at execution-time.
-Similar to the 
-.B PATH
-environment variable.
-.TP
-.B LD_AOUT_PRELOAD
-The name of an additional, user-specified, a.out shared library to be loaded 
-after all others.
-This can be used to selectively override functions in other shared libraries.
-.TP
-.B LD_NOWARN
-Suppress warnings about a.out libraries with incompatible minor 
-version numbers.
-.TP
-.B LD_KEEPDIR
-Don't ignore the directory in the names of a.out libraries to be loaded.
-Use of this option is strongly discouraged.
-.SH FILES
-.PD 0
-.TP 20
-.B /lib/ld.so
-a.out dynamic linker/loader
-.TP 20
-.B /lib/ld-linux.so.*
-ELF dynamic linker/loader
-.TP
-.B /etc/ld.so.cache
-File containing a compiled list of directories in which to search for
-libraries and an ordered list of candidate libraries.
-.TP
-.B /etc/ld.so.preload
-File containing a whitespace separated list of ELF shared libraries to
-be loaded before the program.
-libraries and an ordered list of candidate libraries.
-.TP
-.B lib*.so*
-shared libraries
-.PD
-.SH SEE ALSO
-.BR ldd (1),
-.BR ldconfig (8).
-.SH BUGS
-.LP
-Currently
-.B ld.so
-has no means of unloading and searching for compatible or newer version of
-libraries.
-.PP
-.B ld.so
-functionality is only available for executables compiled using libc version
-4.4.3 or greater.
-.SH AUTHORS
-David Engel, Eric Youngdale, Peter MacDonald, Hongjiu Lu, Linus
-Torvalds, Lars Wirzenius and Mitch D'Souza (not necessarily in that order).
diff -urN a/ldso/man/ld.so.texi b/ldso/man/ld.so.texi
--- a/ldso/man/ld.so.texi	2001-04-24 01:43:54.000000000 +0800
+++ b/ldso/man/ld.so.texi	1970-01-01 07:00:00.000000000 +0700
@@ -1,411 +0,0 @@
-\input texinfo @c -*-texinfo-*-
-@c %**start of header
-@setfilename ld.so.info
-@settitle ld.so : Dynamic-Link Library support
-@c %**end of header
-
-@ifinfo
-This file documents the dynamic-link support libraries and utilities for the
-Linux OS, version 1.8.1.
-
-Copyright 1996 Michael Deutschmann
-
-This document is subject to the GNU General Public License as published by 
-the Free Software foundation, version 2 or later (your choice).
-
-Note: The software described in this document is under a different copyright
-and license.
-
-@end ifinfo
-
-@titlepage 
-@title ld.so
-@subtitle Dynamic Link library support for the Linux OS.
-@author David Engel
-@author Eric Youngdale
-@author Peter Macdonald 
-@author Hongjiu Lu 
-@author Mitch D'Souza
-@author Michael Deutschmann (this documentation)
-
-@page
-Copyright @copyright{} 1996 Michael Deutschmann
-
-This document is subject to the GNU General Public License as published by 
-the Free Software foundation, version 2 or later (your choice).
-
-Note: The software described in this document is under a different copyright
-and license.
-@end titlepage
-
-@ifinfo
-@node Top
-@top
-
-The @code{ld.so} module provides dynamic linked library support in Linux.
-This file documents @code{ld.so} and its companion software.
-
-@menu
-* intro::	Introduction
-
-* ld.so::	The dynamic linker core program
-* ldd::		A utility to print out dependencies
-* ldconfig::	A utility to maintain the cache and symlinks
-* libdl::	Manual dynamic linking library
-@end menu
-
-@end ifinfo
-
-@node intro
-@unnumbered Introduction
-
-The @code{ld.so} suite contains special files and utilities needed for linux
-to handle @dfn{dynamic libraries}.
-
-Ordinary static libraries (@file{lib*.a} files) are included into executables
-that use their functions. A file that only uses static libraries needs less
-intelligence to load, but takes up more space. If many executables use the
-same library, there can be much wastage of storage space, since multiple
-copies of the library functions are scattered across the executables.
-However, static libraries are easier to make.
-
-Dynamic libraries (@file{lib*.so*} files) are not copied into executables ---
-the executable is written in such a way that it will automatically load the
-libraries. In linux, the executable will first load the special library 
-@code{ld.so} or @code{ld-linux.so}, which contains the intelligence
-to load further dynamic libraries. Since multiple files end up getting
-executable data from the same file, dynamic libraries are also known as
-shared libraries.
-
-Linux executables come in two flavors, @sc{elf} and a.out.
-
-a.out is the original executable format used by Linux. It has somewhat less 
-overhead than @sc{elf}. However creating shared libraries for a.out is
-@emph{very} involved, and each a.out shared library must be explicitly 
-registered.
- 
-@sc{elf} is a more recent format, which supports a much simpler method of
-creating libraries. @sc{elf} libraries may also be linked manually
-(@pxref{libdl}).
-
-Since many library authors prefer @sc{elf} and no longer release shared a.out 
-libraries, a.out is moribund on Linux. This version of the @code{ld.so} can
-be compiled to support only @sc{elf}, or to support both formats. (The last
-release of ld.so to support a.out alone was 1.8.0.)
-
-@node ld.so
-@chapter @code{ld.so}: Dynamic linker core
-
-@code{ld.so} works behind the scenes to handle dynamic libraries in Linux.
-Users will almost never have to deal with it directly, but in special cases
-one can send instructions to it through environment variables. Also, if
-something is wrong with your libraries (usually an incorrect version) ld.so
-will give error messages.
-
-Actually @code{ld.so} is the a.out linker. The new @sc{elf} executables are
-handled by a related program @code{ld-linux.so}.
-
-@menu
-* files::	Configuration files used by the suite
-* environment::	Environment settings that tweak @code{ld.so}
-* errors::	Complaints @code{ld.so} might make
-@end menu
-
-@node files
-@section Configuration Files
-
-@table @file
-@item /etc/ld.so.cache
-A file created by @code{ldconfig} and used to speed linking. It's structure
-is private to the suite.
-
-@item /etc/ld.so.conf
-A simple list of directories to scan for libraries, in addition to
-@file{/usr/lib} and @file{/lib}, which are hardwired. It may contain
-comments started with a @samp{#}.
-
-@item /etc/ld.so.preload
-A list of libraries to preload. This allows preloading libraries for
-setuid/setgid executables securely. It may contain comments. 
-@end table
-
-@node environment
-@section Environment Variables
-
-@table @code
-@item LD_AOUT_LIBRARY_PATH
-@itemx LD_LIBRARY_PATH
-These variables supply a library path for finding dynamic libraries, in the
-standard colon seperated format. These variables are ignored when executing 
-setuid/setgid programs, because otherwise they would be a security hazard. 
-@code{ld.so} will use @code{LD_AOUT_LIBRARY_PATH} and @code{ld-linux.so} will 
-use @code{LD_LIBRARY_PATH}.
-
-@item LD_AOUT_PRELOAD
-@itemx LD_PRELOAD
-These variables allow an extra library not specified in the executable to be
-loaded. Generally this is only useful if you want to override a function. 
-These are also ignored when running setuid/setgid executables. @code{ld.so} 
-will use @code{LD_AOUT_PRELOAD} and @code{ld-linux.so} will use 
-@code{LD_PRELOAD}.
-
-@item LD_NOWARN
-If non-empty, errors about incompatible minor revisions are suppressed.
-
-@item LD_KEEPDIR
-If non-empty, allow executables to specify absolute library names. This
-option is deprecated.
-@c FIXME:
-@c The following are things I noticed in the ld-linux.so source.
-@c I don't really understand 'em. Could someone help me?
-@c
-@c @item LD_BIND_NOW
-@c This option is used by the @code{ld-linux.so} only. I don't know 
-@c what it does. (I suspect, looking at the code, that it specifies
-@c "RTLD_NOW" rather than "RTLD_LAZY" mode for the shared libraries.)
-@c 
-@c @item LD_TRACE_LOADED_OBJECTS
-@c @itemx LD_WARN
-@c These seem to have something to do with the communication between the
-@c @code{ld-linux.so} and @code{ldd}. I don't know more.
-@end table
-
-@node errors
-@section Errors
-
-@table @samp
-@item Can't find library @var{library}
-The executable required a dynamically linked library that ld.so cannot find.
-Your symbolic links may be not set right, or you may have not installed a 
-library needed by the program.
-
-@item Can't load library @var{library}
-The library is corrupt. 
-
-@item Incompatible library @var{library}
-@itemx   Require major version @var{x} and found @var{y}
-Your version of the library is incompatible with the executable. Recompiling
-the executable, or upgrading the library will fix the problem.
-
-@item using incompatible library @var{library}
-@itemx   Desire minor version >= @var{x} and found @var{y}.
-Your version of the library is older than that expected by the executable,
-but not so old that the library interface has radically changed, so the
-linker will attempt to run anyway. There is a chance that it will work, but 
-you should upgrade the library or recompile the software. The environment 
-variable @code{LD_NOWARN} can be used to supress this message.
-
-@item too many directories in library path
-The linker only supports up to 32 library directories. You have too many.
-
-@item dynamic linker error in @var{blah}
-The linker is having trouble handling a binary - it is probably corrupt.
-
-@item can't map cache file @var{cache-file}
-@itemx cache file @var{cache-file} @var{blah}
-The linker cache file (generally @file{/etc/ld.so.cache}) is corrupt or
-non-existent. These errors can be ignored, and can be prevented by 
-regenerating the cache file with @code{ldconfig}.
-@end table
-
-@node ldd
-@chapter @code{ldd}: Dependency scanner
-
-@code{ldd} is a utility that prints out the dynamic libraries that an
-executable is linked to. 
-
-Actually @code{ldd} works by signalling ld.so to print the dependencies. 
-For a.out executables this is done by starting the executable with 
-@code{argc} equal to 0. The linker detects this and prints the dependencies. 
-(This can cause problems with @emph{very} old binaries, which would run as 
-normal only with an inappropriate @code{argc}.)
-
-For @sc{elf} executables, special environment variables are used to tell the
-linker to print the dependencies.
-
-@code{ldd} has a few options:
-
-@table @samp
-@item -v
-Print the version number of @code{ldd} itself
-
-@item -V
-Print the version number of the dynamic linker
-
-@item -d
-Report missing functions. This is only supported for @sc{elf} executables.
-
-@item -r
-Report missing objects. This is also only available for @sc{elf}
-executables.
-@end table
-
-@node ldconfig
-@chapter @code{ldconfig}: Setup program 
-
-This utility is used by the system administrator to automatically set up
-symbolic links needed by the libraries, and also to set up the cache file.
-
-@code{ldconfig} is run after new dynamic libraries are installed, and if the 
-cache file or links are damaged. It is also run when upgrading the
-@code{ld.so} suite itself.
-
-The @file{/lib} and @file{/usr/lib} directories, and any listed in the file 
-@file{/etc/ld.so.conf} are scanned by default unless @samp{-n} is used.
-Additional directories may be specified on the command line.
-
-It has the following options:
-
-@table @samp
-@item -D
-Enter debug mode. Implies @samp{-N} and @samp{-X}.
-
-@item -v
-Verbose. Print out links created and directories scanned.
-
-@item -n 
-Check directories specified on the commandline @emph{only}.
-
-@item -N
-Do not regenerate the cache.
-
-@item -X
-Do not rebuild symbolic links.
-
-@item -l
-Set up symbolic links for only libraries presented on the command line.
-
-@item -p
-Print out the library pathnames in the cache file (@file{/etc/ld.so.cache})
-@end table
-
-@node libdl
-@chapter User dynamic linking library
-
-The @code{ld.so} package includes a small library of functions
-(@code{libdl}) to allow manual dynamic linking. Normally programs are linked 
-so that dynamic functions and objects are automagically available. These 
-functions allow one to manually load and access a symbol from a library. 
-They are only available for @sc{elf} executables.
-
-@menu
-* using libdl::	General points
-* functions::	How to use the functions
-* example::	A sample program
-@end menu
-
-@node using libdl
-@section Overview
-
-To access this library, add the flag @samp{-ldl} to your compile command when
-linking the executable. You also must include the header file
-@code{dlfcn.h}. You may also need the flag @samp{-rdynamic}, which enables
-resolving references in the loaded libraries against your executable.
-
-Generally, you will first use @code{dlopen} to open a library. Then you use
-@code{dlsym} one or more times to access symbols. Finally you use
-@code{dlclose} to close the library.
-
-These facilities are most useful for language interpreters that provide
-access to external libraries. Without @code{libdl}, it would be neccessary
-to link the interpreter executable with any and all external libraries
-needed by the programs it runs. With @code{libdl}, the interpreter only 
-needs to be linked with the libraries it uses itself, and can dynamically 
-load in additional ones if programs need it.
-
-@node functions
-@section Functions
-
-@deftypefun void *dlopen ( const char @var{filename}, int @var{flags} )
-
-This function opens the dynamic library specified by @var{filename}
-and returns an abstract handle, which can be used in subsequent calls to 
-@code{dlsym}. The function will respect the @code{LD_ELF_LIBRARY_PATH} and
-@code{LD_LIBRARY_PATH} environment variables.
-
-@end deftypefun
-
-The following flags can be used with @code{dlopen}:
-
-@deftypevr Macro int RTLD_LAZY
-Resolve symbols in the library as they are needed.
-@end deftypevr
-
-@deftypevr Macro int RTLD_NOW
-Resolve all symbols in the library before returning, and fail if not all can
-be resolved. This is mutually exclusive with @code{RTLD_LAZY}.
-@end deftypevr
-
-@deftypevr Macro int RTLD_GLOBAL
-Make symbols in this library available for resolving symbols in other
-libraries loaded with @code{dlopen}.
-@end deftypevr
-
-@deftypefun int dlclose ( void *@var{handle} )
-
-This function releases a library handle.
-
-Note that if a library opened twice, the handle will be the same. However,
-a reference count is used, so you should still close the library as many 
-times as you open it.
-
-@end deftypefun
-
-@deftypefun void *dlsym (void *@var{handle},char *@var{symbol-name})
-
-This function looks up the name @var{symbol-name} in the library and returns
-it in the void pointer.
-
-If there is an error, a null pointer will be returned. However, it is
-possible for a valid name in the library to have a null value, so
-@code{dlerror} should be used to check if there was an error.
-
-@end deftypefun
-
-@deftypefun {libdl function} {const char} *dlerror( void )
-
-This function is used to read the error state. It returns a human-readable
-string describing the last error, or null, meaning no error.
-
-The function resets the error value each time it is called, so the result
-should be copied into a variable. If the function is called more than once
-after an error, the second and subsequent calls will return null.
-
-@end deftypefun
-
-@node example
-@section Example program
-
-Here is an example program that prints the cosine of two by manually linking
-to the math library:
- 
-@example
-@c The following was snarfed verbatim from the dlopen.3 man file.
-#include <stdio.h>
-#include <dlfcn.h>
-
-int main(int argc, char **argv) @{
-    void *handle;
-    double (*cosine)(double);
-    char *error;
-
-    handle = dlopen ("/lib/libm.so", RTLD_LAZY);
-    if (!handle) @{
-        fputs (dlerror(), stderr);
-        exit(1);
-    @}
-
-    cosine = dlsym(handle, "cos");
-    if ((error = dlerror()) != NULL)  @{
-        fputs(error, stderr);
-        exit(1);
-    @}
-
-    printf ("%f\\n", (*cosine)(2.0));
-    dlclose(handle);
-@}
-@end example
-
-@contents
-
-@bye
diff -urN a/libc/inet/getaddrinfo.c b/libc/inet/getaddrinfo.c
--- a/libc/inet/getaddrinfo.c	2002-11-21 14:05:33.000000000 +0700
+++ b/libc/inet/getaddrinfo.c	2012-04-10 13:55:23.000000000 +0800
@@ -816,7 +816,10 @@
 	if (hints->ai_family == g->family || hints->ai_family == AF_UNSPEC)
 	{
 	    if ((hints->ai_flags & AI_ADDRCONFIG) && !addrconfig(g->family))
+	    {
+		g++;
 		continue;
+	    }
 	    j++;
 	    if (pg == NULL || pg->gaih != g->gaih)
 	    {
diff -urN a/libc/inet/getnetent.c b/libc/inet/getnetent.c
--- a/libc/inet/getnetent.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/inet/getnetent.c	2012-04-10 13:55:23.000000000 +0800
@@ -39,9 +39,9 @@
 {
     __UCLIBC_MUTEX_LOCK(mylock);
     if (netf == NULL)
-		netf = fopen(NETDB, "r" );
+	netf = fopen(NETDB, "r" );
     else
-		rewind(netf);
+	rewind(netf);
     _net_stayopen |= f;
     __UCLIBC_MUTEX_UNLOCK(mylock);
     return;
@@ -51,8 +51,8 @@
 {
     __UCLIBC_MUTEX_LOCK(mylock);
     if (netf) {
-		fclose(netf);
-		netf = NULL;
+	fclose(netf);
+	netf = NULL;
     }
     _net_stayopen = 0;
     __UCLIBC_MUTEX_UNLOCK(mylock);
@@ -63,10 +63,10 @@
     register char *mp, c;
 
     while ((c = *cp)) {
-		for (mp = match; *mp; mp++)
-			if (*mp == c)
-				return (cp);
-		cp++;
+	for (mp = match; *mp; mp++)
+	    if (*mp == c)
+		return (cp);
+	cp++;
     }
     return ((char *)0);
 }
@@ -81,12 +81,12 @@
     if (netf == NULL && (netf = fopen(NETDB, "r" )) == NULL) {
 		goto DONE;
     }
- again:
+again:
 
     if (!line) {
-		line = malloc(BUFSIZ + 1);
-		if (!line)
-			abort();
+	line = malloc(BUFSIZ + 1);
+	if (!line)
+	    abort();
     }
 
     p = fgets(line, BUFSIZ, netf);
@@ -94,36 +94,36 @@
 		goto DONE;
     }
     if (*p == '#')
-		goto again;
+	goto again;
     cp = any(p, "#\n");
     if (cp == NULL)
-		goto again;
+	goto again;
     *cp = '\0';
     net.n_name = p;
     cp = any(p, " \t");
     if (cp == NULL)
-		goto again;
+	goto again;
     *cp++ = '\0';
     while (*cp == ' ' || *cp == '\t')
-		cp++;
+	cp++;
     p = any(cp, " \t");
     if (p != NULL)
-		*p++ = '\0';
+	*p++ = '\0';
     net.n_net = inet_network(cp);
     net.n_addrtype = AF_INET;
     q = net.n_aliases = net_aliases;
     if (p != NULL)
-		cp = p;
+	cp = p;
     while (cp && *cp) {
-		if (*cp == ' ' || *cp == '\t') {
-			cp++;
-			continue;
-		}
-		if (q < &net_aliases[MAXALIASES - 1])
-			*q++ = cp;
-		cp = any(cp, " \t");
-		if (cp != NULL)
-			*cp++ = '\0';
+	if (*cp == ' ' || *cp == '\t') {
+	    cp++;
+	    continue;
+	}
+	if (q < &net_aliases[MAXALIASES - 1])
+	    *q++ = cp;
+	cp = any(cp, " \t");
+	if (cp != NULL)
+	    *cp++ = '\0';
     }
     *q = NULL;
 
diff -urN a/libc/inet/getproto.c b/libc/inet/getproto.c
--- a/libc/inet/getproto.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/inet/getproto.c	2012-04-10 13:55:23.000000000 +0800
@@ -77,9 +77,9 @@
 static void __initbuf(void)
 {
     if (!static_aliases) {
-		static_aliases = malloc(SBUFSIZE);
-		if (!static_aliases)
-			abort();
+	static_aliases = malloc(SBUFSIZE);
+	if (!static_aliases)
+	    abort();
     }
 }
 
@@ -87,9 +87,9 @@
 {
     __UCLIBC_MUTEX_LOCK(mylock);
     if (protof == NULL)
-		protof = fopen(_PATH_PROTOCOLS, "r" );
+	protof = fopen(_PATH_PROTOCOLS, "r" );
     else
-		rewind(protof);
+	rewind(protof);
     proto_stayopen |= f;
     __UCLIBC_MUTEX_UNLOCK(mylock);
 }
@@ -98,16 +98,16 @@
 {
     __UCLIBC_MUTEX_LOCK(mylock);
     if (protof) {
-		fclose(protof);
-		protof = NULL;
+	fclose(protof);
+	protof = NULL;
     }
     proto_stayopen = 0;
     __UCLIBC_MUTEX_UNLOCK(mylock);
 }
 
 int getprotoent_r(struct protoent *result_buf,
-				  char *buf, size_t buflen,
-				  struct protoent **result)
+		  char *buf, size_t buflen,
+		  struct protoent **result)
 {
     char *p;
     register char *cp, **q;
@@ -118,8 +118,8 @@
     *result = NULL;
 
     if (buflen < sizeof(*proto_aliases)*MAXALIASES) {
-		errno=ERANGE;
-		return errno;
+	errno=ERANGE;
+	return errno;
     }
 
     __UCLIBC_MUTEX_LOCK(mylock);
@@ -139,43 +139,43 @@
 		rv=errno;
 		goto DONE;
     }
- again:
+again:
     if ((p = fgets(line, BUFSIZ, protof)) == NULL) {
 		rv=TRY_AGAIN;
 		goto DONE;
     }
 
     if (*p == '#')
-		goto again;
+	goto again;
     cp = strpbrk(p, "#\n");
     if (cp == NULL)
-		goto again;
+	goto again;
     *cp = '\0';
     result_buf->p_name = p;
     cp = strpbrk(p, " \t");
     if (cp == NULL)
-		goto again;
+	goto again;
     *cp++ = '\0';
     while (*cp == ' ' || *cp == '\t')
-		cp++;
+	cp++;
     p = strpbrk(cp, " \t");
     if (p != NULL)
-		*p++ = '\0';
+	*p++ = '\0';
     result_buf->p_proto = atoi(cp);
     q = result_buf->p_aliases = proto_aliases;
     if (p != NULL) {
-		cp = p;
-		while (cp && *cp) {
-			if (*cp == ' ' || *cp == '\t') {
-				cp++;
-				continue;
-			}
-			if (q < &proto_aliases[MAXALIASES - 1])
-				*q++ = cp;
-			cp = strpbrk(cp, " \t");
-			if (cp != NULL)
-				*cp++ = '\0';
-		}
+	cp = p;
+	while (cp && *cp) {
+	    if (*cp == ' ' || *cp == '\t') {
+		cp++;
+		continue;
+	    }
+	    if (q < &proto_aliases[MAXALIASES - 1])
+		*q++ = cp;
+	    cp = strpbrk(cp, " \t");
+	    if (cp != NULL)
+		*cp++ = '\0';
+	}
     }
     *q = NULL;
     *result=result_buf;
@@ -198,9 +198,9 @@
 
 
 int getprotobyname_r(const char *name,
-					 struct protoent *result_buf,
-					 char *buf, size_t buflen,
-					 struct protoent **result)
+		    struct protoent *result_buf,
+		    char *buf, size_t buflen,
+		    struct protoent **result)
 {
     register char **cp;
     int ret;
@@ -208,15 +208,15 @@
     __UCLIBC_MUTEX_LOCK(mylock);
     setprotoent(proto_stayopen);
     while (!(ret=getprotoent_r(result_buf, buf, buflen, result))) {
-		if (strcmp(result_buf->p_name, name) == 0)
-			break;
-		for (cp = result_buf->p_aliases; *cp != 0; cp++)
-			if (strcmp(*cp, name) == 0)
-				goto found;
+	if (strcmp(result_buf->p_name, name) == 0)
+	    break;
+	for (cp = result_buf->p_aliases; *cp != 0; cp++)
+	    if (strcmp(*cp, name) == 0)
+		goto found;
     }
- found:
+found:
     if (!proto_stayopen)
-		endprotoent();
+	endprotoent();
     __UCLIBC_MUTEX_UNLOCK(mylock);
     return *result?0:ret;
 }
@@ -233,19 +233,19 @@
 
 
 int getprotobynumber_r (int proto_num,
-						struct protoent *result_buf,
-						char *buf, size_t buflen,
-						struct protoent **result)
+			struct protoent *result_buf,
+			char *buf, size_t buflen,
+			struct protoent **result)
 {
     int ret;
 
     __UCLIBC_MUTEX_LOCK(mylock);
     setprotoent(proto_stayopen);
     while (!(ret=getprotoent_r(result_buf, buf, buflen, result)))
-		if (result_buf->p_proto == proto_num)
-			break;
+	if (result_buf->p_proto == proto_num)
+	    break;
     if (!proto_stayopen)
-		endprotoent();
+	endprotoent();
     __UCLIBC_MUTEX_UNLOCK(mylock);
     return *result?0:ret;
 }
diff -urN a/libc/inet/getservice.c b/libc/inet/getservice.c
--- a/libc/inet/getservice.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/inet/getservice.c	2012-04-10 13:55:23.000000000 +0800
@@ -80,9 +80,9 @@
 static void __initbuf(void)
 {
     if (!servbuf) {
-		servbuf = malloc(SBUFSIZE);
-		if (!servbuf)
-			abort();
+	servbuf = malloc(SBUFSIZE);
+	if (!servbuf)
+	    abort();
     }
 }
 
@@ -90,9 +90,9 @@
 {
     __UCLIBC_MUTEX_LOCK(mylock);
     if (servf == NULL)
-		servf = fopen(_PATH_SERVICES, "r" );
+	servf = fopen(_PATH_SERVICES, "r" );
     else
-		rewind(servf);
+	rewind(servf);
     serv_stayopen |= f;
     __UCLIBC_MUTEX_UNLOCK(mylock);
 }
@@ -101,8 +101,8 @@
 {
     __UCLIBC_MUTEX_LOCK(mylock);
     if (servf) {
-		fclose(servf);
-		servf = NULL;
+	fclose(servf);
+	servf = NULL;
     }
     serv_stayopen = 0;
     __UCLIBC_MUTEX_UNLOCK(mylock);
@@ -138,8 +138,8 @@
 }
 
 int getservent_r(struct servent * result_buf,
-				 char * buf, size_t buflen,
-				 struct servent ** result)
+		 char * buf, size_t buflen,
+		 struct servent ** result)
 {
     char *p;
     register char *cp, **q;
@@ -150,8 +150,8 @@
     *result=NULL;
 
     if (buflen < sizeof(*serv_aliases)*MAXALIASES) {
-		errno=ERANGE;
-		return errno;
+	errno=ERANGE;
+	return errno;
     }
     __UCLIBC_MUTEX_LOCK(mylock);
     serv_aliases=(char **)buf;
@@ -170,44 +170,44 @@
 		errno=rv=EIO;
 		goto DONE;
     }
- again:
+again:
     if ((p = fgets(line, BUFSIZ, servf)) == NULL) {
 		errno=rv=EIO;
 		goto DONE;
     }
     if (*p == '#')
-		goto again;
+	goto again;
     cp = strpbrk(p, "#\n");
     if (cp == NULL)
-		goto again;
+	goto again;
     *cp = '\0';
     result_buf->s_name = p;
     p = strpbrk(p, " \t");
     if (p == NULL)
-		goto again;
+	goto again;
     *p++ = '\0';
     while (*p == ' ' || *p == '\t')
-		p++;
+	p++;
     cp = strpbrk(p, ",/");
     if (cp == NULL)
-		goto again;
+	goto again;
     *cp++ = '\0';
     result_buf->s_port = htons((u_short)atoi(p));
     result_buf->s_proto = cp;
     q = result_buf->s_aliases = serv_aliases;
     cp = strpbrk(cp, " \t");
     if (cp != NULL)
-		*cp++ = '\0';
+	*cp++ = '\0';
     while (cp && *cp) {
-		if (*cp == ' ' || *cp == '\t') {
-			cp++;
-			continue;
-		}
-		if (q < &serv_aliases[MAXALIASES - 1])
-			*q++ = cp;
-		cp = strpbrk(cp, " \t");
-		if (cp != NULL)
-			*cp++ = '\0';
+	if (*cp == ' ' || *cp == '\t') {
+	    cp++;
+	    continue;
+	}
+	if (q < &serv_aliases[MAXALIASES - 1])
+	    *q++ = cp;
+	cp = strpbrk(cp, " \t");
+	if (cp != NULL)
+	    *cp++ = '\0';
     }
     *q = NULL;
     *result=result_buf;
@@ -220,8 +220,8 @@
 }
 
 int getservbyname_r(const char *name, const char *proto,
-					struct servent * result_buf, char * buf, size_t buflen,
-					struct servent ** result)
+	struct servent * result_buf, char * buf, size_t buflen,
+	struct servent ** result)
 {
     register char **cp;
     int ret;
@@ -229,38 +229,38 @@
     __UCLIBC_MUTEX_LOCK(mylock);
     setservent(serv_stayopen);
     while (!(ret=getservent_r(result_buf, buf, buflen, result))) {
-		if (strcmp(name, result_buf->s_name) == 0)
-			goto gotname;
-		for (cp = result_buf->s_aliases; *cp; cp++)
-			if (strcmp(name, *cp) == 0)
-				goto gotname;
-		continue;
-	gotname:
-		if (proto == 0 || strcmp(result_buf->s_proto, proto) == 0)
-			break;
+	if (strcmp(name, result_buf->s_name) == 0)
+	    goto gotname;
+	for (cp = result_buf->s_aliases; *cp; cp++)
+	    if (strcmp(name, *cp) == 0)
+		goto gotname;
+	continue;
+gotname:
+	if (proto == 0 || strcmp(result_buf->s_proto, proto) == 0)
+	    break;
     }
     if (!serv_stayopen)
-		endservent();
+	endservent();
     __UCLIBC_MUTEX_UNLOCK(mylock);
     return *result?0:ret;
 }
 
 int getservbyport_r(int port, const char *proto,
-					struct servent * result_buf, char * buf,
-					size_t buflen, struct servent ** result)
+	struct servent * result_buf, char * buf,
+	size_t buflen, struct servent ** result)
 {
     int ret;
 
     __UCLIBC_MUTEX_LOCK(mylock);
     setservent(serv_stayopen);
     while (!(ret=getservent_r(result_buf, buf, buflen, result))) {
-		if (result_buf->s_port != port)
-			continue;
-		if (proto == 0 || strcmp(result_buf->s_proto, proto) == 0)
-			break;
+	if (result_buf->s_port != port)
+	    continue;
+	if (proto == 0 || strcmp(result_buf->s_proto, proto) == 0)
+	    break;
     }
     if (!serv_stayopen)
-		endservent();
+	endservent();
     __UCLIBC_MUTEX_UNLOCK(mylock);
     return *result?0:ret;
 }
diff -urN a/libc/inet/.indent.pro b/libc/inet/.indent.pro
--- a/libc/inet/.indent.pro	2000-10-10 04:06:30.000000000 +0800
+++ b/libc/inet/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/inet/resolv.c b/libc/inet/resolv.c
--- a/libc/inet/resolv.c	2007-02-22 06:27:09.000000000 +0700
+++ b/libc/inet/resolv.c	2012-04-25 02:42:00.000000000 +0800
@@ -7,7 +7,7 @@
  * modify it under the terms of the GNU Library General Public
  * License as published by the Free Software Foundation; either
  * version 2 of the License, or (at your option) any later version.
- */
+*/
 
 /*
  * Portions Copyright (c) 1985, 1993
@@ -134,7 +134,6 @@
  */
 
 #define __FORCE_GLIBC
-#define _GNU_SOURCE
 #include <features.h>
 #include <string.h>
 #include <stdio.h>
@@ -154,16 +153,11 @@
 #include <sys/utsname.h>
 #include <sys/un.h>
 
-#include <bits/uClibc_mutex.h>
-
-__UCLIBC_MUTEX_EXTERN(__resolv_lock);
-
-
-#define MAX_RECURSE 5
+#define MAX_RECURSE 3
 #define REPLY_TIMEOUT 10
-#define MAX_RETRIES 3
+#define MAX_RETRIES 2
 #define MAX_SERVERS 3
-#define MAX_SEARCH 4
+#define MAX_SEARCH 3
 
 #define MAX_ALIASES	5
 
@@ -181,14 +175,23 @@
 
 
 /* Global stuff (stuff needing to be locked to be thread safe)... */
-
-/* We use __resolv_lock to guard access to the
- * '__nameservers' and __searchdomains globals */
 extern int __nameservers;
 extern char * __nameserver[MAX_SERVERS];
 extern int __searchdomains;
 extern char * __searchdomain[MAX_SEARCH];
 
+#ifdef __UCLIBC_HAS_THREADS__
+#include <pthread.h>
+extern pthread_mutex_t __resolv_lock;
+# define BIGLOCK	__pthread_mutex_lock(&__resolv_lock)
+# define BIGUNLOCK	__pthread_mutex_unlock(&__resolv_lock);
+#else
+# define BIGLOCK
+# define BIGUNLOCK
+#endif
+
+
+
 /* Structs */
 struct resolv_header {
 	int id;
@@ -226,49 +229,49 @@
 
 /* function prototypes */
 extern int __get_hosts_byname_r(const char * name, int type,
-								struct hostent * result_buf,
-								char * buf, size_t buflen,
-								struct hostent ** result,
-								int * h_errnop);
+			      struct hostent * result_buf,
+			      char * buf, size_t buflen,
+			      struct hostent ** result,
+			      int * h_errnop);
 extern int __get_hosts_byaddr_r(const char * addr, int len, int type,
-								struct hostent * result_buf,
-								char * buf, size_t buflen,
-								struct hostent ** result,
-								int * h_errnop);
+			      struct hostent * result_buf,
+			      char * buf, size_t buflen,
+			      struct hostent ** result,
+			      int * h_errnop);
 extern void __open_etc_hosts(FILE **fp);
 extern int __read_etc_hosts_r(FILE *fp, const char * name, int type,
-							  enum etc_hosts_action action,
-							  struct hostent * result_buf,
-							  char * buf, size_t buflen,
-							  struct hostent ** result,
-							  int * h_errnop);
+			    enum etc_hosts_action action,
+			    struct hostent * result_buf,
+			    char * buf, size_t buflen,
+			    struct hostent ** result,
+			    int * h_errnop);
 extern int __dns_lookup(const char * name, int type, int nscount,
-						char ** nsip, unsigned char ** outpacket, struct resolv_answer * a);
+	char ** nsip, unsigned char ** outpacket, struct resolv_answer * a);
 
 extern int __encode_dotted(const char * dotted, unsigned char * dest, int maxlen);
 extern int __decode_dotted(const unsigned char * message, int offset,
-						   char * dest, int maxlen);
+	char * dest, int maxlen);
 extern int __length_dotted(const unsigned char * message, int offset);
 extern int __encode_header(struct resolv_header * h, unsigned char * dest, int maxlen);
 extern int __decode_header(unsigned char * data, struct resolv_header * h);
 extern int __encode_question(struct resolv_question * q,
-							 unsigned char * dest, int maxlen);
+	unsigned char * dest, int maxlen);
 extern int __decode_question(unsigned char * message, int offset,
-							 struct resolv_question * q);
+	struct resolv_question * q);
 extern int __encode_answer(struct resolv_answer * a,
-						   unsigned char * dest, int maxlen);
+	unsigned char * dest, int maxlen);
 extern int __decode_answer(unsigned char * message, int offset,
-						   struct resolv_answer * a);
+	struct resolv_answer * a);
 extern int __length_question(unsigned char * message, int offset);
 extern int __open_nameservers(void);
 extern void __close_nameservers(void);
 extern int __dn_expand(const u_char *, const u_char *, const u_char *,
-					   char *, int);
+	char *, int);
 extern int __ns_name_uncompress(const u_char *, const u_char *,
-								const u_char *, char *, size_t);
+		const u_char *, char *, size_t);
 extern int __ns_name_ntop(const u_char *, char *, size_t);
 extern int __ns_name_unpack(const u_char *, const u_char *, const u_char *,
-							u_char *, size_t);
+               u_char *, size_t);
 
 
 #ifdef L_encodeh
@@ -358,7 +361,7 @@
    This routine understands compressed data. */
 
 int __decode_dotted(const unsigned char *data, int offset,
-					char *dest, int maxlen)
+				  char *dest, int maxlen)
 {
 	int l;
 	int measure = 1;
@@ -432,7 +435,7 @@
 
 #ifdef L_encodeq
 int __encode_question(struct resolv_question *q,
-					  unsigned char *dest, int maxlen)
+					unsigned char *dest, int maxlen)
 {
 	int i;
 
@@ -457,7 +460,7 @@
 
 #ifdef L_decodeq
 int __decode_question(unsigned char *message, int offset,
-					  struct resolv_question *q)
+					struct resolv_question *q)
 {
 	char temp[256];
 	int i;
@@ -522,7 +525,7 @@
 
 #ifdef L_decodea
 int __decode_answer(unsigned char *message, int offset,
-					struct resolv_answer *a)
+				  struct resolv_answer *a)
 {
 	char temp[256];
 	int i;
@@ -554,11 +557,11 @@
 
 #ifdef L_encodep
 int __encode_packet(struct resolv_header *h,
-					struct resolv_question **q,
-					struct resolv_answer **an,
-					struct resolv_answer **ns,
-					struct resolv_answer **ar,
-					unsigned char *dest, int maxlen)
+	struct resolv_question **q,
+	struct resolv_answer **an,
+	struct resolv_answer **ns,
+	struct resolv_answer **ar,
+	unsigned char *dest, int maxlen)
 {
 	int i, total = 0;
 	int j;
@@ -618,7 +621,7 @@
 
 #ifdef L_formquery
 int __form_query(int id, const char *name, int type, unsigned char *packet,
-				 int maxlen)
+			   int maxlen)
 {
 	struct resolv_header h;
 	struct resolv_question q;
@@ -646,7 +649,14 @@
 
 #ifdef L_dnslookup
 
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+#ifdef __UCLIBC_HAS_THREADS__
+static pthread_mutex_t mylock = PTHREAD_MUTEX_INITIALIZER;
+# define LOCK	__pthread_mutex_lock(&mylock)
+# define UNLOCK	__pthread_mutex_unlock(&mylock);
+#else
+# define LOCK
+# define UNLOCK
+#endif
 
 /* Just for the record, having to lock __dns_lookup() just for these two globals
  * is pretty lame.  I think these two variables can probably be de-global-ized,
@@ -655,7 +665,7 @@
 static int ns=0, id=1;
 
 int __dns_lookup(const char *name, int type, int nscount, char **nsip,
-				 unsigned char **outpacket, struct resolv_answer *a)
+			   unsigned char **outpacket, struct resolv_answer *a)
 {
 	int i, j, len, fd, pos, rc;
 	struct timeval tv;
@@ -683,10 +693,10 @@
 	DPRINTF("Looking up type %d answer for '%s'\n", type, name);
 
 	/* Mess with globals while under lock */
-	__UCLIBC_MUTEX_LOCK(mylock);
+	LOCK;
 	local_ns = ns % nscount;
 	local_id = id;
-	__UCLIBC_MUTEX_UNLOCK(mylock);
+	UNLOCK;
 
 	while (retries < MAX_RETRIES) {
 		if (fd != -1)
@@ -699,11 +709,7 @@
 		++local_id;
 		local_id &= 0xffff;
 		h.id = local_id;
-		__UCLIBC_MUTEX_LOCK(__resolv_lock);
-		/* this is really __nameserver[] which is a global that
-		   needs to hold __resolv_lock before access!! */
 		dns = nsip[local_ns];
-		__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
 
 		h.qdcount = 1;
 		h.rd = 1;
@@ -716,13 +722,13 @@
 
 		strncpy(lookup,name,MAXDNAME);
 		if (variant >= 0) {
-			__UCLIBC_MUTEX_LOCK(__resolv_lock);
-			if (variant < __searchdomains) {
-				strncat(lookup,".", MAXDNAME);
-				strncat(lookup,__searchdomain[variant], MAXDNAME);
-			}
-			__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
-		}
+                        BIGLOCK;
+                        if (variant < __searchdomains) {
+                                strncat(lookup,".", MAXDNAME);
+                                strncat(lookup,__searchdomain[variant], MAXDNAME);
+                        }
+                        BIGUNLOCK;
+                }
 		DPRINTF("lookup name: %s\n", lookup);
 		q.dotted = (char *)lookup;
 		q.qtype = type;
@@ -738,17 +744,13 @@
 				retries+1, NAMESERVER_PORT, dns);
 
 #ifdef __UCLIBC_HAS_IPV6__
-		__UCLIBC_MUTEX_LOCK(__resolv_lock);
-		/* 'dns' is really __nameserver[] which is a global that
-		   needs to hold __resolv_lock before access!! */
 		v6 = inet_pton(AF_INET6, dns, &sa6.sin6_addr) > 0;
-		__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
 		fd = socket(v6 ? AF_INET6 : AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 #else
 		fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 #endif
 		if (fd < 0) {
-			retries++;
+                    retries++;
 		    continue;
 		}
 
@@ -763,22 +765,18 @@
 #endif
 		    sa.sin_family = AF_INET;
 		    sa.sin_port = htons(NAMESERVER_PORT);
-		    __UCLIBC_MUTEX_LOCK(__resolv_lock);
-		    /* 'dns' is really __nameserver[] which is a global that
-		       needs to hold __resolv_lock before access!! */
 		    sa.sin_addr.s_addr = inet_addr(dns);
-		    __UCLIBC_MUTEX_UNLOCK(__resolv_lock);
 		    rc = connect(fd, (struct sockaddr *) &sa, sizeof(sa));
 #ifdef __UCLIBC_HAS_IPV6__
 		}
 #endif
 		if (rc < 0) {
 		    if (errno == ENETUNREACH) {
-				/* routing error, presume not transient */
-				goto tryall;
+			/* routing error, presume not transient */
+			goto tryall;
 		    } else
-				/* retry */
-				retries++;
+			/* retry */
+                        retries++;
 			continue;
 		}
 
@@ -840,55 +838,55 @@
 
 		first_answer = 1;
 		for (j=0;j<h.ancount;j++,pos += i)
-			{
-				i = __decode_answer(packet, pos, &ma);
+		{
+		    i = __decode_answer(packet, pos, &ma);
 
-				if (i<0) {
-					DPRINTF("failed decode %d\n", i);
-					goto again;
-				}
+		    if (i<0) {
+			DPRINTF("failed decode %d\n", i);
+			goto again;
+		    }
 
-				if ( first_answer )
-					{
-						ma.buf = a->buf;
-						ma.buflen = a->buflen;
-						ma.add_count = a->add_count;
-						memcpy(a, &ma, sizeof(ma));
-						if (a->atype != T_SIG && (0 == a->buf || (type != T_A && type != T_AAAA)))
-							{
-								break;
-							}
-						if (a->atype != type)
-							{
-								free(a->dotted);
-								continue;
-							}
-						a->add_count = h.ancount - j - 1;
-						if ((a->rdlength + sizeof(struct in_addr*)) * a->add_count > a->buflen)
-							{
-								break;
-							}
-						a->add_count = 0;
-						first_answer = 0;
-					}
-				else
-					{
-						free(ma.dotted);
-						if (ma.atype != type)
-							{
-								continue;
-							}
-						if (a->rdlength != ma.rdlength)
-							{
-								free(a->dotted);
-								DPRINTF("Answer address len(%u) differs from original(%u)\n",
-										ma.rdlength, a->rdlength);
-								goto again;
-							}
-						memcpy(a->buf + (a->add_count * ma.rdlength), ma.rdata, ma.rdlength);
-						++a->add_count;
-					}
+		    if ( first_answer )
+		    {
+			ma.buf = a->buf;
+			ma.buflen = a->buflen;
+			ma.add_count = a->add_count;
+			memcpy(a, &ma, sizeof(ma));
+			if (a->atype != T_SIG && (0 == a->buf || (type != T_A && type != T_AAAA)))
+			{
+			    break;
+			}
+			if (a->atype != type)
+			{
+			    free(a->dotted);
+			    continue;
+			}
+			a->add_count = h.ancount - j - 1;
+			if ((a->rdlength + sizeof(struct in_addr*)) * a->add_count > a->buflen)
+			{
+			    break;
+			}
+			a->add_count = 0;
+			first_answer = 0;
+		    }
+		    else
+		    {
+			free(ma.dotted);
+			if (ma.atype != type)
+			{
+			    continue;
 			}
+			if (a->rdlength != ma.rdlength)
+			{
+			    free(a->dotted);
+			    DPRINTF("Answer address len(%u) differs from original(%u)\n",
+				    ma.rdlength, a->rdlength);
+			    goto again;
+			}
+			memcpy(a->buf + (a->add_count * ma.rdlength), ma.rdata, ma.rdlength);
+			++a->add_count;
+		    }
+		}
 
 		DPRINTF("Answer name = |%s|\n", a->dotted);
 		DPRINTF("Answer type = |%d|\n", a->atype);
@@ -902,48 +900,48 @@
 		free(lookup);
 
 		/* Mess with globals while under lock */
-		__UCLIBC_MUTEX_LOCK(mylock);
+		LOCK;
 		ns = local_ns;
 		id = local_id;
-		__UCLIBC_MUTEX_UNLOCK(mylock);
+		UNLOCK;
 
 		return (len);				/* success! */
 
-	tryall:
+	  tryall:
 		/* if there are other nameservers, give them a go,
 		   otherwise return with error */
 		{
 		    variant = -1;
-			local_ns = (local_ns + 1) % nscount;
-			if (local_ns == 0)
-				retries++;
+                    local_ns = (local_ns + 1) % nscount;
+                    if (local_ns == 0)
+                      retries++;
 
-			continue;
+                    continue;
 		}
 
-	again:
+	  again:
 		/* if there are searchdomains, try them or fallback as passed */
 		{
 		    int sdomains;
-		    __UCLIBC_MUTEX_LOCK(__resolv_lock);
+		    BIGLOCK;
 		    sdomains=__searchdomains;
-		    __UCLIBC_MUTEX_UNLOCK(__resolv_lock);
+		    BIGUNLOCK;
 
 		    if (variant < sdomains - 1) {
-				/* next search */
-				variant++;
+			/* next search */
+			variant++;
 		    } else {
-				/* next server, first search */
-				local_ns = (local_ns + 1) % nscount;
-				if (local_ns == 0)
-					retries++;
+			/* next server, first search */
+			local_ns = (local_ns + 1) % nscount;
+                        if (local_ns == 0)
+                          retries++;
 
-				variant = -1;
+			variant = -1;
 		    }
 		}
 	}
 
- fail:
+fail:
 	if (fd != -1)
 	    close(fd);
 	if (lookup)
@@ -953,10 +951,10 @@
 	h_errno = NETDB_INTERNAL;
 	/* Mess with globals while under lock */
 	if (local_ns != -1) {
-	    __UCLIBC_MUTEX_LOCK(mylock);
+	    LOCK;
 	    ns = local_ns;
 	    id = local_id;
-	    __UCLIBC_MUTEX_UNLOCK(mylock);
+	    UNLOCK;
 	}
 	return -1;
 }
@@ -968,8 +966,9 @@
 char * __nameserver[MAX_SERVERS];
 int __searchdomains;
 char * __searchdomain[MAX_SEARCH];
-
-__UCLIBC_MUTEX_INIT(__resolv_lock, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
+#ifdef __UCLIBC_HAS_THREADS__
+pthread_mutex_t __resolv_lock = PTHREAD_MUTEX_INITIALIZER;
+#endif
 
 /*
  *	we currently read formats not quite the same as that on normal
@@ -983,63 +982,60 @@
 #define RESOLV_ARGS 5
 	char szBuffer[128], *p, *argv[RESOLV_ARGS];
 	int argc;
-	int rv = 0;
 
-	__UCLIBC_MUTEX_LOCK(__resolv_lock);
+	BIGLOCK;
 	if (__nameservers > 0) {
-		goto DONE;
+	    BIGUNLOCK;
+	    return 0;
 	}
 
 	if ((fp = fopen("/etc/resolv.conf", "r")) ||
-		(fp = fopen("/etc/config/resolv.conf", "r")))
-		{
+			(fp = fopen("/etc/config/resolv.conf", "r")))
+	{
 
-			while (fgets(szBuffer, sizeof(szBuffer), fp) != NULL) {
+		while (fgets(szBuffer, sizeof(szBuffer), fp) != NULL) {
 
-				for (p = szBuffer; *p && isspace(*p); p++)
-					/* skip white space */;
-				if (*p == '\0' || *p == '\n' || *p == '#') /* skip comments etc */
-					continue;
-				argc = 0;
-				while (*p && argc < RESOLV_ARGS) {
-					argv[argc++] = p;
-					while (*p && !isspace(*p) && *p != '\n')
-						p++;
-					while (*p && (isspace(*p) || *p == '\n')) /* remove spaces */
-						*p++ = '\0';
-				}
+			for (p = szBuffer; *p && isspace(*p); p++)
+				/* skip white space */;
+			if (*p == '\0' || *p == '\n' || *p == '#') /* skip comments etc */
+				continue;
+			argc = 0;
+			while (*p && argc < RESOLV_ARGS) {
+				argv[argc++] = p;
+				while (*p && !isspace(*p) && *p != '\n')
+					p++;
+				while (*p && (isspace(*p) || *p == '\n')) /* remove spaces */
+					*p++ = '\0';
+			}
 
-				if (strcmp(argv[0], "nameserver") == 0) {
-					for (i = 1; i < argc && __nameservers < MAX_SERVERS; i++) {
-						__nameserver[__nameservers++] = strdup(argv[i]);
-						DPRINTF("adding nameserver %s\n", argv[i]);
-					}
+			if (strcmp(argv[0], "nameserver") == 0) {
+				for (i = 1; i < argc && __nameservers < MAX_SERVERS; i++) {
+					__nameserver[__nameservers++] = strdup(argv[i]);
+					DPRINTF("adding nameserver %s\n", argv[i]);
 				}
+			}
 
-				/* domain and search are mutually exclusive, the last one wins */
-				if (strcmp(argv[0],"domain")==0 || strcmp(argv[0],"search")==0) {
-					while (__searchdomains > 0) {
-						free(__searchdomain[--__searchdomains]);
-						__searchdomain[__searchdomains] = NULL;
-					}
-					for (i=1; i < argc && __searchdomains < MAX_SEARCH; i++) {
-						__searchdomain[__searchdomains++] = strdup(argv[i]);
-						DPRINTF("adding search %s\n", argv[i]);
-					}
+			/* domain and search are mutually exclusive, the last one wins */
+			if (strcmp(argv[0],"domain")==0 || strcmp(argv[0],"search")==0) {
+				while (__searchdomains > 0) {
+					free(__searchdomain[--__searchdomains]);
+					__searchdomain[__searchdomains] = NULL;
+				}
+				for (i=1; i < argc && __searchdomains < MAX_SEARCH; i++) {
+					__searchdomain[__searchdomains++] = strdup(argv[i]);
+					DPRINTF("adding search %s\n", argv[i]);
 				}
 			}
-			fclose(fp);
-			DPRINTF("nameservers = %d\n", __nameservers);
-			goto DONE;
 		}
+		fclose(fp);
+		DPRINTF("nameservers = %d\n", __nameservers);
+		BIGUNLOCK;
+		return 0;
+	}
 	DPRINTF("failed to open %s\n", "resolv.conf");
 	h_errno = NO_RECOVERY;
-
-	rv = -1;
-
- DONE:
-	__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
-	return rv;
+	BIGUNLOCK;
+	return -1;
 }
 #endif
 
@@ -1048,7 +1044,7 @@
 
 void __close_nameservers(void)
 {
-	__UCLIBC_MUTEX_LOCK(__resolv_lock);
+	BIGLOCK;
 	while (__nameservers > 0) {
 		free(__nameserver[--__nameservers]);
 		__nameserver[__nameservers] = NULL;
@@ -1057,7 +1053,7 @@
 		free(__searchdomain[--__searchdomains]);
 		__searchdomain[__searchdomains] = NULL;
 	}
-	__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
+	BIGUNLOCK;
 }
 #endif
 
@@ -1067,8 +1063,8 @@
 {
 	static struct hostent h;
 	static char buf[sizeof(struct in_addr) +
-					sizeof(struct in_addr *)*2 +
-					sizeof(char *)*(ALIAS_DIM) + 384/*namebuffer*/ + 32/* margin */];
+			sizeof(struct in_addr *)*2 +
+			sizeof(char *)*(ALIAS_DIM) + 384/*namebuffer*/ + 32/* margin */];
 	struct hostent *hp;
 
 	gethostbyname_r(name, &h, buf, sizeof(buf), &hp, &h_errno);
@@ -1086,8 +1082,8 @@
 #else /* __UCLIBC_HAS_IPV6__ */
 	static struct hostent h;
 	static char buf[sizeof(struct in6_addr) +
-					sizeof(struct in6_addr *)*2 +
-					sizeof(char *)*(ALIAS_DIM) + 384/*namebuffer*/ + 32/* margin */];
+			sizeof(struct in6_addr *)*2 +
+			sizeof(char *)*(ALIAS_DIM) + 384/*namebuffer*/ + 32/* margin */];
 	struct hostent *hp;
 
 	gethostbyname2_r(name, family, &h, buf, sizeof(buf), &hp, &h_errno);
@@ -1100,14 +1096,12 @@
 
 
 #ifdef L_res_init
-/* We use __resolv_lock to guard access to global '_res' */
 struct __res_state _res;
 
 int res_init(void)
 {
 	struct __res_state *rp = &(_res);
 
-	__UCLIBC_MUTEX_LOCK(__resolv_lock);	/* must be a recursive lock! */
 	__close_nameservers();
 	__open_nameservers();
 	rp->retrans = RES_TIMEOUT;
@@ -1125,6 +1119,7 @@
 	/** rp->rhook = NULL; **/
 	/** rp->_u._ext.nsinit = 0; **/
 
+	BIGLOCK;
 	if(__searchdomains) {
 		int i;
 		for(i=0; i<__searchdomains; i++) {
@@ -1144,7 +1139,7 @@
 		}
 	}
 	rp->nscount = __nameservers;
-	__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
+	BIGUNLOCK;
 
 	return(0);
 }
@@ -1180,10 +1175,10 @@
 
 	memset((char *) &a, '\0', sizeof(a));
 
-	__UCLIBC_MUTEX_LOCK(__resolv_lock);
+	BIGLOCK;
 	__nameserversXX=__nameservers;
 	__nameserverXX=__nameserver;
-	__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
+	BIGUNLOCK;
 	i = __dns_lookup(dname, type, __nameserversXX, __nameserverXX, &packet, &a);
 
 	if (i < 0) {
@@ -1212,24 +1207,18 @@
  * is detected.  Error code, if any, is left in h_errno.
  */
 int res_search(name, class, type, answer, anslen)
-	 const char *name;	/* domain name */
-	 int class, type;	/* class and type of query */
-	 u_char *answer;		/* buffer to put answer */
-	 int anslen;		/* size of answer */
+	const char *name;	/* domain name */
+	int class, type;	/* class and type of query */
+	u_char *answer;		/* buffer to put answer */
+	int anslen;		/* size of answer */
 {
 	const char *cp, * const *domain;
 	HEADER *hp = (HEADER *)(void *)answer;
 	u_int dots;
 	int trailing_dot, ret, saved_herrno;
 	int got_nodata = 0, got_servfail = 0, tried_as_is = 0;
-	u_long _res_options;
-	unsigned _res_ndots;
-	char **_res_dnsrch;
-
-	__UCLIBC_MUTEX_LOCK(__resolv_lock);
-	_res_options = _res.options;
-	__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
-	if ((!name || !answer) || ((_res_options & RES_INIT) == 0 && res_init() == -1)) {
+
+	if ((!name || !answer) || ((_res.options & RES_INIT) == 0 && res_init() == -1)) {
 		h_errno = NETDB_INTERNAL;
 		return (-1);
 	}
@@ -1248,10 +1237,7 @@
 	 * 'as is'.  The threshold can be set with the "ndots" option.
 	 */
 	saved_herrno = -1;
-	__UCLIBC_MUTEX_LOCK(__resolv_lock);
-	_res_ndots = _res.ndots;
-	__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
-	if (dots >= _res_ndots) {
+	if (dots >= _res.ndots) {
 		ret = res_querydomain(name, NULL, class, type, answer, anslen);
 		if (ret > 0)
 			return (ret);
@@ -1265,20 +1251,16 @@
 	 *	- there is at least one dot, there is no trailing dot,
 	 *	  and RES_DNSRCH is set.
 	 */
-	__UCLIBC_MUTEX_LOCK(__resolv_lock);
-	_res_options = _res.options;
-	_res_dnsrch = _res.dnsrch;
-	__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
-	if ((!dots && (_res_options & RES_DEFNAMES)) ||
-	    (dots && !trailing_dot && (_res_options & RES_DNSRCH))) {
+	if ((!dots && (_res.options & RES_DEFNAMES)) ||
+	    (dots && !trailing_dot && (_res.options & RES_DNSRCH))) {
 		int done = 0;
 
-		for (domain = (const char * const *)_res_dnsrch;
-			 *domain && !done;
-			 domain++) {
+		for (domain = (const char * const *)_res.dnsrch;
+		   *domain && !done;
+		   domain++) {
 
 			ret = res_querydomain(name, *domain, class, type,
-								  answer, anslen);
+			    answer, anslen);
 			if (ret > 0)
 				return (ret);
 
@@ -1301,31 +1283,28 @@
 			}
 
 			switch (h_errno) {
-				case NO_DATA:
-					got_nodata++;
-					/* FALLTHROUGH */
-				case HOST_NOT_FOUND:
-					/* keep trying */
+			case NO_DATA:
+				got_nodata++;
+				/* FALLTHROUGH */
+			case HOST_NOT_FOUND:
+				/* keep trying */
+				break;
+			case TRY_AGAIN:
+				if (hp->rcode == SERVFAIL) {
+					/* try next search element, if any */
+					got_servfail++;
 					break;
-				case TRY_AGAIN:
-					if (hp->rcode == SERVFAIL) {
-						/* try next search element, if any */
-						got_servfail++;
-						break;
-					}
-					/* FALLTHROUGH */
-				default:
-					/* anything else implies that we're done */
-					done++;
+				}
+				/* FALLTHROUGH */
+			default:
+				/* anything else implies that we're done */
+				done++;
 			}
 			/*
 			 * if we got here for some reason other than DNSRCH,
 			 * we only wanted one iteration of the loop, so stop.
 			 */
-			__UCLIBC_MUTEX_LOCK(__resolv_lock);
-			_res_options = _res.options;
-			__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
-			if (!(_res_options & RES_DNSRCH))
+			if (!(_res.options & RES_DNSRCH))
 				done++;
 		}
 	}
@@ -1363,31 +1342,24 @@
  * removing a trailing dot from name if domain is NULL.
  */
 int res_querydomain(name, domain, class, type, answer, anslen)
-	 const char *name, *domain;
-	 int class, type;	/* class and type of query */
-	 u_char *answer;		/* buffer to put answer */
-	 int anslen;		/* size of answer */
+	const char *name, *domain;
+	int class, type;	/* class and type of query */
+	u_char *answer;		/* buffer to put answer */
+	int anslen;		/* size of answer */
 {
 	char nbuf[MAXDNAME];
 	const char *longname = nbuf;
 	size_t n, d;
-	u_long _res_options;
 
-	__UCLIBC_MUTEX_LOCK(__resolv_lock);
-	_res_options = _res.options;
-	__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
-	if ((!name || !answer) || ((_res_options & RES_INIT) == 0 && res_init() == -1)) {
+	if ((!name || !answer) || ((_res.options & RES_INIT) == 0 && res_init() == -1)) {
 		h_errno = NETDB_INTERNAL;
 		return (-1);
 	}
 
 #ifdef DEBUG
-	__UCLIBC_MUTEX_LOCK(__resolv_lock);
-	_res_options = _res.options;
-	__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
-	if (_res_options & RES_DEBUG)
+	if (_res.options & RES_DEBUG)
 		printf(";; res_querydomain(%s, %s, %d, %d)\n",
-			   name, domain?domain:"<Nil>", class, type);
+			name, domain?domain:"<Nil>", class, type);
 #endif
 	if (domain == NULL) {
 		/*
@@ -1428,11 +1400,11 @@
 	static struct hostent h;
 	static char buf[
 #ifndef __UCLIBC_HAS_IPV6__
-					sizeof(struct in_addr) + sizeof(struct in_addr *)*2 +
+		sizeof(struct in_addr) + sizeof(struct in_addr *)*2 +
 #else
-					sizeof(struct in6_addr) + sizeof(struct in6_addr *)*2 +
+		sizeof(struct in6_addr) + sizeof(struct in6_addr *)*2 +
 #endif /* __UCLIBC_HAS_IPV6__ */
-					sizeof(char *)*(ALIAS_DIM) + 384/*namebuffer*/ + 32/* margin */];
+		sizeof(char *)*(ALIAS_DIM) + 384/*namebuffer*/ + 32/* margin */];
 	struct hostent *hp;
 
 	gethostbyaddr_r(addr, len, type, &h, buf, sizeof(buf), &hp, &h_errno);
@@ -1453,11 +1425,11 @@
 }
 
 int __read_etc_hosts_r(FILE * fp, const char * name, int type,
-					   enum etc_hosts_action action,
-					   struct hostent * result_buf,
-					   char * buf, size_t buflen,
-					   struct hostent ** result,
-					   int * h_errnop)
+		     enum etc_hosts_action action,
+		     struct hostent * result_buf,
+		     char * buf, size_t buflen,
+		     struct hostent ** result,
+		     int * h_errnop)
 {
 	struct in_addr	*in=NULL;
 	struct in_addr	**addr_list=NULL;
@@ -1586,7 +1558,7 @@
 		} else {
 			DPRINTF("Error\n");
 			ret=TRY_AGAIN;
-			break; /* bad ip address */
+			continue; /* bad ip address, ignore */
         }
 
 		if (action!=GETHOSTENT) {
@@ -1604,49 +1576,56 @@
 
 #ifdef L_gethostent
 
-__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);
+#ifdef __UCLIBC_HAS_THREADS__
+static pthread_mutex_t mylock = PTHREAD_MUTEX_INITIALIZER;
+# define LOCK	__pthread_mutex_lock(&mylock)
+# define UNLOCK	__pthread_mutex_unlock(&mylock);
+#else
+# define LOCK
+# define UNLOCK
+#endif
 
 static int __stay_open;
 static FILE * __gethostent_fp;
 
 void endhostent (void)
 {
-    __UCLIBC_MUTEX_LOCK(mylock);
+    LOCK;
     __stay_open = 0;
     if (__gethostent_fp) {
-		fclose(__gethostent_fp);
+	fclose(__gethostent_fp);
     }
-    __UCLIBC_MUTEX_UNLOCK(mylock);
+    UNLOCK;
 }
 
 void sethostent (int stay_open)
 {
-    __UCLIBC_MUTEX_LOCK(mylock);
+    LOCK;
     __stay_open = stay_open;
-    __UCLIBC_MUTEX_UNLOCK(mylock);
+    UNLOCK;
 }
 
 int gethostent_r(struct hostent *result_buf, char *buf, size_t buflen,
-				 struct hostent **result, int *h_errnop)
+	struct hostent **result, int *h_errnop)
 {
-    int ret = 0;
+    int ret = HOST_NOT_FOUND;
 
-    __UCLIBC_MUTEX_LOCK(mylock);
+    LOCK;
     if (__gethostent_fp == NULL) {
-		__open_etc_hosts(&__gethostent_fp);
-		if (__gethostent_fp == NULL) {
-			*result=NULL;
-			goto DONE;
-		}
+	__open_etc_hosts(&__gethostent_fp);
+	if (__gethostent_fp == NULL) {
+	    UNLOCK;
+	    *result=NULL;
+	    return 0;
+	}
     }
 
     ret = __read_etc_hosts_r(__gethostent_fp, NULL, AF_INET, GETHOSTENT,
-							 result_buf, buf, buflen, result, h_errnop);
+		   result_buf, buf, buflen, result, h_errnop);
     if (__stay_open==0) {
-		fclose(__gethostent_fp);
+	fclose(__gethostent_fp);
     }
- DONE:
-    __UCLIBC_MUTEX_UNLOCK(mylock);
+    UNLOCK;
     return(ret);
 }
 
@@ -1655,17 +1634,17 @@
     static struct hostent h;
     static char buf[
 #ifndef __UCLIBC_HAS_IPV6__
-					sizeof(struct in_addr) + sizeof(struct in_addr *)*2 +
+	    sizeof(struct in_addr) + sizeof(struct in_addr *)*2 +
 #else
-					sizeof(struct in6_addr) + sizeof(struct in6_addr *)*2 +
+	    sizeof(struct in6_addr) + sizeof(struct in6_addr *)*2 +
 #endif /* __UCLIBC_HAS_IPV6__ */
-					sizeof(char *)*(ALIAS_DIM) +
-					80/*namebuffer*/ + 2/* margin */];
+		sizeof(char *)*(ALIAS_DIM) +
+	    80/*namebuffer*/ + 2/* margin */];
     struct hostent *host;
 
-    __UCLIBC_MUTEX_LOCK(mylock);
+    LOCK;
     gethostent_r(&h, buf, sizeof(buf), &host, &h_errno);
-    __UCLIBC_MUTEX_UNLOCK(mylock);
+    UNLOCK;
     return(host);
 }
 #endif
@@ -1673,23 +1652,23 @@
 #ifdef L_get_hosts_byname_r
 
 int __get_hosts_byname_r(const char * name, int type,
-						 struct hostent * result_buf,
-						 char * buf, size_t buflen,
-						 struct hostent ** result,
-						 int * h_errnop)
+			    struct hostent * result_buf,
+			    char * buf, size_t buflen,
+			    struct hostent ** result,
+			    int * h_errnop)
 {
 	return(__read_etc_hosts_r(NULL, name, type, GET_HOSTS_BYNAME,
-							  result_buf, buf, buflen, result, h_errnop));
+		    result_buf, buf, buflen, result, h_errnop));
 }
 #endif
 
 #ifdef L_get_hosts_byaddr_r
 
 int __get_hosts_byaddr_r(const char * addr, int len, int type,
-						 struct hostent * result_buf,
-						 char * buf, size_t buflen,
-						 struct hostent ** result,
-						 int * h_errnop)
+			    struct hostent * result_buf,
+			    char * buf, size_t buflen,
+			    struct hostent ** result,
+			    int * h_errnop)
 {
 #ifndef __UCLIBC_HAS_IPV6__
 	char	ipaddr[INET_ADDRSTRLEN];
@@ -1698,24 +1677,24 @@
 #endif /* __UCLIBC_HAS_IPV6__ */
 
     switch (type) {
-		case AF_INET:
-			if (len != sizeof(struct in_addr))
-				return 0;
-			break;
+	case AF_INET:
+		if (len != sizeof(struct in_addr))
+			return 0;
+		break;
 #ifdef __UCLIBC_HAS_IPV6__
-		case AF_INET6:
-			if (len != sizeof(struct in6_addr))
-				return 0;
-			break;
-#endif /* __UCLIBC_HAS_IPV6__ */
-		default:
+	case AF_INET6:
+		if (len != sizeof(struct in6_addr))
 			return 0;
+		break;
+#endif /* __UCLIBC_HAS_IPV6__ */
+	default:
+		return 0;
 	}
 
 	inet_ntop(type, addr, ipaddr, sizeof(ipaddr));
 
 	return(__read_etc_hosts_r(NULL, ipaddr, type, GET_HOSTS_BYADDR,
-							  result_buf, buf, buflen, result, h_errnop));
+		    result_buf, buf, buflen, result, h_errnop));
 }
 #endif
 
@@ -1726,8 +1705,8 @@
 #endif /* min */
 
 int getnameinfo (const struct sockaddr *sa, socklen_t addrlen, char *host,
-				 socklen_t hostlen, char *serv, socklen_t servlen,
-				 unsigned int flags)
+	     socklen_t hostlen, char *serv, socklen_t servlen,
+	     unsigned int flags)
 {
 	int serrno = errno;
 	int ok = 0;
@@ -1741,167 +1720,167 @@
 		return EAI_FAMILY;
 
 	switch (sa->sa_family) {
-		case AF_LOCAL:
-			break;
-		case AF_INET:
-			if (addrlen < sizeof (struct sockaddr_in))
-				return EAI_FAMILY;
-			break;
+	case AF_LOCAL:
+		break;
+	case AF_INET:
+		if (addrlen < sizeof (struct sockaddr_in))
+			return EAI_FAMILY;
+		break;
 #ifdef __UCLIBC_HAS_IPV6__
-		case AF_INET6:
-			if (addrlen < sizeof (struct sockaddr_in6))
-				return EAI_FAMILY;
-			break;
-#endif /* __UCLIBC_HAS_IPV6__ */
-		default:
+	case AF_INET6:
+		if (addrlen < sizeof (struct sockaddr_in6))
 			return EAI_FAMILY;
+		break;
+#endif /* __UCLIBC_HAS_IPV6__ */
+	default:
+		return EAI_FAMILY;
 	}
 
 	if (host != NULL && hostlen > 0)
 		switch (sa->sa_family) {
-			case AF_INET:
+		case AF_INET:
 #ifdef __UCLIBC_HAS_IPV6__
-			case AF_INET6:
+		case AF_INET6:
 #endif /* __UCLIBC_HAS_IPV6__ */
-				if (!(flags & NI_NUMERICHOST)) {
+			if (!(flags & NI_NUMERICHOST)) {
 #ifdef __UCLIBC_HAS_IPV6__
-					if (sa->sa_family == AF_INET6)
-						h = gethostbyaddr ((const void *)
-										   &(((const struct sockaddr_in6 *) sa)->sin6_addr),
-										   sizeof(struct in6_addr), AF_INET6);
-					else
-#endif /* __UCLIBC_HAS_IPV6__ */
-						h = gethostbyaddr ((const void *) &(((const struct sockaddr_in *)sa)->sin_addr),
-										   sizeof(struct in_addr), AF_INET);
-
-					if (h) {
-						char *c;
-						if ((flags & NI_NOFQDN)
-							&& (getdomainname (domain, sizeof(domain)) == 0)
-							&& (c = strstr (h->h_name, domain))
-							&& (c != h->h_name) && (*(--c) == '.')) {
-							strncpy (host, h->h_name,
-									 min(hostlen, (size_t) (c - h->h_name)));
-							host[min(hostlen - 1, (size_t) (c - h->h_name))] = '\0';
-							ok = 1;
-						} else {
-							strncpy (host, h->h_name, hostlen);
-							ok = 1;
-						}
-					}
-				}
+				if (sa->sa_family == AF_INET6)
+					h = gethostbyaddr ((const void *)
+						&(((const struct sockaddr_in6 *) sa)->sin6_addr),
+						sizeof(struct in6_addr), AF_INET6);
+				else
+#endif /* __UCLIBC_HAS_IPV6__ */
+                    h = gethostbyaddr ((const void *) &(((const struct sockaddr_in *)sa)->sin_addr),
+					  sizeof(struct in_addr), AF_INET);
 
-				if (!ok) {
-					if (flags & NI_NAMEREQD) {
-						errno = serrno;
-						return EAI_NONAME;
+				if (h) {
+					char *c;
+					if ((flags & NI_NOFQDN)
+					    && (getdomainname (domain, sizeof(domain)) == 0)
+					    && (c = strstr (h->h_name, domain))
+					    && (c != h->h_name) && (*(--c) == '.')) {
+						strncpy (host, h->h_name,
+							min(hostlen, (size_t) (c - h->h_name)));
+						host[min(hostlen - 1, (size_t) (c - h->h_name))] = '\0';
+						ok = 1;
 					} else {
-						const char *c;
+						strncpy (host, h->h_name, hostlen);
+						ok = 1;
+					}
+				 }
+			}
+
+			if (!ok) {
+				if (flags & NI_NAMEREQD) {
+					errno = serrno;
+					return EAI_NONAME;
+				} else {
+					const char *c;
 #ifdef __UCLIBC_HAS_IPV6__
-						if (sa->sa_family == AF_INET6) {
-							const struct sockaddr_in6 *sin6p;
+					if (sa->sa_family == AF_INET6) {
+						const struct sockaddr_in6 *sin6p;
 
-							sin6p = (const struct sockaddr_in6 *) sa;
+						sin6p = (const struct sockaddr_in6 *) sa;
 
-							c = inet_ntop (AF_INET6,
-										   (const void *) &sin6p->sin6_addr, host, hostlen);
+						c = inet_ntop (AF_INET6,
+							(const void *) &sin6p->sin6_addr, host, hostlen);
 #if 0
-							/* Does scope id need to be supported? */
-							uint32_t scopeid;
-							scopeid = sin6p->sin6_scope_id;
-							if (scopeid != 0) {
-								/* Buffer is >= IFNAMSIZ+1.  */
-								char scopebuf[IFNAMSIZ + 1];
-								char *scopeptr;
-								int ni_numericscope = 0;
-								size_t real_hostlen = __strnlen (host, hostlen);
-								size_t scopelen = 0;
-
-								scopebuf[0] = SCOPE_DELIMITER;
-								scopebuf[1] = '\0';
-								scopeptr = &scopebuf[1];
-
-								if (IN6_IS_ADDR_LINKLOCAL (&sin6p->sin6_addr)
-									|| IN6_IS_ADDR_MC_LINKLOCAL (&sin6p->sin6_addr)) {
-									if (if_indextoname (scopeid, scopeptr) == NULL)
-										++ni_numericscope;
-									else
-										scopelen = strlen (scopebuf);
-								} else {
+						/* Does scope id need to be supported? */
+						uint32_t scopeid;
+						scopeid = sin6p->sin6_scope_id;
+						if (scopeid != 0) {
+							/* Buffer is >= IFNAMSIZ+1.  */
+							char scopebuf[IFNAMSIZ + 1];
+							char *scopeptr;
+							int ni_numericscope = 0;
+							size_t real_hostlen = __strnlen (host, hostlen);
+							size_t scopelen = 0;
+
+							scopebuf[0] = SCOPE_DELIMITER;
+							scopebuf[1] = '\0';
+							scopeptr = &scopebuf[1];
+
+							if (IN6_IS_ADDR_LINKLOCAL (&sin6p->sin6_addr)
+							    || IN6_IS_ADDR_MC_LINKLOCAL (&sin6p->sin6_addr)) {
+								if (if_indextoname (scopeid, scopeptr) == NULL)
 									++ni_numericscope;
-								}
-
-								if (ni_numericscope)
-									scopelen = 1 + snprintf (scopeptr,
-															 (scopebuf
-															  + sizeof scopebuf
-															  - scopeptr),
-															 "%u", scopeid);
-
-								if (real_hostlen + scopelen + 1 > hostlen)
-									return EAI_SYSTEM;
-								memcpy (host + real_hostlen, scopebuf, scopelen + 1);
+								else
+									scopelen = strlen (scopebuf);
+							} else {
+								++ni_numericscope;
 							}
+
+							if (ni_numericscope)
+								scopelen = 1 + snprintf (scopeptr,
+									(scopebuf
+									+ sizeof scopebuf
+									- scopeptr),
+									"%u", scopeid);
+
+							if (real_hostlen + scopelen + 1 > hostlen)
+								return EAI_SYSTEM;
+							memcpy (host + real_hostlen, scopebuf, scopelen + 1);
+						}
 #endif
-						} else
+					} else
 #endif /* __UCLIBC_HAS_IPV6__ */
-							c = inet_ntop (AF_INET, (const void *)
-										   &(((const struct sockaddr_in *) sa)->sin_addr),
-										   host, hostlen);
-
-						if (c == NULL) {
-							errno = serrno;
-							return EAI_SYSTEM;
-						}
+						c = inet_ntop (AF_INET, (const void *)
+							&(((const struct sockaddr_in *) sa)->sin_addr),
+							host, hostlen);
+
+					if (c == NULL) {
+						errno = serrno;
+						return EAI_SYSTEM;
 					}
-					ok = 1;
 				}
-				break;
+				ok = 1;
+			}
+			break;
 
-			case AF_LOCAL:
-				if (!(flags & NI_NUMERICHOST)) {
-					struct utsname utsname;
-
-					if (!uname (&utsname)) {
-						strncpy (host, utsname.nodename, hostlen);
-						break;
-					};
+		case AF_LOCAL:
+			if (!(flags & NI_NUMERICHOST)) {
+				struct utsname utsname;
+
+				if (!uname (&utsname)) {
+					strncpy (host, utsname.nodename, hostlen);
+					break;
 				};
+			};
 
-				if (flags & NI_NAMEREQD) {
-					errno = serrno;
-					return EAI_NONAME;
-				}
+			if (flags & NI_NAMEREQD) {
+				errno = serrno;
+				return EAI_NONAME;
+			}
 
-				strncpy (host, "localhost", hostlen);
-				break;
+			strncpy (host, "localhost", hostlen);
+			break;
 
-			default:
-				return EAI_FAMILY;
-		}
+		default:
+			return EAI_FAMILY;
+	}
 
 	if (serv && (servlen > 0)) {
 		switch (sa->sa_family) {
-			case AF_INET:
+		case AF_INET:
 #ifdef __UCLIBC_HAS_IPV6__
-			case AF_INET6:
+		case AF_INET6:
 #endif /* __UCLIBC_HAS_IPV6__ */
-				if (!(flags & NI_NUMERICSERV)) {
-					struct servent *s;
-					s = getservbyport (((const struct sockaddr_in *) sa)->sin_port,
-									   ((flags & NI_DGRAM) ? "udp" : "tcp"));
-					if (s) {
-						strncpy (serv, s->s_name, servlen);
-						break;
-					}
+			if (!(flags & NI_NUMERICSERV)) {
+				struct servent *s;
+				s = getservbyport (((const struct sockaddr_in *) sa)->sin_port,
+				      ((flags & NI_DGRAM) ? "udp" : "tcp"));
+				if (s) {
+					strncpy (serv, s->s_name, servlen);
+					break;
 				}
-				snprintf (serv, servlen, "%d",
-						  ntohs (((const struct sockaddr_in *) sa)->sin_port));
-				break;
+			}
+			snprintf (serv, servlen, "%d",
+				ntohs (((const struct sockaddr_in *) sa)->sin_port));
+			break;
 
-			case AF_LOCAL:
-				strncpy (serv, ((const struct sockaddr_un *) sa)->sun_path, servlen);
-				break;
+		case AF_LOCAL:
+			strncpy (serv, ((const struct sockaddr_un *) sa)->sun_path, servlen);
+			break;
 		}
 	}
 	if (host && (hostlen > 0))
@@ -1917,10 +1896,10 @@
 #ifdef L_gethostbyname_r
 
 int gethostbyname_r(const char * name,
-					struct hostent * result_buf,
-					char * buf, size_t buflen,
-					struct hostent ** result,
-					int * h_errnop)
+			    struct hostent * result_buf,
+			    char * buf, size_t buflen,
+			    struct hostent ** result,
+			    int * h_errnop)
 {
 	struct in_addr *in;
 	struct in_addr **addr_list;
@@ -1942,7 +1921,7 @@
 		__set_errno(0);			/* to check for missing /etc/hosts. */
 
 		if ((i=__get_hosts_byname_r(name, AF_INET, result_buf,
-									buf, buflen, result, h_errnop))==0)
+				buf, buflen, result, h_errnop))==0)
 			return i;
 		switch (*h_errnop) {
 			case HOST_NOT_FOUND:
@@ -2004,60 +1983,60 @@
 
 	for (;;) {
 
-	    __UCLIBC_MUTEX_LOCK(__resolv_lock);
+	    BIGLOCK;
 	    __nameserversXX=__nameservers;
 	    __nameserverXX=__nameserver;
-	    __UCLIBC_MUTEX_UNLOCK(__resolv_lock);
+	    BIGUNLOCK;
 	    a.buf = buf;
 	    a.buflen = buflen;
 	    a.add_count = 0;
 	    i = __dns_lookup(name, T_A, __nameserversXX, __nameserverXX, &packet, &a);
 
 	    if (i < 0) {
-			*h_errnop = HOST_NOT_FOUND;
-			DPRINTF("__dns_lookup\n");
-			return TRY_AGAIN;
+		*h_errnop = HOST_NOT_FOUND;
+		DPRINTF("__dns_lookup\n");
+		return TRY_AGAIN;
 	    }
 
 	    if ((a.rdlength + sizeof(struct in_addr*)) * a.add_count + 256 > buflen)
-			{
-				free(a.dotted);
-				free(packet);
-				*h_errnop = NETDB_INTERNAL;
-				DPRINTF("buffer too small for all addresses\n");
-				return ERANGE;
-			}
+	    {
+		free(a.dotted);
+		free(packet);
+		*h_errnop = NETDB_INTERNAL;
+		DPRINTF("buffer too small for all addresses\n");
+		return ERANGE;
+	    }
 	    else if(a.add_count > 0)
-			{
-				memmove(buf - sizeof(struct in_addr*)*2, buf, a.add_count * a.rdlength);
-				addr_list = (struct in_addr**)(buf + a.add_count * a.rdlength);
-				addr_list[0] = in;
-				for (i = a.add_count-1; i>=0; --i)
-					addr_list[i+1] = (struct in_addr*)(buf - sizeof(struct in_addr*)*2 + a.rdlength * i);
-				addr_list[a.add_count + 1] = 0;
-				buflen -= (((char*)&(addr_list[a.add_count + 2])) - buf);
-				buf = (char*)&addr_list[a.add_count + 2];
-			}
+	    {
+		memmove(buf - sizeof(struct in_addr*)*2, buf, a.add_count * a.rdlength);
+		addr_list = (struct in_addr**)(buf + a.add_count * a.rdlength);
+		addr_list[0] = in;
+		for (i = a.add_count-1; i>=0; --i)
+		    addr_list[i+1] = (struct in_addr*)(buf - sizeof(struct in_addr*)*2 + a.rdlength * i);
+		addr_list[a.add_count + 1] = 0;
+		buflen -= (((char*)&(addr_list[a.add_count + 2])) - buf);
+		buf = (char*)&addr_list[a.add_count + 2];
+	    }
 
 	    strncpy(buf, a.dotted, buflen);
 	    free(a.dotted);
 
 	    if (a.atype == T_A) { /* ADDRESS */
-			memcpy(in, a.rdata, sizeof(*in));
-			result_buf->h_name = buf;
-			result_buf->h_addrtype = AF_INET;
-			result_buf->h_length = sizeof(*in);
-			result_buf->h_addr_list = (char **) addr_list;
+		memcpy(in, a.rdata, sizeof(*in));
+		result_buf->h_name = buf;
+		result_buf->h_addrtype = AF_INET;
+		result_buf->h_length = sizeof(*in);
+		result_buf->h_addr_list = (char **) addr_list;
 #ifdef __UCLIBC_MJN3_ONLY__
 #warning TODO -- generate the full list
 #endif
-			result_buf->h_aliases = alias; /* TODO: generate the full list */
-			free(packet);
-			break;
+		result_buf->h_aliases = alias; /* TODO: generate the full list */
+		free(packet);
+		break;
 	    } else {
-			free(packet);
-			*h_errnop=HOST_NOT_FOUND;
-			return TRY_AGAIN;
+		free(packet);
+		*h_errnop=HOST_NOT_FOUND;
+		return TRY_AGAIN;
 	    }
 	}
 
@@ -2070,14 +2049,14 @@
 #ifdef L_gethostbyname2_r
 
 int gethostbyname2_r(const char *name, int family,
-					 struct hostent * result_buf,
-					 char * buf, size_t buflen,
-					 struct hostent ** result,
-					 int * h_errnop)
+			    struct hostent * result_buf,
+			    char * buf, size_t buflen,
+			    struct hostent ** result,
+			    int * h_errnop)
 {
 #ifndef __UCLIBC_HAS_IPV6__
 	return family == (AF_INET)? gethostbyname_r(name, result_buf,
-												buf, buflen, result, h_errnop) : HOST_NOT_FOUND;
+		buf, buflen, result, h_errnop) : HOST_NOT_FOUND;
 #else /* __UCLIBC_HAS_IPV6__ */
 	struct in6_addr *in;
 	struct in6_addr **addr_list;
@@ -2104,8 +2083,8 @@
 		int old_errno = errno;	/* Save the old errno and reset errno */
 		__set_errno(0);			/* to check for missing /etc/hosts. */
 
-		if ((i=__get_hosts_byname_r(name, family, result_buf,
-									buf, buflen, result, h_errnop))==0)
+		if ((i=__get_hosts_byname_r(name, AF_INET6, result_buf,
+				buf, buflen, result, h_errnop))==0)
 			return i;
 		switch (*h_errnop) {
 			case HOST_NOT_FOUND:
@@ -2158,10 +2137,10 @@
 	memset((char *) &a, '\0', sizeof(a));
 
 	for (;;) {
-		__UCLIBC_MUTEX_LOCK(__resolv_lock);
-		__nameserversXX=__nameservers;
-		__nameserverXX=__nameserver;
-		__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
+	BIGLOCK;
+	__nameserversXX=__nameservers;
+	__nameserverXX=__nameserver;
+	BIGUNLOCK;
 
 		i = __dns_lookup(buf, T_AAAA, __nameserversXX, __nameserverXX, &packet, &a);
 
@@ -2211,10 +2190,10 @@
 
 #ifdef L_gethostbyaddr_r
 int gethostbyaddr_r (const void *addr, socklen_t len, int type,
-					 struct hostent * result_buf,
-					 char * buf, size_t buflen,
-					 struct hostent ** result,
-					 int * h_errnop)
+			    struct hostent * result_buf,
+			    char * buf, size_t buflen,
+			    struct hostent ** result,
+			    int * h_errnop)
 
 {
 	struct in_addr *in;
@@ -2225,7 +2204,6 @@
 	struct in6_addr	*in6;
 	struct in6_addr	**addr_list6;
 #endif /* __UCLIBC_HAS_IPV6__ */
-	char **alias;
 	unsigned char *packet;
 	struct resolv_answer a;
 	int i;
@@ -2256,7 +2234,7 @@
 
 	/* do /etc/hosts first */
 	if ((i=__get_hosts_byaddr_r(addr, len, type, result_buf,
-								buf, buflen, result, h_errnop))==0)
+				  buf, buflen, result, h_errnop))==0)
 		return i;
 	switch (*h_errnop) {
 		case HOST_NOT_FOUND:
@@ -2286,12 +2264,6 @@
 	buf+=sizeof(*addr_list)*2;
 	buflen-=sizeof(*addr_list)*2;
 
-	if (buflen < sizeof(char *)*(ALIAS_DIM))
-		return ERANGE;
-	alias=(char **)buf;
-	buf+=sizeof(*alias)*(ALIAS_DIM);
-	buflen-=sizeof(*alias)*(ALIAS_DIM);
-
 #ifdef __UCLIBC_HAS_IPV6__
 	if (plen < sizeof(*in6))
 		return ERANGE;
@@ -2322,7 +2294,7 @@
 		addr_list[0] = in;
 
 		sprintf(buf, "%u.%u.%u.%u.in-addr.arpa",
-				tmp_addr[3], tmp_addr[2], tmp_addr[1], tmp_addr[0]);
+			tmp_addr[3], tmp_addr[2], tmp_addr[1], tmp_addr[0]);
 #ifdef __UCLIBC_HAS_IPV6__
 	} else {
 		memcpy(in6->s6_addr, addr, len);
@@ -2332,7 +2304,7 @@
 
 		for (i = len - 1; i >= 0; i--) {
 			qp += sprintf(qp, "%x.%x.", in6->s6_addr[i] & 0xf,
-						  (in6->s6_addr[i] >> 4) & 0xf);
+				(in6->s6_addr[i] >> 4) & 0xf);
     	}
     	strcpy(qp, "ip6.int");
 #endif /* __UCLIBC_HAS_IPV6__ */
@@ -2340,15 +2312,12 @@
 
 	addr_list[1] = 0;
 
-	alias[0] = buf;
-	alias[1] = 0;
-
 	for (;;) {
 
-		__UCLIBC_MUTEX_LOCK(__resolv_lock);
-		__nameserversXX=__nameservers;
-		__nameserverXX=__nameserver;
-		__UCLIBC_MUTEX_UNLOCK(__resolv_lock);
+	BIGLOCK;
+	__nameserversXX=__nameservers;
+	__nameserverXX=__nameserver;
+	BIGUNLOCK;
 		i = __dns_lookup(buf, T_PTR, __nameserversXX, __nameserverXX, &packet, &a);
 
 		if (i < 0) {
@@ -2389,7 +2358,6 @@
     		}
 
 			result_buf->h_addr_list = (char **) addr_list;
-			result_buf->h_aliases = alias;
 			break;
 		} else {
 			free(packet);
@@ -2413,7 +2381,7 @@
  * Return size of compressed name or -1 if there was an error.
  */
 int __dn_expand(const u_char *msg, const u_char *eom, const u_char *src,
-				char *dst, int dstsiz)
+          char *dst, int dstsiz)
 {
 	int n = ns_name_uncompress(msg, eom, src, dst, (size_t)dstsiz);
 
@@ -2433,7 +2401,7 @@
  */
 static int printable(int ch)
 {
-	return (ch > 0x20 && ch < 0x7f);
+        return (ch > 0x20 && ch < 0x7f);
 }
 
 /*
@@ -2445,18 +2413,18 @@
  */
 static int special(int ch)
 {
-	switch (ch) {
+        switch (ch) {
         case 0x22: /* '"' */
         case 0x2E: /* '.' */
         case 0x3B: /* ';' */
         case 0x5C: /* '\\' */
-			/* Special modifiers in zone files. */
+        /* Special modifiers in zone files. */
         case 0x40: /* '@' */
         case 0x24: /* '$' */
-			return (1);
+                return (1);
         default:
-			return (0);
-	}
+                return (0);
+        }
 }
 
 /*
@@ -2468,7 +2436,7 @@
  *      Root domain returns as "." not "".
  */
 int __ns_name_uncompress(const u_char *msg, const u_char *eom,
-						 const u_char *src, char *dst, size_t dstsiz)
+		const u_char *src, char *dst, size_t dstsiz)
 {
 	u_char tmp[NS_MAXCDNAME];
 	int n;
@@ -2557,7 +2525,7 @@
 		return (-1);
 	}
 	*dn++ = '\0';
-	return (dn - dst);
+        return (dn - dst);
 }
 
 /*
@@ -2567,7 +2535,7 @@
  *      -1 if it fails, or consumed octets if it succeeds.
  */
 int __ns_name_unpack(const u_char *msg, const u_char *eom, const u_char *src,
-					 u_char *dst, size_t dstsiz)
+               u_char *dst, size_t dstsiz)
 {
 	const u_char *srcp, *dstlim;
 	u_char *dstp;
@@ -2586,46 +2554,46 @@
 	while ((n = *srcp++) != 0) {
 		/* Check for indirection. */
 		switch (n & NS_CMPRSFLGS) {
-			case 0:
-				/* Limit checks. */
-				if (dstp + n + 1 >= dstlim || srcp + n >= eom) {
-					__set_errno (EMSGSIZE);
-					return (-1);
-				}
-				checked += n + 1;
-				*dstp++ = n;
-				memcpy(dstp, srcp, n);
-				dstp += n;
-				srcp += n;
-				break;
-
-			case NS_CMPRSFLGS:
-				if (srcp >= eom) {
-					__set_errno (EMSGSIZE);
-					return (-1);
-				}
-				if (len < 0)
-					len = srcp - src + 1;
-				srcp = msg + (((n & 0x3f) << 8) | (*srcp & 0xff));
-				if (srcp < msg || srcp >= eom) {  /* Out of range. */
-					__set_errno (EMSGSIZE);
-					return (-1);
-				}
-				checked += 2;
-				/*
-				 * Check for loops in the compressed name;
-				 * if we've looked at the whole message,
-				 * there must be a loop.
-				 */
-				if (checked >= eom - msg) {
-					__set_errno (EMSGSIZE);
-					return (-1);
-				}
-				break;
+		case 0:
+			/* Limit checks. */
+			if (dstp + n + 1 >= dstlim || srcp + n >= eom) {
+				__set_errno (EMSGSIZE);
+				return (-1);
+			}
+			checked += n + 1;
+			*dstp++ = n;
+			memcpy(dstp, srcp, n);
+			dstp += n;
+			srcp += n;
+			break;
 
-			default:
+		case NS_CMPRSFLGS:
+			if (srcp >= eom) {
+				__set_errno (EMSGSIZE);
+				return (-1);
+			}
+			if (len < 0)
+				len = srcp - src + 1;
+			srcp = msg + (((n & 0x3f) << 8) | (*srcp & 0xff));
+			if (srcp < msg || srcp >= eom) {  /* Out of range. */
+				__set_errno (EMSGSIZE);
+				return (-1);
+			}
+			checked += 2;
+			/*
+			 * Check for loops in the compressed name;
+			 * if we've looked at the whole message,
+			 * there must be a loop.
+			 */
+			if (checked >= eom - msg) {
 				__set_errno (EMSGSIZE);
-				return (-1);                    /* flag error */
+				return (-1);
+			}
+			break;
+
+		default:
+			__set_errno (EMSGSIZE);
+			return (-1);                    /* flag error */
 		}
 	}
 	*dstp = '\0';
diff -urN a/libc/inet/rpc/create_xid.c b/libc/inet/rpc/create_xid.c
--- a/libc/inet/rpc/create_xid.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/inet/rpc/create_xid.c	2012-04-10 13:55:23.000000000 +0800
@@ -35,22 +35,22 @@
 unsigned long
 _create_xid (void)
 {
-	unsigned long res;
+  unsigned long res;
 
 	__UCLIBC_MUTEX_LOCK(mylock);
 
-	if (!is_initialized)
-		{
-			struct timeval now;
-
-			gettimeofday (&now, (struct timezone *) 0);
-			srand48_r (now.tv_sec ^ now.tv_usec, &__rpc_lrand48_data);
-			is_initialized = 1;
-		}
+  if (!is_initialized)
+    {
+      struct timeval now;
+
+      gettimeofday (&now, (struct timezone *) 0);
+      srand48_r (now.tv_sec ^ now.tv_usec, &__rpc_lrand48_data);
+      is_initialized = 1;
+    }
 
-	lrand48_r (&__rpc_lrand48_data, &res);
+  lrand48_r (&__rpc_lrand48_data, &res);
 
 	__UCLIBC_MUTEX_UNLOCK(mylock);
 
-	return res;
+  return res;
 }
diff -urN a/libc/inet/rpc/.indent.pro b/libc/inet/rpc/.indent.pro
--- a/libc/inet/rpc/.indent.pro	2000-10-10 04:07:06.000000000 +0800
+++ b/libc/inet/rpc/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/inet/rpc/Makefile b/libc/inet/rpc/Makefile
--- a/libc/inet/rpc/Makefile	2005-01-25 10:17:00.000000000 +0700
+++ b/libc/inet/rpc/Makefile	2012-04-10 13:55:23.000000000 +0800
@@ -43,9 +43,10 @@
 	clnt_tcp.c clnt_udp.c bindresvport.c authunix_prot.c \
 	auth_none.c auth_unix.c xdr.c xdr_array.c xdr_rec.c \
 	xdr_reference.c xdr_mem.c svc.c svc_auth.c svc_auth_unix.c \
+	svc_simple.c svc_tcp.c svc_udp.c \
 	rpc_callmsg.c rpc_prot.c rpc_dtablesize.c rpc_commondata.c \
 	rpc_thread.c rcmd.c rexec.c sa_len.c ruserpass.c rtime.c \
-	getrpcent.c
+	getrpcent.c get_myaddress.c clnt_generic.c
 endif
 COBJS=$(patsubst %.c,%.o, $(CSRC))
 OBJS=$(COBJS)
diff -urN a/libc/Makefile b/libc/Makefile
--- a/libc/Makefile	2007-03-01 04:23:09.000000000 +0700
+++ b/libc/Makefile	2012-04-10 13:55:23.000000000 +0800
@@ -59,7 +59,7 @@
 	$(AR) dN 2 $(LIBNAME) $$objs && \
 	$(AR) dN 2 $(LIBNAME) $$objs
 	@for objfile in obj.signal \
-	                obj.string.generic obj.string.$(TARGET_ARCH) obj.string \
+	                obj.string obj.string.generic obj.string.$(TARGET_ARCH) \
 	                obj.sysdeps.common obj.sysdeps.$(TARGET_ARCH) ; do \
 		if [ -e $$objfile ] ; then \
 			if [ "$(MAKE_IS_SILENT)" = "n" ] ; then \
diff -urN a/libc/misc/assert/.indent.pro b/libc/misc/assert/.indent.pro
--- a/libc/misc/assert/.indent.pro	2000-10-12 06:08:28.000000000 +0800
+++ b/libc/misc/assert/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/misc/ctype/.indent.pro b/libc/misc/ctype/.indent.pro
--- a/libc/misc/ctype/.indent.pro	2000-10-12 06:08:28.000000000 +0800
+++ b/libc/misc/ctype/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/misc/dirent/readdir64_r.c b/libc/misc/dirent/readdir64_r.c
--- a/libc/misc/dirent/readdir64_r.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/misc/dirent/readdir64_r.c	2012-09-07 02:23:48.000000000 +0800
@@ -35,15 +35,15 @@
 
 	do {
 	    if (dir->dd_size <= dir->dd_nextloc) {
-			/* read dir->dd_max bytes of directory entries. */
-			bytes = __getdents64(dir->dd_fd, dir->dd_buf, dir->dd_max);
-			if (bytes <= 0) {
-				*result = NULL;
-				ret = errno;
-				goto all_done;
-			}
-			dir->dd_size = bytes;
-			dir->dd_nextloc = 0;
+		/* read dir->dd_max bytes of directory entries. */
+		bytes = __getdents64(dir->dd_fd, dir->dd_buf, dir->dd_max);
+		if (bytes <= 0) {
+		    *result = NULL;
+		    ret = (bytes==0)? 0 : errno;
+		    goto all_done;
+		}
+		dir->dd_size = bytes;
+		dir->dd_nextloc = 0;
 	    }
 
 	    de = (struct dirent64 *) (((char *) dir->dd_buf) + dir->dd_nextloc);
@@ -63,10 +63,10 @@
 	}
 	ret = 0;
 
- all_done:
+all_done:
 
 	__UCLIBC_MUTEX_UNLOCK(dir->dd_lock);
-	return((de != NULL)? 0 : ret);
+        return((de != NULL)? 0 : ret);
 }
 #endif /* __UCLIBC_HAS_LFS__ */
 
diff -urN a/libc/misc/dirent/readdir_r.c b/libc/misc/dirent/readdir_r.c
--- a/libc/misc/dirent/readdir_r.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/misc/dirent/readdir_r.c	2012-09-07 02:22:55.000000000 +0800
@@ -21,15 +21,15 @@
 
 	do {
 	    if (dir->dd_size <= dir->dd_nextloc) {
-			/* read dir->dd_max bytes of directory entries. */
-			bytes = __getdents(dir->dd_fd, dir->dd_buf, dir->dd_max);
-			if (bytes <= 0) {
-				*result = NULL;
-				ret = errno;
-				goto all_done;
-			}
-			dir->dd_size = bytes;
-			dir->dd_nextloc = 0;
+		/* read dir->dd_max bytes of directory entries. */
+		bytes = __getdents(dir->dd_fd, dir->dd_buf, dir->dd_max);
+		if (bytes <= 0) {
+		    *result = NULL;
+		    ret = (bytes==0)? 0 : errno;
+		    goto all_done;
+		}
+		dir->dd_size = bytes;
+		dir->dd_nextloc = 0;
 	    }
 
 	    de = (struct dirent *) (((char *) dir->dd_buf) + dir->dd_nextloc);
@@ -49,8 +49,8 @@
 	}
 	ret = 0;
 
- all_done:
+all_done:
 
 	__UCLIBC_MUTEX_UNLOCK(dir->dd_lock);
-	return((de != NULL)? 0 : ret);
+        return((de != NULL)? 0 : ret);
 }
diff -urN a/libc/misc/fnmatch/.indent.pro b/libc/misc/fnmatch/.indent.pro
--- a/libc/misc/fnmatch/.indent.pro	2000-10-12 06:08:28.000000000 +0800
+++ b/libc/misc/fnmatch/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/misc/glob/.indent.pro b/libc/misc/glob/.indent.pro
--- a/libc/misc/glob/.indent.pro	2000-10-12 06:08:28.000000000 +0800
+++ b/libc/misc/glob/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/misc/internals/tempname.c b/libc/misc/internals/tempname.c
--- a/libc/misc/internals/tempname.c	2005-04-16 11:59:42.000000000 +0800
+++ b/libc/misc/internals/tempname.c	2012-04-10 13:55:23.000000000 +0800
@@ -128,7 +128,7 @@
     unsigned int result = -1;
     fd = open("/dev/urandom", O_RDONLY);
     if (fd < 0) {
-	fd = open("/dev/random", O_RDONLY | O_NONBLOCK);
+	fd = open("/dev/urandom", O_RDONLY | O_NONBLOCK);
     }
     if (fd >= 0) {
 	result = read(fd, buf, len);
diff -urN a/libc/misc/mntent/.indent.pro b/libc/misc/mntent/.indent.pro
--- a/libc/misc/mntent/.indent.pro	2000-10-26 15:12:49.000000000 +0800
+++ b/libc/misc/mntent/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/misc/regex/.indent.pro b/libc/misc/regex/.indent.pro
--- a/libc/misc/regex/.indent.pro	2000-10-10 04:06:30.000000000 +0800
+++ b/libc/misc/regex/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/misc/syslog/syslog.c b/libc/misc/syslog/syslog.c
--- a/libc/misc/syslog/syslog.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/misc/syslog/syslog.c	2012-04-10 13:55:23.000000000 +0800
@@ -109,19 +109,19 @@
 	LogFile = -1;
 	connected = 0;
 	if (to_default)
-		{
-			LogStat = 0;
-			LogTag = "syslog";
-			LogFacility = LOG_USER;
-			LogMask = 0xff;
-		}
+	{
+		LogStat = 0;
+		LogTag = "syslog";
+		LogFacility = LOG_USER;
+		LogMask = 0xff;
+	}
 	__UCLIBC_MUTEX_UNLOCK(mylock);
 }
 
 static void
 sigpipe_handler (int sig)
 {
-	closelog_intern (0);
+  closelog_intern (0);
 }
 
 /*
@@ -200,7 +200,7 @@
 	if (p >= end || p < head_end) {	/* Returned -1 in case of error... */
 		static const char truncate_msg[12] = "[truncated] ";
 		memmove(head_end + sizeof(truncate_msg), head_end,
-				end - head_end - sizeof(truncate_msg));
+			end - head_end - sizeof(truncate_msg));
 		memcpy(head_end, truncate_msg, sizeof(truncate_msg));
 		if (p < head_end) {
 			while (p < end && *p) {
@@ -253,11 +253,11 @@
 		(void)close(fd);
 	}
 
- getout:
+getout:
 	__UCLIBC_MUTEX_UNLOCK(mylock);
 	if (sigpipe == 0)
 		sigaction (SIGPIPE, &oldaction,
-				   (struct sigaction *) NULL);
+			(struct sigaction *) NULL);
 }
 
 /*
@@ -271,41 +271,41 @@
     __UCLIBC_MUTEX_LOCK(mylock);
 
     if (ident != NULL)
-		LogTag = ident;
+	LogTag = ident;
     LogStat = logstat;
     if (logfac != 0 && (logfac &~ LOG_FACMASK) == 0)
-		LogFacility = logfac;
+	LogFacility = logfac;
     if (LogFile == -1) {
-		SyslogAddr.sa_family = AF_UNIX;
-		(void)strncpy(SyslogAddr.sa_data, _PATH_LOG,
-					  sizeof(SyslogAddr.sa_data));
-	retry:
-		if (LogStat & LOG_NDELAY) {
-			if ((LogFile = socket(AF_UNIX, logType, 0)) == -1){
+	SyslogAddr.sa_family = AF_UNIX;
+	(void)strncpy(SyslogAddr.sa_data, _PATH_LOG,
+		      sizeof(SyslogAddr.sa_data));
+retry:
+	if (LogStat & LOG_NDELAY) {
+	    if ((LogFile = socket(AF_UNIX, logType, 0)) == -1){
 				goto DONE;
-			}
-			/*			fcntl(LogFile, F_SETFD, 1); */
-		}
+	    }
+	    /*			fcntl(LogFile, F_SETFD, 1); */
+	}
     }
 
     if (LogFile != -1 && !connected) {
-		if (connect(LogFile, &SyslogAddr, sizeof(SyslogAddr) - 
-					sizeof(SyslogAddr.sa_data) + strlen(SyslogAddr.sa_data)) != -1)
-			{
-				connected = 1;
-			} else if (logType == SOCK_DGRAM) {
-				logType = SOCK_STREAM;
-				if (LogFile != -1) {
-					close(LogFile);
-					LogFile = -1;
-				}
-				goto retry;
-			} else {
-				if (LogFile != -1) {
-					close(LogFile);
-					LogFile = -1;
-				}
-			}
+	if (connect(LogFile, &SyslogAddr, sizeof(SyslogAddr) - 
+		    sizeof(SyslogAddr.sa_data) + strlen(SyslogAddr.sa_data)) != -1)
+	{
+	    connected = 1;
+	} else if (logType == SOCK_DGRAM) {
+	    logType = SOCK_STREAM;
+	    if (LogFile != -1) {
+		close(LogFile);
+		LogFile = -1;
+	    }
+	    goto retry;
+	} else {
+	    if (LogFile != -1) {
+		close(LogFile);
+		LogFile = -1;
+	    }
+	}
     }
 
  DONE:
@@ -329,7 +329,7 @@
     omask = LogMask;
     __UCLIBC_MUTEX_LOCK(mylock);
     if (pmask != 0)
-		LogMask = pmask;
+	LogMask = pmask;
     __UCLIBC_MUTEX_UNLOCK(mylock);
     return (omask);
 }
diff -urN a/libc/misc/sysvipc/.indent.pro b/libc/misc/sysvipc/.indent.pro
--- a/libc/misc/sysvipc/.indent.pro	2001-03-20 04:51:29.000000000 +0700
+++ b/libc/misc/sysvipc/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/misc/time/.indent.pro b/libc/misc/time/.indent.pro
--- a/libc/misc/time/.indent.pro	2000-10-10 04:06:30.000000000 +0800
+++ b/libc/misc/time/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/misc/time/time.c b/libc/misc/time/time.c
--- a/libc/misc/time/time.c	2007-01-30 04:37:48.000000000 +0700
+++ b/libc/misc/time/time.c	2012-09-07 06:17:57.000000000 +0800
@@ -459,6 +459,7 @@
 char *ctime_r(const time_t *clock, char *buf)
 {
 	struct tm xtm;
+	memset(&xtm, 0, sizeof(xtm));
 
 	return asctime_r(localtime_r(clock, &xtm), buf);
 }
@@ -648,7 +649,7 @@
 					++day;
 				}
 				monlen = 31 + day_cor[r->month -1] - day_cor[r->month];
-				if (isleap && (r->month > 1)) {
+				if (isleap && (r->month == 2)) {
 					++monlen;
 				}
 				/* Wweekday (0 is Sunday) of 1st of the month
diff -urN a/libc/misc/ttyent/getttyent.c b/libc/misc/ttyent/getttyent.c
--- a/libc/misc/ttyent/getttyent.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/misc/ttyent/getttyent.c	2012-04-10 13:55:23.000000000 +0800
@@ -47,8 +47,8 @@
 
     setttyent();
     while ((t = getttyent()))
-		if (!strcmp(tty, t->ty_name))
-			break;
+	if (!strcmp(tty, t->ty_name))
+	    break;
     endttyent();
     return (t);
 }
@@ -64,27 +64,27 @@
     register int c, q;
 
     for (q = 0, t = p; (c = *p) != '\0'; p++) {
-		if (c == '"') {
-			q ^= QUOTED;	/* obscure, but nice */
-			continue;
-		}
-		if (q == QUOTED && *p == '\\' && *(p+1) == '"')
-			p++;
-		*t++ = *p;
-		if (q == QUOTED)
-			continue;
-		if (c == '#') {
-			zapchar = c;
-			*p = 0;
-			break;
-		}
-		if (c == '\t' || c == ' ' || c == '\n') {
-			zapchar = c;
-			*p++ = 0;
-			while ((c = *p) == '\t' || c == ' ' || c == '\n')
-				p++;
-			break;
-		}
+	if (c == '"') {
+	    q ^= QUOTED;	/* obscure, but nice */
+	    continue;
+	}
+	if (q == QUOTED && *p == '\\' && *(p+1) == '"')
+	    p++;
+	*t++ = *p;
+	if (q == QUOTED)
+	    continue;
+	if (c == '#') {
+	    zapchar = c;
+	    *p = 0;
+	    break;
+	}
+	if (c == '\t' || c == ' ' || c == '\n') {
+	    zapchar = c;
+	    *p++ = 0;
+	    while ((c = *p) == '\t' || c == ' ' || c == '\n')
+		p++;
+	    break;
+	}
     }
     *--t = '\0';
     return (p);
@@ -104,43 +104,43 @@
     struct ttyent *retval = NULL;
 
     if (!tf && !setttyent())
-		return (NULL);
+	return (NULL);
 
     if (!line) {
-		line = malloc(BUFSIZ);
+            line = malloc(BUFSIZ);
 		if (!line)
 		    abort();
     }
 
-    __STDIO_ALWAYS_THREADLOCK(tf);
+	__STDIO_ALWAYS_THREADLOCK(tf);
 
     for (;;) {
-		if (!fgets_unlocked(p = line, BUFSIZ, tf)) {
+	if (!fgets_unlocked(p = line, BUFSIZ, tf)) {
 			goto DONE;
-		}
-		/* skip lines that are too big */
-		if (!index(p, '\n')) {
-			while ((c = getc_unlocked(tf)) != '\n' && c != EOF)
-				;
-			continue;
-		}
-		while (isspace(*p))
-			++p;
-		if (*p && *p != '#')
-			break;
+	}
+	/* skip lines that are too big */
+	if (!index(p, '\n')) {
+	    while ((c = getc_unlocked(tf)) != '\n' && c != EOF)
+		;
+	    continue;
+	}
+	while (isspace(*p))
+	    ++p;
+	if (*p && *p != '#')
+	    break;
     }
 
     zapchar = 0;
     tty.ty_name = p;
     p = skip(p);
     if (!*(tty.ty_getty = p))
-		tty.ty_getty = tty.ty_type = NULL;
+	tty.ty_getty = tty.ty_type = NULL;
     else {
-		p = skip(p);
-		if (!*(tty.ty_type = p))
-			tty.ty_type = NULL;
-		else
-			p = skip(p);
+	p = skip(p);
+	if (!*(tty.ty_type = p))
+	    tty.ty_type = NULL;
+	else
+	    p = skip(p);
     }
     tty.ty_status = 0;
     tty.ty_window = NULL;
@@ -148,26 +148,26 @@
 #define	scmp(e)	!strncmp(p, e, sizeof(e) - 1) && isspace(p[sizeof(e) - 1])
 #define	vcmp(e)	!strncmp(p, e, sizeof(e) - 1) && p[sizeof(e) - 1] == '='
     for (; *p; p = skip(p)) {
-		if (scmp(_TTYS_OFF))
-			tty.ty_status &= ~TTY_ON;
-		else if (scmp(_TTYS_ON))
-			tty.ty_status |= TTY_ON;
-		else if (scmp(_TTYS_SECURE))
-			tty.ty_status |= TTY_SECURE;
-		else if (vcmp(_TTYS_WINDOW))
-			tty.ty_window = value(p);
-		else
-			break;
+	if (scmp(_TTYS_OFF))
+	    tty.ty_status &= ~TTY_ON;
+	else if (scmp(_TTYS_ON))
+	    tty.ty_status |= TTY_ON;
+	else if (scmp(_TTYS_SECURE))
+	    tty.ty_status |= TTY_SECURE;
+	else if (vcmp(_TTYS_WINDOW))
+	    tty.ty_window = value(p);
+	else
+	    break;
     }
 
     if (zapchar == '#' || *p == '#')
-		while ((c = *++p) == ' ' || c == '\t')
-			;
+	while ((c = *++p) == ' ' || c == '\t')
+	    ;
     tty.ty_comment = p;
     if (*p == 0)
-		tty.ty_comment = 0;
+	tty.ty_comment = 0;
     if ((p = index(p, '\n')))
-		*p = '\0';
+	*p = '\0';
     retval = &tty;
 
  DONE:
@@ -179,14 +179,14 @@
 {
 
     if (tf) {
-		rewind(tf);
-		return (1);
+	rewind(tf);
+	return (1);
     } else if ((tf = fopen(_PATH_TTYS, "r"))) {
-		/* We do the locking ourselves.  */
+	/* We do the locking ourselves.  */
 #ifdef __UCLIBC_HAS_THREADS__
-		__fsetlocking (tf, FSETLOCKING_BYCALLER);
+	__fsetlocking (tf, FSETLOCKING_BYCALLER);
 #endif
-		return (1);
+	return (1);
     }
     return (0);
 }
@@ -196,9 +196,9 @@
     int rval;
 
     if (tf) {
-		rval = !(fclose(tf) == EOF);
-		tf = NULL;
-		return (rval);
+	rval = !(fclose(tf) == EOF);
+	tf = NULL;
+	return (rval);
     }
     return (1);
 }
diff -urN a/libc/misc/utmp/utent.c b/libc/misc/utmp/utent.c
--- a/libc/misc/utmp/utent.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/misc/utmp/utent.c	2012-04-10 13:55:23.000000000 +0800
@@ -36,17 +36,17 @@
 
 {
     if (utmp_fd == -1) {
-		setutent();
+	setutent();
     }
     if (utmp_fd == -1) {
-		return NULL;
+	return NULL;
     }
 
     __UCLIBC_MUTEX_LOCK(utmplock);
     if (read(utmp_fd, (char *) &static_utmp, sizeof(struct utmp)) != sizeof(struct utmp)) 
-		{
-			return NULL;
-		}
+    {
+	return NULL;
+    }
 
     __UCLIBC_MUTEX_UNLOCK(utmplock);
     return &static_utmp;
@@ -58,22 +58,22 @@
 
     __UCLIBC_MUTEX_LOCK(utmplock);
     if (static_fd == -1) {
-		if ((static_fd = open(static_ut_name, O_RDWR)) < 0) {
-			if ((static_fd = open(static_ut_name, O_RDONLY)) < 0) {
-				goto bummer;
-			}
-		}
-		/* Make sure the file will be closed on exec()  */
-		ret = fcntl(static_fd, F_GETFD, 0);
-		if (ret >= 0) {
-			ret = fcntl(static_fd, F_GETFD, 0);
-		}
-		if (ret < 0) {
-		bummer:
-			close(static_fd);
+	if ((static_fd = open(static_ut_name, O_RDWR)) < 0) {
+	    if ((static_fd = open(static_ut_name, O_RDONLY)) < 0) {
+		goto bummer;
+	    }
+	}
+	/* Make sure the file will be closed on exec()  */
+	ret = fcntl(static_fd, F_GETFD, 0);
+	if (ret >= 0) {
+	    ret = fcntl(static_fd, F_GETFD, 0);
+	}
+	if (ret < 0) {
+bummer:
+	    close(static_fd);
 			static_fd = -1;
 			goto DONE;
-		}
+	}
     }
     lseek(static_fd, 0, SEEK_SET);
  DONE:
@@ -85,7 +85,7 @@
 {
     __UCLIBC_MUTEX_LOCK(utmplock);
     if (static_fd != -1) {
-		close(static_fd);
+	close(static_fd);
     }
     static_fd = -1;
     __UCLIBC_MUTEX_UNLOCK(utmplock);
@@ -103,22 +103,22 @@
     struct utmp *lutmp;
 
     while ((lutmp = __getutent(static_fd)) != NULL) {
-		if (	(utmp_entry->ut_type == RUN_LVL ||
-				 utmp_entry->ut_type == BOOT_TIME ||
-				 utmp_entry->ut_type == NEW_TIME ||
-				 utmp_entry->ut_type == OLD_TIME) &&
-				lutmp->ut_type == utmp_entry->ut_type)  
-			{
-				return lutmp;
-			}
-		if (	(utmp_entry->ut_type == INIT_PROCESS ||
-				 utmp_entry->ut_type == DEAD_PROCESS ||
-				 utmp_entry->ut_type == LOGIN_PROCESS ||
-				 utmp_entry->ut_type == USER_PROCESS) &&
-				!strncmp(lutmp->ut_id, utmp_entry->ut_id, sizeof(lutmp->ut_id))) 
-			{
-				return lutmp;
-			}
+	if (	(utmp_entry->ut_type == RUN_LVL ||
+		 utmp_entry->ut_type == BOOT_TIME ||
+		 utmp_entry->ut_type == NEW_TIME ||
+		 utmp_entry->ut_type == OLD_TIME) &&
+		lutmp->ut_type == utmp_entry->ut_type)  
+	{
+	    return lutmp;
+	}
+	if (	(utmp_entry->ut_type == INIT_PROCESS ||
+		 utmp_entry->ut_type == DEAD_PROCESS ||
+		 utmp_entry->ut_type == LOGIN_PROCESS ||
+		 utmp_entry->ut_type == USER_PROCESS) &&
+		!strncmp(lutmp->ut_id, utmp_entry->ut_id, sizeof(lutmp->ut_id))) 
+	{
+	    return lutmp;
+	}
     }
 
     return NULL;
@@ -130,11 +130,11 @@
     struct utmp *lutmp;
 
     while ((lutmp = __getutent(static_fd)) != NULL) {
-		if ((lutmp->ut_type == USER_PROCESS || lutmp->ut_type == LOGIN_PROCESS) &&
-			!strcmp(lutmp->ut_line, utmp_entry->ut_line))
-			{
-				return lutmp;
-			}
+	if ((lutmp->ut_type == USER_PROCESS || lutmp->ut_type == LOGIN_PROCESS) &&
+		!strcmp(lutmp->ut_line, utmp_entry->ut_line))
+	{
+	    return lutmp;
+	}
     }
 
     return NULL;
@@ -148,13 +148,13 @@
     lseek(static_fd, (off_t) - sizeof(struct utmp), SEEK_CUR);
 
     if (getutid(utmp_entry) != NULL) {
-		lseek(static_fd, (off_t) - sizeof(struct utmp), SEEK_CUR);
-		if (write(static_fd, utmp_entry, sizeof(struct utmp)) != sizeof(struct utmp))
-			return NULL;
+	lseek(static_fd, (off_t) - sizeof(struct utmp), SEEK_CUR);
+	if (write(static_fd, utmp_entry, sizeof(struct utmp)) != sizeof(struct utmp))
+	    return NULL;
     } else {
-		lseek(static_fd, (off_t) 0, SEEK_END);
-		if (write(static_fd, utmp_entry, sizeof(struct utmp)) != sizeof(struct utmp))
-			return NULL;
+	lseek(static_fd, (off_t) 0, SEEK_END);
+	if (write(static_fd, utmp_entry, sizeof(struct utmp)) != sizeof(struct utmp))
+	    return NULL;
     }
 
     __UCLIBC_MUTEX_UNLOCK(utmplock);
@@ -165,18 +165,18 @@
 {
     __UCLIBC_MUTEX_LOCK(utmplock);
     if (new_ut_name != NULL) {
-		if (static_ut_name != default_file_name)
-			free((char *)static_ut_name);
-		static_ut_name = strdup(new_ut_name);
-		if (static_ut_name == NULL) {
-			/* We should probably whine about out-of-memory 
-			 * errors here...  Instead just reset to the default */
-			static_ut_name = default_file_name;
-		}
+	if (static_ut_name != default_file_name)
+	    free((char *)static_ut_name);
+	static_ut_name = strdup(new_ut_name);
+	if (static_ut_name == NULL) {
+	    /* We should probably whine about out-of-memory 
+	     * errors here...  Instead just reset to the default */
+	    static_ut_name = default_file_name;
+	}
     }
 
     if (static_fd != -1)
-		close(static_fd);
+	close(static_fd);
     __UCLIBC_MUTEX_UNLOCK(utmplock);
     return 0;
 }
diff -urN a/libc/misc/wctype/wctype.c b/libc/misc/wctype/wctype.c
--- a/libc/misc/wctype/wctype.c	2003-09-09 12:15:27.000000000 +0800
+++ b/libc/misc/wctype/wctype.c	2012-04-10 13:55:23.000000000 +0800
@@ -880,10 +880,10 @@
 	const unsigned char *p;
 	int i;
 
-	p = transstring;
+	p = (const unsigned char *) transstring;
 	i = 1;
 	do {
-		if (!strcmp(property, ++p)) {
+		if (!strcmp(property, (const char*) ++p)) {
 			return i;
 		}
 		++i;
diff -urN a/libc/pwd_grp/.indent.pro b/libc/pwd_grp/.indent.pro
--- a/libc/pwd_grp/.indent.pro	2000-10-08 07:46:22.000000000 +0800
+++ b/libc/pwd_grp/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/stdio/fcloseall.c b/libc/stdio/fcloseall.c
--- a/libc/stdio/fcloseall.c	2007-02-22 06:28:41.000000000 +0700
+++ b/libc/stdio/fcloseall.c	2012-04-10 13:55:23.000000000 +0800
@@ -46,9 +46,9 @@
 		    != (__FLAG_READONLY|__FLAG_WRITEONLY)
 		    ) {
 			if (fclose(f)) {
-				retval = EOF;
-			}
+			retval = EOF;
 		}
+	}
 		__STDIO_AUTO_THREADUNLOCK(f);
 
 		f = n;
diff -urN a/libc/stdio/fflush.c b/libc/stdio/fflush.c
--- a/libc/stdio/fflush.c	2007-02-22 06:28:41.000000000 +0700
+++ b/libc/stdio/fflush.c	2012-04-10 13:55:23.000000000 +0800
@@ -109,17 +109,17 @@
 			if (__STDIO_STREAM_IS_WRITING(stream)) { /* ONLY IF ATOMIC!!! */
 				__MY_STDIO_THREADLOCK(stream);
 				/* Need to check again once we have the lock. */
-				if (!(((stream->__modeflags | bufmask)
-					   ^ (__FLAG_WRITING|__FLAG_LBF)
-					   ) & (__FLAG_WRITING|__MASK_BUFMODE))
-					) {
-					if (!__STDIO_COMMIT_WRITE_BUFFER(stream)) {
-						__STDIO_STREAM_DISABLE_PUTC(stream);
-						__STDIO_STREAM_CLEAR_WRITING(stream);
-					} else {
-						retval = EOF;
-					}
+			if (!(((stream->__modeflags | bufmask)
+				   ^ (__FLAG_WRITING|__FLAG_LBF)
+				   ) & (__FLAG_WRITING|__MASK_BUFMODE))
+				) {
+				if (!__STDIO_COMMIT_WRITE_BUFFER(stream)) {
+					__STDIO_STREAM_DISABLE_PUTC(stream);
+					__STDIO_STREAM_CLEAR_WRITING(stream);
+				} else {
+					retval = EOF;
 				}
+			}
 				__MY_STDIO_THREADUNLOCK(stream);
 			}
 			stream = stream->__nextopen;
diff -urN a/libc/stdio/_fopen.c b/libc/stdio/_fopen.c
--- a/libc/stdio/_fopen.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/stdio/_fopen.c	2012-04-10 13:55:23.000000000 +0800
@@ -63,11 +63,6 @@
 		open_mode += (O_RDWR - (O_RDONLY | O_WRONLY));
 	}
 
-#ifdef __UCLIBC_MJN3_ONLY__
-#warning CONSIDER: Implement glibc ccs option to bind a codeset?
-#warning CONSIDER: Implement glibc mmap option for readonly files?
-#warning CONSIDER: Implement a text mode using custom read/write funcs?
-#endif
 #if defined(__UCLIBC_HAS_FOPEN_EXCLUSIVE_MODE__) || defined(__UCLIBC_HAS_FOPEN_LARGEFILE_MODE__)
 
 	while (*++mode) {
@@ -206,8 +201,8 @@
 		 * the last file. */
 		__STDIO_THREADLOCK_OPENLIST_DEL;
 		__STDIO_THREADLOCK_OPENLIST_ADD;
-		stream->__nextopen = _stdio_openlist; /* New files are inserted at */
-		_stdio_openlist = stream;			  /*   the head of the list. */
+	stream->__nextopen = _stdio_openlist; /* New files are inserted at */
+	_stdio_openlist = stream;			  /*   the head of the list. */
 		__STDIO_THREADUNLOCK_OPENLIST_ADD;
 		__STDIO_THREADUNLOCK_OPENLIST_DEL;
 	}
diff -urN a/libc/stdio/.indent.pro b/libc/stdio/.indent.pro
--- a/libc/stdio/.indent.pro	2000-10-10 04:06:30.000000000 +0800
+++ b/libc/stdio/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/stdio/scanf.c b/libc/stdio/scanf.c
--- a/libc/stdio/scanf.c	2004-02-12 06:48:50.000000000 +0700
+++ b/libc/stdio/scanf.c	2012-04-10 13:55:23.000000000 +0800
@@ -241,7 +241,7 @@
 
 	/* Set these last since __bufgetc initialization depends on
 	 * __user_locking and only gets set if user locking is on. */
-	f.__bufstart = 
+	f.__bufstart =
 	f.__bufpos = (unsigned char *) ((void *) sp);
 	f.__bufread =
 	f.__bufend = f.__bufstart + strlen(sp);
@@ -385,10 +385,8 @@
 {
 	FILE f;
 
-	f.__bufstart =
-	f.__bufpos = (char *) str;
-	f.__bufread =
-	f.__bufend = (char *)(str + wcslen(str));
+	f.__bufstart = f.__bufpos = (unsigned char *) str;
+	f.__bufread = f.__bufend = (unsigned char *) (str + wcslen(str));
 	__STDIO_STREAM_DISABLE_GETC(&f);
 	__STDIO_STREAM_DISABLE_PUTC(&f);
 
@@ -472,7 +470,7 @@
 	FLAG_THOUSANDS	=	0x20,
 	FLAG_I18N		=	0x40,	/* only works for d, i, u */
 	FLAG_MALLOC     =   0x80,	/* only works for s, S, and [ (and l[)*/
-};	  
+};
 
 
 #define SPEC_RANGES		{ CONV_n, CONV_p, CONV_i, CONV_A, \
@@ -552,13 +550,15 @@
 #define QUAL_CHARS		{ \
 	/* j:(u)intmax_t z:(s)size_t  t:ptrdiff_t  \0:int  q:long_long */ \
 	'h',   'l',  'L',  'j',  'z',  't',  'q', 0, \
-	 2,     4,    8,  IMS,   SS,  PDS,    8,  0, /* TODO -- fix!!! */\
-     1,     8   }
+	 2,     4,    8,  IMS,   SS,  PDS,    8,  0, /* TODO -- fix!!! */ \
+	 1,     8 \
+}
 
 
 /**********************************************************************/
 
 #ifdef L_vfwscanf
+/* FIXME: "warning: the right operand of ">" changes sign when promoted" */
 #if WINT_MIN > EOF
 #error Unfortunately, we currently need wint_t to be able to store EOF.  Sorry.
 #endif
@@ -1034,9 +1034,6 @@
 		wc = '.';
 	} else
 #endif /* __UCLIBC_HAS_FLOATS__ */
-	if (!__isascii(wc)) {
-		wc = '?';
-	}
 	sc->wc = sc->ungot_char = wc;
 
 	return (int) wc;
@@ -1145,7 +1142,9 @@
 #endif /* L_vfwscanf */
 
 #ifdef __UCLIBC_HAS_WCHAR__
+#if defined(__UCLIBC_HAS_LOCALE__) && !defined(L_vfwscanf)
 	mbstate_t mbstate;
+#endif
 #endif /* __UCLIBC_HAS_WCHAR__ */
 
 	struct scan_cookie sc;
@@ -1160,10 +1159,13 @@
 	unsigned char buf[MAX_DIGITS+2];
 #ifdef L_vfscanf
 	unsigned char scanset[UCHAR_MAX + 1];
-	unsigned char invert;		/* Careful!  Meaning changes. */
+	unsigned char invert = "";		/* Careful!  Meaning changes. */
 #endif /* L_vfscanf */
 	unsigned char fail;
 	unsigned char zero_conversions = 1;
+#ifndef L_vfscanf
+	mbstate_t mbstate;                      /* vfscanf */
+#endif
 	__STDIO_AUTO_THREADLOCK_VAR;
 
 #ifdef __UCLIBC_MJN3_ONLY__
@@ -1202,13 +1204,13 @@
 
 #ifdef __UCLIBC_HAS_GLIBC_DIGIT_GROUPING__
 	if (*sc.grouping) {
-		sc.thousands_sep = fake_thousands_sep_str;
+		sc.thousands_sep = (const unsigned char *) ",";
 		sc.tslen = 1;
 	}
 #endif /* __UCLIBC_HAS_GLIBC_DIGIT_GROUPING__ */
 
 #ifdef __UCLIBC_HAS_FLOATS__
-	sc.fake_decpt = fake_decpt_str;
+	sc.fake_decpt = (const unsigned char *) ".";
 #endif /* __UCLIBC_HAS_FLOATS__ */
 
 #else  /* L_vfwscanf */
@@ -1332,7 +1334,7 @@
 
 			if (psfs.conv_num == CONV_percent) {
 				goto MATCH_CHAR;
- 			}
+			}
 
 			if (psfs.conv_num == CONV_n) {
 #ifdef __UCLIBC_MJN3_ONLY__
@@ -1376,7 +1378,6 @@
 			{
 				b = (psfs.store ? ((unsigned char *) psfs.cur_ptr) : buf);
 				fail = 1;
-			
 
 				if (psfs.conv_num == CONV_c) {
 					if (sc.width == INT_MAX) {
@@ -1417,7 +1418,7 @@
 					if (*++fmt == '^') {
 						++fmt;
 						invert = 1;
- 					}
+					}
 					memset(scanset, invert, sizeof(scanset));
 					invert = 1-invert;
 
@@ -1485,7 +1486,7 @@
 
 				wb = (psfs.store ? ((wchar_t *) psfs.cur_ptr) : wbuf);
 				fail = 1;
-			
+
 				if (psfs.conv_num == CONV_C) {
 					if (sc.width == INT_MAX) {
 						sc.width = 1;
@@ -1577,7 +1578,7 @@
 							*wb = sc.wc;
 							wb += psfs.store;
 						} else {
-							i = wcrtomb(b, sc.wc, &mbstate);
+							i = wcrtomb((char*) b, sc.wc, &mbstate);
 							if (i < 0) { /* Conversion failure. */
 								goto DONE_DO_UNGET;
 							}
@@ -1605,7 +1606,7 @@
 							*wb = sc.wc;
 							wb += psfs.store;
 						} else {
-							i = wcrtomb(b, sc.wc, &mbstate);
+							i = wcrtomb((char*) b, sc.wc, &mbstate);
 							if (i < 0) { /* Conversion failure. */
 								goto DONE_DO_UNGET;
 							}
@@ -1679,7 +1680,7 @@
 							*wb = sc.wc;
 							wb += psfs.store;
 						} else {
-							i = wcrtomb(b, sc.wc, &mbstate);
+							i = wcrtomb((char*) b, sc.wc, &mbstate);
 							if (i < 0) { /* Conversion failure. */
 								goto DONE_DO_UNGET;
 							}
@@ -1793,7 +1794,7 @@
 				if (psfs->store) {
 					++psfs->cnt;
 					_store_inttype(psfs->cur_ptr, psfs->dataargtype,
-								   (uintmax_t) NULL);
+								   (uintmax_t)0);
 				}
 				return 0;
 			}
@@ -1852,7 +1853,7 @@
 #ifdef __UCLIBC_HAS_GLIBC_DIGIT_GROUPING__
 
 	if ((psfs->flags & FLAG_THOUSANDS) && (base == 10)
-		&& *(p = sc->grouping)
+		&& *(p = (const unsigned char *) sc->grouping)
 		) {
 
 		int nblk1, nblk2, nbmax, lastblock, pass, i;
@@ -1974,7 +1975,7 @@
 								p = sc->fake_decpt + k;
 								do {
 									if (!*++p) {
-										strcpy(b, sc->decpt);
+										strcpy((char*) b, (char*) sc->decpt);
 										b += sc->decpt_len;
 										goto GOT_DECPT;
 									}
@@ -2054,7 +2055,7 @@
 			}
 			++psfs->cnt;
 			_store_inttype(psfs->cur_ptr, psfs->dataargtype,
-						   (uintmax_t) STRTOUIM(buf, NULL, base, 1-usflag));
+						   (uintmax_t) STRTOUIM((char *) buf, NULL, base, 1-usflag));
 		}
 		return 0;
 	}
@@ -2068,7 +2069,7 @@
 	p = sc->fake_decpt;
 	do {
 		if (!*p) {
-			strcpy(b, sc->decpt);
+			strcpy((char *) b, (char *) sc->decpt);
 			b += sc->decpt_len;
 			break;
 		}
@@ -2175,7 +2176,7 @@
 		assert(seendigit);
 		seendigit = 0;
 		nonzero = 0;
-		
+
 		if (sc->cc == '0') {
 			seendigit = 1;
 			*b++ = '0';
@@ -2191,7 +2192,7 @@
 			}
 			__scan_getc(sc);
 		}
-			
+
 		if (!seendigit) {		/* No digits.  Unrecoverable. */
 			goto DONE_DO_UNGET;
 		}
@@ -2203,7 +2204,7 @@
 	{
 		__fpmax_t x;
 		char *e;
-		x = __strtofpmax(buf, &e, exp_adjust);
+		x = __strtofpmax((char *) buf, &e, exp_adjust);
 		assert(!*e);
 		if (psfs->store) {
 			if (psfs->dataargtype & PA_FLAG_LONG_LONG) {
diff -urN a/libc/stdio/vfprintf.c b/libc/stdio/vfprintf.c
--- a/libc/stdio/vfprintf.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/stdio/vfprintf.c	2012-04-10 13:55:23.000000000 +0800
@@ -35,7 +35,7 @@
 /* April 1, 2002
  * Initialize thread locks for fake files in vsnprintf and vdprintf.
  *    reported by Erik Andersen (andersen@codepoet.com)
- * Fix an arg promotion handling bug in _do_one_spec for %c. 
+ * Fix an arg promotion handling bug in _do_one_spec for %c.
  *    reported by Ilguiz Latypov <ilatypov@superbt.com>
  *
  * May 10, 2002
@@ -229,7 +229,7 @@
 	FLAG_THOUSANDS	=	0x20,
 	FLAG_I18N		=	0x40,	/* only works for d, i, u */
 	FLAG_WIDESTREAM =   0x80
-};	  
+};
 
 /**********************************************************************/
 
@@ -678,7 +678,7 @@
 				case PA_STRING:
 				case PA_WSTRING:
 					GET_VA_ARG(p,p,void *,ppfs->arg);
-					break;				
+					break;
 				case __PA_NOARG:
 					continue;
 			}
@@ -689,7 +689,7 @@
 		if (ppfs->info.width == INT_MIN) {
 			ppfs->info.width
 				= (int) GET_ARG_VALUE(p + ppfs->argnumber[0] - 1,u,unsigned int);
-		} 
+		}
 		if (ppfs->info.prec == INT_MIN) {
 			ppfs->info.prec
 				= (int) GET_ARG_VALUE(p + ppfs->argnumber[1] - 1,u,unsigned int);
@@ -732,7 +732,7 @@
 
 /* TODO -- rethink this -- perhaps we should set to largest type??? */
 
-#ifdef _OVERLAPPING_DIFFERENT_ARGS 
+#ifdef _OVERLAPPING_DIFFERENT_ARGS
 
 #define PROMOTED_SIZE_OF(X)		((sizeof(X) + sizeof(int) - 1) / sizeof(X))
 
@@ -878,7 +878,7 @@
 				) {
 				return -1;
 			}
-		} while (buf[i++]);
+		} while (buf[i++] && (i < sizeof(buf)));
 		buf[sizeof(buf)-1] = 0;
 	}
 #else  /* __UCLIBC_HAS_WCHAR__ */
@@ -898,8 +898,11 @@
 	}
 	i = 0;
 	while (isdigit(*fmt)) {
-		if (i < MAX_FIELD_WIDTH) { /* Avoid overflow. */
+		if (i < INT_MAX / 10
+		    || (i == INT_MAX / 10 && (*fmt - '0') <= INT_MAX % 10)) {
 			i = (i * 10) + (*fmt - '0');
+		} else {
+			i = INT_MAX; /* best we can do... */
 		}
 		++fmt;
 	}
@@ -956,7 +959,7 @@
 	restart_flags:		/* Process flags. */
 		i = 1;
 		p = spec_flags;
-	
+
 		do {
 			if (*fmt == *p++) {
 				++fmt;
@@ -1082,7 +1085,7 @@
 		/* Otherwise error. */
 		return -1;
 	}
-		
+
 #if defined(__UCLIBC_HAS_GLIBC_CUSTOM_PRINTF__) || defined(__UCLIBC_HAS_PRINTF_M_SPEC__)
  DONE:
 #endif
@@ -1196,7 +1199,7 @@
 #define _PPFS_init _ppfs_init
 #define OUTPUT(F,S)			__fputs_unlocked(S,F)
 /* #define _outnstr(stream, string, len)	__stdio_fwrite(string, len, stream) */
-#define _outnstr(stream, string, len)	((len > 0) ? __stdio_fwrite(string, len, stream) : 0)
+#define _outnstr(stream, string, len)  ((len > 0) ? __stdio_fwrite((const unsigned char *)(string), len, stream) : 0)
 #define FP_OUT _fp_out_narrow
 
 #ifdef __STDIO_PRINTF_FLOAT
@@ -1227,7 +1230,7 @@
 #define STRLEN  wcslen
 #define _PPFS_init _ppwfs_init
 #define OUTPUT(F,S)			fputws(S,F)
-#define _outnwcs(stream, wstring, len)	_wstdio_fwrite(wstring, len, stream)
+#define _outnwcs(stream, wstring, len) _wstdio_fwrite((const wchar_t *)(wstring), len, stream)
 #define FP_OUT _fp_out_wide
 
 static size_t _outnstr(FILE *stream, const char *s, size_t wclen)
@@ -1239,7 +1242,7 @@
 
 	mbstate.__mask = 0;
 	todo = wclen;
-	
+
 	while (todo) {
 		r = mbsrtowcs(wbuf, &s,
 					  ((todo <= sizeof(wbuf)/sizeof(wbuf[0]))
@@ -1407,7 +1410,7 @@
 	FMT_TYPE pad[1];
 
 	*pad = padchar;
-	while (todo && (OUTNSTR(stream, pad, 1) == 1)) {
+	while (todo && (OUTNSTR(stream, (const char *) pad, 1) == 1)) {
 		--todo;
 	}
 
@@ -1466,6 +1469,8 @@
 	 * eventually this should be handled robustly. */
 	char buf[128];
 
+	memset(argptr, 0, sizeof(argptr));
+
 #ifdef NDEBUG
 	_ppfs_parsespec(ppfs);
 #else
@@ -1811,7 +1816,7 @@
 			}
 		}
 #else  /* __UCLIBC_HAS_WCHAR__ */
-		if (_outnstr(stream, s, slen) != slen) {
+		if (_outnstr(stream, (const unsigned char *) s, slen) != slen) {
 			return -1;
 		}
 #endif /* __UCLIBC_HAS_WCHAR__ */
@@ -1877,8 +1882,9 @@
 				++format;
 			}
 
-			if (format-s) {		/* output any literal text in format string */
-				if ( (r = OUTNSTR(stream, s, format-s)) != (format-s)) {
+			if (format - s) {	/* output any literal text in format string */
+				r = OUTNSTR(stream, (const char *) s, format - s);
+				if (r != (format - s)) {
 					count = -1;
 					break;
 				}
@@ -1888,7 +1894,7 @@
 			if (!*format) {			/* we're done */
 				break;
 			}
-		
+
 			if (format[1] != '%') {	/* if we get here, *format == '%' */
 				/* TODO: _do_one_spec needs to know what the output funcs are!!! */
 				ppfs.fmtpos = (const char *)(++format);
diff -urN a/libc/stdio/vsnprintf.c b/libc/stdio/vsnprintf.c
--- a/libc/stdio/vsnprintf.c	2004-02-12 06:48:50.000000000 +0700
+++ b/libc/stdio/vsnprintf.c	2012-04-10 13:55:23.000000000 +0800
@@ -49,10 +49,11 @@
 		size = SIZE_MAX - (size_t) buf;
 	}
 
+/* TODO: this comment seems to be wrong */
 	/* Set these last since __bufputc initialization depends on
 	 * __user_locking and only gets set if user locking is on. */
-	f.__bufstart = buf;
-	f.__bufend = buf + size;
+	f.__bufstart = (unsigned char *) buf;
+	f.__bufend = (unsigned char *) buf + size;
 	__STDIO_STREAM_INIT_BUFREAD_BUFPOS(&f);
 	__STDIO_STREAM_DISABLE_GETC(&f);
 	__STDIO_STREAM_ENABLE_PUTC(&f);
diff -urN a/libc/stdio/vswprintf.c b/libc/stdio/vswprintf.c
--- a/libc/stdio/vswprintf.c	2004-02-12 06:48:50.000000000 +0700
+++ b/libc/stdio/vswprintf.c	2012-04-10 13:55:23.000000000 +0800
@@ -36,18 +36,14 @@
 	__INIT_MBSTATE(&(f.__state));
 #endif /* __STDIO_MBSTATE */
 
-#ifdef __UCLIBC_HAS_THREADS__
-	f.__user_locking = 1;		/* Set user locking. */
-	__stdio_init_mutex(&f.__lock);
-#endif
 	f.__nextopen = NULL;
 
 	if (size > ((SIZE_MAX - (size_t) buf)/sizeof(wchar_t))) {
 		size = ((SIZE_MAX - (size_t) buf)/sizeof(wchar_t));
 	}
 
-	f.__bufstart = (char *) buf;
-	f.__bufend = (char *)(buf + size);
+	f.__bufstart = (unsigned char *) buf;
+	f.__bufend = (unsigned char *) (buf + size);
 	__STDIO_STREAM_INIT_BUFREAD_BUFPOS(&f);
 	__STDIO_STREAM_DISABLE_GETC(&f);
 	__STDIO_STREAM_DISABLE_PUTC(&f);
@@ -58,7 +54,7 @@
 	if (f.__bufpos == f.__bufend) {
 		rv = -1;
 		if (size) {
-			f.__bufpos = (char *)(((wchar_t *) f.__bufpos) - 1);
+			f.__bufpos = (unsigned char *) (((wchar_t *) f.__bufpos) - 1);
 		}
 	}
 	if (size) {
diff -urN a/libc/stdio/_wfwrite.c b/libc/stdio/_wfwrite.c
--- a/libc/stdio/_wfwrite.c	2004-02-12 06:48:50.000000000 +0700
+++ b/libc/stdio/_wfwrite.c	2012-04-10 13:55:23.000000000 +0800
@@ -38,7 +38,7 @@
 		}
 		if (count) {
 			wmemcpy((wchar_t *)(stream->__bufpos), ws, count);
-			stream->__bufpos = (char *)(((wchar_t *)(stream->__bufpos)) + count);
+			stream->__bufpos = (unsigned char *)(((wchar_t *)(stream->__bufpos)) + count);
 		}
 		__STDIO_STREAM_VALIDATE(stream);
 		return n;
@@ -59,7 +59,7 @@
 					++r;		  /* 0 is returned when nul is reached. */
 					pw = ws + count + r; /* pw was set to NULL, so correct. */
 				}
-				if (__stdio_fwrite(buf, r, stream) == r) {
+				if (__stdio_fwrite((const unsigned char *)buf, r, stream) == r) {
 					count = pw - ws;
 					continue;
 				}
diff -urN a/libc/stdio/_WRITE.c b/libc/stdio/_WRITE.c
--- a/libc/stdio/_WRITE.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/stdio/_WRITE.c	2012-04-10 13:55:23.000000000 +0800
@@ -47,7 +47,7 @@
 			return bufsize;
 		}
 		stodo = (todo <= SSIZE_MAX) ? todo : SSIZE_MAX;
-		if ((rv = __WRITE(stream, (char *) buf, stodo)) >= 0) {
+		if ((rv = __WRITE(stream, (const char*)buf, stodo)) >= 0) {
 #ifdef __UCLIBC_MJN3_ONLY__
 #warning TODO: Make custom stream write return check optional.
 #endif
diff -urN a/libc/stdlib/.indent.pro b/libc/stdlib/.indent.pro
--- a/libc/stdlib/.indent.pro	2000-10-10 04:06:30.000000000 +0800
+++ b/libc/stdlib/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/stdlib/Makefile b/libc/stdlib/Makefile
--- a/libc/stdlib/Makefile	2005-01-25 10:17:00.000000000 +0700
+++ b/libc/stdlib/Makefile	2012-04-10 13:55:23.000000000 +0800
@@ -1,7 +1,7 @@
 # Makefile for uClibc
 #
 # Copyright (C) 2000 by Lineo, inc.
-# Copyright (C) 2000,2001 Erik Andersen <andersen@uclibc.org>
+# Copyright (C) 2000-2005 Erik Andersen <andersen@uclibc.org>
 #
 # This program is free software; you can redistribute it and/or modify it under
 # the terms of the GNU Library General Public License as published by the Free
@@ -86,7 +86,7 @@
 	getpt.c ptsname.c grantpt.c unlockpt.c gcvt.c drand48-iter.c jrand48.c \
 	jrand48_r.c lrand48.c lrand48_r.c mrand48.c mrand48_r.c nrand48.c \
 	nrand48_r.c rand_r.c srand48.c srand48_r.c seed48.c seed48_r.c \
-	valloc.c
+	valloc.c posix_memalign.c
 ifeq ($(UCLIBC_HAS_FLOATS),y)
 	CSRC += drand48.c drand48_r.c erand48.c erand48_r.c
 endif
diff -urN a/libc/stdlib/malloc-simple/alloc.c b/libc/stdlib/malloc-simple/alloc.c
--- a/libc/stdlib/malloc-simple/alloc.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/stdlib/malloc-simple/alloc.c	2012-04-10 13:55:23.000000000 +0800
@@ -158,7 +158,7 @@
 		return NULL;
 
 	adj = (unsigned long int) ((unsigned long int) ((char *) result -
-													(char *) NULL)) % alignment;
+	      (char *) NULL)) % alignment;
 	if (adj != 0) {
 		struct alignlist *l;
 		__MALLOC_LOCK;
diff -urN a/libc/stdlib/malloc-standard/calloc.c b/libc/stdlib/malloc-standard/calloc.c
--- a/libc/stdlib/malloc-standard/calloc.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/stdlib/malloc-standard/calloc.c	2012-04-10 13:55:23.000000000 +0800
@@ -8,7 +8,7 @@
   VERSION 2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
 
   Note: There may be an updated version of this malloc obtainable at
-  ftp://gee.cs.oswego.edu/pub/misc/malloc.c
+           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
   Check before installing!
 
   Hacked up for uClibc by Erik Andersen <andersen@codepoet.org>
@@ -31,60 +31,60 @@
      * to fall through and call malloc(0) */
     size = n_elements * elem_size;
     if (n_elements && elem_size != (size / n_elements)) {
-		__set_errno(ENOMEM);
-		return NULL;
+	__set_errno(ENOMEM);
+	return NULL;
     }
 
     __MALLOC_LOCK;
     mem = malloc(size);
     if (mem != 0) {
-		p = mem2chunk(mem);
+	p = mem2chunk(mem);
 
-		if (!chunk_is_mmapped(p))
-			{
-				/*
-				  Unroll clear of <= 36 bytes (72 if 8byte sizes)
-				  We know that contents have an odd number of
-				  size_t-sized words; minimally 3.
-				*/
-
-				d = (size_t*)mem;
-				clearsize = chunksize(p) - (sizeof(size_t));
-				nclears = clearsize / sizeof(size_t);
-				assert(nclears >= 3);
-
-				if (nclears > 9)
-					memset(d, 0, clearsize);
-
-				else {
-					*(d+0) = 0;
-					*(d+1) = 0;
-					*(d+2) = 0;
-					if (nclears > 4) {
-						*(d+3) = 0;
-						*(d+4) = 0;
-						if (nclears > 6) {
-							*(d+5) = 0;
-							*(d+6) = 0;
-							if (nclears > 8) {
-								*(d+7) = 0;
-								*(d+8) = 0;
-							}
-						}
-					}
-				}
+	if (!chunk_is_mmapped(p))
+	{
+	    /*
+	       Unroll clear of <= 36 bytes (72 if 8byte sizes)
+	       We know that contents have an odd number of
+	       size_t-sized words; minimally 3.
+	       */
+
+	    d = (size_t*)mem;
+	    clearsize = chunksize(p) - (sizeof(size_t));
+	    nclears = clearsize / sizeof(size_t);
+	    assert(nclears >= 3);
+
+	    if (nclears > 9)
+		memset(d, 0, clearsize);
+
+	    else {
+		*(d+0) = 0;
+		*(d+1) = 0;
+		*(d+2) = 0;
+		if (nclears > 4) {
+		    *(d+3) = 0;
+		    *(d+4) = 0;
+		    if (nclears > 6) {
+			*(d+5) = 0;
+			*(d+6) = 0;
+			if (nclears > 8) {
+			    *(d+7) = 0;
+			    *(d+8) = 0;
 			}
+		    }
+		}
+	    }
+	}
 #if 0
-		else
-			{
-				/* Standard unix mmap using /dev/zero clears memory so calloc
-				 * doesn't need to actually zero anything....
-				 */
-				d = (size_t*)mem;
-				/* Note the additional (sizeof(size_t)) */
-				clearsize = chunksize(p) - 2*(sizeof(size_t));
-				memset(d, 0, clearsize);
-			}
+	else
+	{
+	/* Standard unix mmap using /dev/zero clears memory so calloc
+	 * doesn't need to actually zero anything....
+	 */
+	    d = (size_t*)mem;
+	    /* Note the additional (sizeof(size_t)) */
+	    clearsize = chunksize(p) - 2*(sizeof(size_t));
+	    memset(d, 0, clearsize);
+	}
 #endif
     }
     __MALLOC_UNLOCK;
diff -urN a/libc/stdlib/malloc-standard/free.c b/libc/stdlib/malloc-standard/free.c
--- a/libc/stdlib/malloc-standard/free.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/stdlib/malloc-standard/free.c	2012-04-10 13:55:23.000000000 +0800
@@ -8,7 +8,7 @@
   VERSION 2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
 
   Note: There may be an updated version of this malloc obtainable at
-  ftp://gee.cs.oswego.edu/pub/misc/malloc.c
+           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
   Check before installing!
 
   Hacked up for uClibc by Erik Andersen <andersen@codepoet.org>
@@ -42,71 +42,71 @@
 
     if (extra > 0) {
 
-		/*
-		  Only proceed if end of memory is where we last set it.
-		  This avoids problems if there were foreign sbrk calls.
-		*/
-		current_brk = (char*)(MORECORE(0));
-		if (current_brk == (char*)(av->top) + top_size) {
-
-			/*
-			  Attempt to release memory. We ignore MORECORE return value,
-			  and instead call again to find out where new end of memory is.
-			  This avoids problems if first call releases less than we asked,
-			  of if failure somehow altered brk value. (We could still
-			  encounter problems if it altered brk in some very bad way,
-			  but the only thing we can do is adjust anyway, which will cause
-			  some downstream failure.)
-			*/
-
-			MORECORE(-extra);
-			new_brk = (char*)(MORECORE(0));
-
-			if (new_brk != (char*)MORECORE_FAILURE) {
-				released = (long)(current_brk - new_brk);
-
-				if (released != 0) {
-					/* Success. Adjust top. */
-					av->sbrked_mem -= released;
-					set_head(av->top, (top_size - released) | PREV_INUSE);
-					check_malloc_state();
-					return 1;
-				}
-			}
+	/*
+	   Only proceed if end of memory is where we last set it.
+	   This avoids problems if there were foreign sbrk calls.
+	   */
+	current_brk = (char*)(MORECORE(0));
+	if (current_brk == (char*)(av->top) + top_size) {
+
+	    /*
+	       Attempt to release memory. We ignore MORECORE return value,
+	       and instead call again to find out where new end of memory is.
+	       This avoids problems if first call releases less than we asked,
+	       of if failure somehow altered brk value. (We could still
+	       encounter problems if it altered brk in some very bad way,
+	       but the only thing we can do is adjust anyway, which will cause
+	       some downstream failure.)
+	       */
+
+	    MORECORE(-extra);
+	    new_brk = (char*)(MORECORE(0));
+
+	    if (new_brk != (char*)MORECORE_FAILURE) {
+		released = (long)(current_brk - new_brk);
+
+		if (released != 0) {
+		    /* Success. Adjust top. */
+		    av->sbrked_mem -= released;
+		    set_head(av->top, (top_size - released) | PREV_INUSE);
+		    check_malloc_state();
+		    return 1;
 		}
+	    }
+	}
     }
     return 0;
 }
 
 /* ------------------------- malloc_trim -------------------------
-   malloc_trim(size_t pad);
+  malloc_trim(size_t pad);
 
-   If possible, gives memory back to the system (via negative
-   arguments to sbrk) if there is unused memory at the `high' end of
-   the malloc pool. You can call this after freeing large blocks of
-   memory to potentially reduce the system-level memory requirements
-   of a program. However, it cannot guarantee to reduce memory. Under
-   some allocation patterns, some large free blocks of memory will be
-   locked between two used chunks, so they cannot be given back to
-   the system.
-
-   The `pad' argument to malloc_trim represents the amount of free
-   trailing space to leave untrimmed. If this argument is zero,
-   only the minimum amount of memory to maintain internal data
-   structures will be left (one page or less). Non-zero arguments
-   can be supplied to maintain enough trailing space to service
-   future expected allocations without having to re-obtain memory
-   from the system.
-
-   Malloc_trim returns 1 if it actually released any memory, else 0.
-   On systems that do not support "negative sbrks", it will always
-   return 0.
+  If possible, gives memory back to the system (via negative
+  arguments to sbrk) if there is unused memory at the `high' end of
+  the malloc pool. You can call this after freeing large blocks of
+  memory to potentially reduce the system-level memory requirements
+  of a program. However, it cannot guarantee to reduce memory. Under
+  some allocation patterns, some large free blocks of memory will be
+  locked between two used chunks, so they cannot be given back to
+  the system.
+
+  The `pad' argument to malloc_trim represents the amount of free
+  trailing space to leave untrimmed. If this argument is zero,
+  only the minimum amount of memory to maintain internal data
+  structures will be left (one page or less). Non-zero arguments
+  can be supplied to maintain enough trailing space to service
+  future expected allocations without having to re-obtain memory
+  from the system.
+
+  Malloc_trim returns 1 if it actually released any memory, else 0.
+  On systems that do not support "negative sbrks", it will always
+  return 0.
 */
 int malloc_trim(size_t pad)
 {
-	mstate av = get_malloc_state();
-	__malloc_consolidate(av);
-	return __malloc_trim(pad, av);
+  mstate av = get_malloc_state();
+  __malloc_consolidate(av);
+  return __malloc_trim(pad, av);
 }
 
 /*
@@ -125,8 +125,8 @@
 
     /* Establish circular links for normal bins */
     for (i = 1; i < NBINS; ++i) {
-		bin = bin_at(av,i);
-		bin->fd = bin->bk = bin;
+	bin = bin_at(av,i);
+	bin->fd = bin->bk = bin;
     }
 
     av->top_pad        = DEFAULT_TOP_PAD;
@@ -157,15 +157,15 @@
 
 /* ------------------------- __malloc_consolidate -------------------------
 
-__malloc_consolidate is a specialized version of free() that tears
-down chunks held in fastbins.  Free itself cannot be used for this
-purpose since, among other things, it might place chunks back onto
-fastbins.  So, instead, we need to use a minor variant of the same
-code.
-
-Also, because this routine needs to be called the first time through
-malloc anyway, it turns out to be the perfect place to trigger
-initialization code.
+  __malloc_consolidate is a specialized version of free() that tears
+  down chunks held in fastbins.  Free itself cannot be used for this
+  purpose since, among other things, it might place chunks back onto
+  fastbins.  So, instead, we need to use a minor variant of the same
+  code.
+
+  Also, because this routine needs to be called the first time through
+  malloc anyway, it turns out to be the perfect place to trigger
+  initialization code.
 */
 void __malloc_consolidate(mstate av)
 {
@@ -186,78 +186,78 @@
     mchunkptr       fwd;
 
     /*
-	  If max_fast is 0, we know that av hasn't
-	  yet been initialized, in which case do so below
-	*/
+       If max_fast is 0, we know that av hasn't
+       yet been initialized, in which case do so below
+       */
 
     if (av->max_fast != 0) {
-		clear_fastchunks(av);
+	clear_fastchunks(av);
 
-		unsorted_bin = unsorted_chunks(av);
+	unsorted_bin = unsorted_chunks(av);
 
-		/*
-		  Remove each chunk from fast bin and consolidate it, placing it
-		  then in unsorted bin. Among other reasons for doing this,
-		  placing in unsorted bin avoids needing to calculate actual bins
-		  until malloc is sure that chunks aren't immediately going to be
-		  reused anyway.
-		*/
+	/*
+	   Remove each chunk from fast bin and consolidate it, placing it
+	   then in unsorted bin. Among other reasons for doing this,
+	   placing in unsorted bin avoids needing to calculate actual bins
+	   until malloc is sure that chunks aren't immediately going to be
+	   reused anyway.
+	   */
+
+	maxfb = &(av->fastbins[fastbin_index(av->max_fast)]);
+	fb = &(av->fastbins[0]);
+	do {
+	    if ( (p = *fb) != 0) {
+		*fb = 0;
 
-		maxfb = &(av->fastbins[fastbin_index(av->max_fast)]);
-		fb = &(av->fastbins[0]);
 		do {
-			if ( (p = *fb) != 0) {
-				*fb = 0;
+		    check_inuse_chunk(p);
+		    nextp = p->fd;
 
-				do {
-					check_inuse_chunk(p);
-					nextp = p->fd;
-
-					/* Slightly streamlined version of consolidation code in free() */
-					size = p->size & ~PREV_INUSE;
-					nextchunk = chunk_at_offset(p, size);
-					nextsize = chunksize(nextchunk);
-
-					if (!prev_inuse(p)) {
-						prevsize = p->prev_size;
-						size += prevsize;
-						p = chunk_at_offset(p, -((long) prevsize));
-						unlink(p, bck, fwd);
-					}
-
-					if (nextchunk != av->top) {
-						nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
-						set_head(nextchunk, nextsize);
-
-						if (!nextinuse) {
-							size += nextsize;
-							unlink(nextchunk, bck, fwd);
-						}
-
-						first_unsorted = unsorted_bin->fd;
-						unsorted_bin->fd = p;
-						first_unsorted->bk = p;
-
-						set_head(p, size | PREV_INUSE);
-						p->bk = unsorted_bin;
-						p->fd = first_unsorted;
-						set_foot(p, size);
-					}
-
-					else {
-						size += nextsize;
-						set_head(p, size | PREV_INUSE);
-						av->top = p;
-					}
+		    /* Slightly streamlined version of consolidation code in free() */
+		    size = p->size & ~PREV_INUSE;
+		    nextchunk = chunk_at_offset(p, size);
+		    nextsize = chunksize(nextchunk);
 
-				} while ( (p = nextp) != 0);
+		    if (!prev_inuse(p)) {
+			prevsize = p->prev_size;
+			size += prevsize;
+			p = chunk_at_offset(p, -((long) prevsize));
+			unlink(p, bck, fwd);
+		    }
 
+		    if (nextchunk != av->top) {
+			nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
+			set_head(nextchunk, nextsize);
+
+			if (!nextinuse) {
+			    size += nextsize;
+			    unlink(nextchunk, bck, fwd);
 			}
-		} while (fb++ != maxfb);
+
+			first_unsorted = unsorted_bin->fd;
+			unsorted_bin->fd = p;
+			first_unsorted->bk = p;
+
+			set_head(p, size | PREV_INUSE);
+			p->bk = unsorted_bin;
+			p->fd = first_unsorted;
+			set_foot(p, size);
+		    }
+
+		    else {
+			size += nextsize;
+			set_head(p, size | PREV_INUSE);
+			av->top = p;
+		    }
+
+		} while ( (p = nextp) != 0);
+
+	    }
+	} while (fb++ != maxfb);
     }
     else {
-		malloc_init_state(av);
-		check_malloc_state();
+	malloc_init_state(av);
+	check_malloc_state();
     }
 }
 
@@ -279,7 +279,7 @@
 
     /* free(0) has no effect */
     if (mem == NULL)
-		return;
+	return;
 
     __MALLOC_LOCK;
     av = get_malloc_state();
@@ -289,9 +289,9 @@
     check_inuse_chunk(p);
 
     /*
-	  If eligible, place chunk on a fastbin so it can be found
-	  and used quickly in malloc.
-	*/
+       If eligible, place chunk on a fastbin so it can be found
+       and used quickly in malloc.
+       */
 
     if ((unsigned long)(size) <= (unsigned long)(av->max_fast)
 
@@ -300,113 +300,113 @@
 	       bordering top into fastbins */
 	    && (chunk_at_offset(p, size) != av->top)
 #endif
-		) {
+       ) {
 
-		set_fastchunks(av);
-		fb = &(av->fastbins[fastbin_index(size)]);
-		p->fd = *fb;
-		*fb = p;
+	set_fastchunks(av);
+	fb = &(av->fastbins[fastbin_index(size)]);
+	p->fd = *fb;
+	*fb = p;
     }
 
     /*
-	  Consolidate other non-mmapped chunks as they arrive.
-	*/
+       Consolidate other non-mmapped chunks as they arrive.
+       */
 
     else if (!chunk_is_mmapped(p)) {
-		set_anychunks(av);
-
-		nextchunk = chunk_at_offset(p, size);
-		nextsize = chunksize(nextchunk);
-
-		/* consolidate backward */
-		if (!prev_inuse(p)) {
-			prevsize = p->prev_size;
-			size += prevsize;
-			p = chunk_at_offset(p, -((long) prevsize));
-			unlink(p, bck, fwd);
-		}
-
-		if (nextchunk != av->top) {
-			/* get and clear inuse bit */
-			nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
-			set_head(nextchunk, nextsize);
-
-			/* consolidate forward */
-			if (!nextinuse) {
-				unlink(nextchunk, bck, fwd);
-				size += nextsize;
-			}
-
-			/*
-			  Place the chunk in unsorted chunk list. Chunks are
-			  not placed into regular bins until after they have
-			  been given one chance to be used in malloc.
-			*/
-
-			bck = unsorted_chunks(av);
-			fwd = bck->fd;
-			p->bk = bck;
-			p->fd = fwd;
-			bck->fd = p;
-			fwd->bk = p;
+	set_anychunks(av);
 
-			set_head(p, size | PREV_INUSE);
-			set_foot(p, size);
-
-			check_free_chunk(p);
-		}
-
-		/*
-		  If the chunk borders the current high end of memory,
-		  consolidate into top
-		*/
+	nextchunk = chunk_at_offset(p, size);
+	nextsize = chunksize(nextchunk);
 
-		else {
-			size += nextsize;
-			set_head(p, size | PREV_INUSE);
-			av->top = p;
-			check_chunk(p);
-		}
-
-		/*
-		  If freeing a large space, consolidate possibly-surrounding
-		  chunks. Then, if the total unused topmost memory exceeds trim
-		  threshold, ask malloc_trim to reduce top.
-
-		  Unless max_fast is 0, we don't know if there are fastbins
-		  bordering top, so we cannot tell for sure whether threshold
-		  has been reached unless fastbins are consolidated.  But we
-		  don't want to consolidate on each free.  As a compromise,
-		  consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD
-		  is reached.
-		*/
-
-		if ((unsigned long)(size) >= FASTBIN_CONSOLIDATION_THRESHOLD) {
-			if (have_fastchunks(av))
-				__malloc_consolidate(av);
-
-			if ((unsigned long)(chunksize(av->top)) >=
-				(unsigned long)(av->trim_threshold))
-				__malloc_trim(av->top_pad, av);
-		}
+	/* consolidate backward */
+	if (!prev_inuse(p)) {
+	    prevsize = p->prev_size;
+	    size += prevsize;
+	    p = chunk_at_offset(p, -((long) prevsize));
+	    unlink(p, bck, fwd);
+	}
+
+	if (nextchunk != av->top) {
+	    /* get and clear inuse bit */
+	    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
+	    set_head(nextchunk, nextsize);
+
+	    /* consolidate forward */
+	    if (!nextinuse) {
+		unlink(nextchunk, bck, fwd);
+		size += nextsize;
+	    }
+
+	    /*
+	       Place the chunk in unsorted chunk list. Chunks are
+	       not placed into regular bins until after they have
+	       been given one chance to be used in malloc.
+	       */
+
+	    bck = unsorted_chunks(av);
+	    fwd = bck->fd;
+	    p->bk = bck;
+	    p->fd = fwd;
+	    bck->fd = p;
+	    fwd->bk = p;
+
+	    set_head(p, size | PREV_INUSE);
+	    set_foot(p, size);
+
+	    check_free_chunk(p);
+	}
+
+	/*
+	   If the chunk borders the current high end of memory,
+	   consolidate into top
+	   */
+
+	else {
+	    size += nextsize;
+	    set_head(p, size | PREV_INUSE);
+	    av->top = p;
+	    check_chunk(p);
+	}
+
+	/*
+	   If freeing a large space, consolidate possibly-surrounding
+	   chunks. Then, if the total unused topmost memory exceeds trim
+	   threshold, ask malloc_trim to reduce top.
+
+	   Unless max_fast is 0, we don't know if there are fastbins
+	   bordering top, so we cannot tell for sure whether threshold
+	   has been reached unless fastbins are consolidated.  But we
+	   don't want to consolidate on each free.  As a compromise,
+	   consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD
+	   is reached.
+	   */
+
+	if ((unsigned long)(size) >= FASTBIN_CONSOLIDATION_THRESHOLD) {
+	    if (have_fastchunks(av))
+		__malloc_consolidate(av);
+
+	    if ((unsigned long)(chunksize(av->top)) >=
+		    (unsigned long)(av->trim_threshold))
+		__malloc_trim(av->top_pad, av);
+	}
 
     }
     /*
-	  If the chunk was allocated via mmap, release via munmap()
-	  Note that if HAVE_MMAP is false but chunk_is_mmapped is
-	  true, then user must have overwritten memory. There's nothing
-	  we can do to catch this error unless DEBUG is set, in which case
-	  check_inuse_chunk (above) will have triggered error.
-	*/
+       If the chunk was allocated via mmap, release via munmap()
+       Note that if HAVE_MMAP is false but chunk_is_mmapped is
+       true, then user must have overwritten memory. There's nothing
+       we can do to catch this error unless DEBUG is set, in which case
+       check_inuse_chunk (above) will have triggered error.
+       */
 
     else {
-		int ret;
-		size_t offset = p->prev_size;
-		av->n_mmaps--;
-		av->mmapped_mem -= (size + offset);
-		ret = munmap((char*)p - offset, size + offset);
-		/* munmap returns non-zero on failure */
-		assert(ret == 0);
+	int ret;
+	size_t offset = p->prev_size;
+	av->n_mmaps--;
+	av->mmapped_mem -= (size + offset);
+	ret = munmap((char*)p - offset, size + offset);
+	/* munmap returns non-zero on failure */
+	assert(ret == 0);
     }
     __MALLOC_UNLOCK;
 }
diff -urN a/libc/stdlib/malloc-standard/mallinfo.c b/libc/stdlib/malloc-standard/mallinfo.c
--- a/libc/stdlib/malloc-standard/mallinfo.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/stdlib/malloc-standard/mallinfo.c	2012-04-10 13:55:23.000000000 +0800
@@ -8,7 +8,7 @@
   VERSION 2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
 
   Note: There may be an updated version of this malloc obtainable at
-  ftp://gee.cs.oswego.edu/pub/misc/malloc.c
+           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
   Check before installing!
 
   Hacked up for uClibc by Erik Andersen <andersen@codepoet.org>
@@ -34,7 +34,7 @@
     av = get_malloc_state();
     /* Ensure initialization */
     if (av->top == 0)  {
-		__malloc_consolidate(av);
+	__malloc_consolidate(av);
     }
 
     check_malloc_state();
@@ -48,21 +48,21 @@
     fastavail = 0;
 
     for (i = 0; i < NFASTBINS; ++i) {
-		for (p = av->fastbins[i]; p != 0; p = p->fd) {
-			++nfastblocks;
-			fastavail += chunksize(p);
-		}
+	for (p = av->fastbins[i]; p != 0; p = p->fd) {
+	    ++nfastblocks;
+	    fastavail += chunksize(p);
+	}
     }
 
     avail += fastavail;
 
     /* traverse regular bins */
     for (i = 1; i < NBINS; ++i) {
-		b = bin_at(av, i);
-		for (p = last(b); p != b; p = p->bk) {
-			++nblocks;
-			avail += chunksize(p);
-		}
+	b = bin_at(av, i);
+	for (p = last(b); p != b; p = p->bk) {
+	    ++nblocks;
+	    avail += chunksize(p);
+	}
     }
 
     mi.smblks = nfastblocks;
@@ -84,7 +84,7 @@
     struct mallinfo mi;
 
     if (file==NULL) {
-		file = stderr;
+	file = stderr;
     }
 
     mi = mallinfo();
diff -urN a/libc/stdlib/malloc-standard/malloc.c b/libc/stdlib/malloc-standard/malloc.c
--- a/libc/stdlib/malloc-standard/malloc.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/stdlib/malloc-standard/malloc.c	2012-04-10 13:55:23.000000000 +0800
@@ -8,7 +8,7 @@
   VERSION 2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
 
   Note: There may be an updated version of this malloc obtainable at
-  ftp://gee.cs.oswego.edu/pub/misc/malloc.c
+           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
   Check before installing!
 
   Hacked up for uClibc by Erik Andersen <andersen@codepoet.org>
@@ -20,11 +20,11 @@
 __UCLIBC_MUTEX_INIT(__malloc_lock, PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);
 
 /*
-  There is exactly one instance of this struct in this malloc.
-  If you are adapting this malloc in a way that does NOT use a static
-  malloc_state, you MUST explicitly zero-fill it before using. This
-  malloc relies on the property that malloc_state is initialized to
-  all zeroes (as is true of C statics).
+   There is exactly one instance of this struct in this malloc.
+   If you are adapting this malloc in a way that does NOT use a static
+   malloc_state, you MUST explicitly zero-fill it before using. This
+   malloc relies on the property that malloc_state is initialized to
+   all zeroes (as is true of C statics).
 */
 struct malloc_state __malloc_state;  /* never directly referenced */
 
@@ -74,30 +74,30 @@
 
     if (!chunk_is_mmapped(p)) {
 
-		/* Has legal address ... */
-		if (p != av->top) {
-			if (contiguous(av)) {
-				assert(((char*)p) >= min_address);
-				assert(((char*)p + sz) <= ((char*)(av->top)));
-			}
-		}
-		else {
-			/* top size is always at least MINSIZE */
-			assert((unsigned long)(sz) >= MINSIZE);
-			/* top predecessor always marked inuse */
-			assert(prev_inuse(p));
-		}
+	/* Has legal address ... */
+	if (p != av->top) {
+	    if (contiguous(av)) {
+		assert(((char*)p) >= min_address);
+		assert(((char*)p + sz) <= ((char*)(av->top)));
+	    }
+	}
+	else {
+	    /* top size is always at least MINSIZE */
+	    assert((unsigned long)(sz) >= MINSIZE);
+	    /* top predecessor always marked inuse */
+	    assert(prev_inuse(p));
+	}
 
     }
     else {
-		/* address is outside main heap  */
-		if (contiguous(av) && av->top != initial_top(av)) {
-			assert(((char*)p) < min_address || ((char*)p) > max_address);
-		}
-		/* chunk is page-aligned */
-		assert(((p->prev_size + sz) & (av->pagesize-1)) == 0);
-		/* mem is aligned */
-		assert(aligned_OK(chunk2mem(p)));
+	/* address is outside main heap  */
+	if (contiguous(av) && av->top != initial_top(av)) {
+	    assert(((char*)p) < min_address || ((char*)p) > max_address);
+	}
+	/* chunk is page-aligned */
+	assert(((p->prev_size + sz) & (av->pagesize-1)) == 0);
+	/* mem is aligned */
+	assert(aligned_OK(chunk2mem(p)));
     }
 }
 
@@ -118,21 +118,21 @@
 
     /* Unless a special marker, must have OK fields */
     if ((unsigned long)(sz) >= MINSIZE)
-		{
-			assert((sz & MALLOC_ALIGN_MASK) == 0);
-			assert(aligned_OK(chunk2mem(p)));
-			/* ... matching footer field */
-			assert(next->prev_size == sz);
-			/* ... and is fully consolidated */
-			assert(prev_inuse(p));
-			assert (next == av->top || inuse(next));
-
-			/* ... and has minimally sane links */
-			assert(p->fd->bk == p);
-			assert(p->bk->fd == p);
-		}
+    {
+	assert((sz & MALLOC_ALIGN_MASK) == 0);
+	assert(aligned_OK(chunk2mem(p)));
+	/* ... matching footer field */
+	assert(next->prev_size == sz);
+	/* ... and is fully consolidated */
+	assert(prev_inuse(p));
+	assert (next == av->top || inuse(next));
+
+	/* ... and has minimally sane links */
+	assert(p->fd->bk == p);
+	assert(p->bk->fd == p);
+    }
     else /* markers are always of size (sizeof(size_t)) */
-		assert(sz == (sizeof(size_t)));
+	assert(sz == (sizeof(size_t)));
 }
 
 /* Properties of inuse chunks */
@@ -143,7 +143,7 @@
     __do_check_chunk(p);
 
     if (chunk_is_mmapped(p))
-		return; /* mmapped chunks have no next/prev */
+	return; /* mmapped chunks have no next/prev */
 
     /* Check whether it claims to be in use ... */
     assert(inuse(p));
@@ -153,20 +153,20 @@
     /* ... and is surrounded by OK chunks.
        Since more things can be checked with free chunks than inuse ones,
        if an inuse chunk borders them and debug is on, it's worth doing them.
-	*/
+       */
     if (!prev_inuse(p))  {
-		/* Note that we cannot even look at prev unless it is not inuse */
-		mchunkptr prv = prev_chunk(p);
-		assert(next_chunk(prv) == p);
-		__do_check_free_chunk(prv);
+	/* Note that we cannot even look at prev unless it is not inuse */
+	mchunkptr prv = prev_chunk(p);
+	assert(next_chunk(prv) == p);
+	__do_check_free_chunk(prv);
     }
 
     if (next == av->top) {
-		assert(prev_inuse(next));
-		assert(chunksize(next) >= MINSIZE);
+	assert(prev_inuse(next));
+	assert(chunksize(next) >= MINSIZE);
     }
     else if (!inuse(next))
-		__do_check_free_chunk(next);
+	__do_check_free_chunk(next);
 }
 
 /* Properties of chunks recycled from fastbins */
@@ -195,14 +195,14 @@
     __do_check_remalloced_chunk(p, s);
 
     /*
-	  ... plus,  must obey implementation invariant that prev_inuse is
-	  always true of any allocated chunk; i.e., that each allocated
-	  chunk borders either a previously allocated and still in-use
-	  chunk, or the base of its memory arena. This is ensured
-	  by making all allocations from the the `lowest' part of any found
-	  chunk.  This does not necessarily hold however for chunks
-	  recycled via fastbins.
-	*/
+       ... plus,  must obey implementation invariant that prev_inuse is
+       always true of any allocated chunk; i.e., that each allocated
+       chunk borders either a previously allocated and still in-use
+       chunk, or the base of its memory arena. This is ensured
+       by making all allocations from the the `lowest' part of any found
+       chunk.  This does not necessarily hold however for chunks
+       recycled via fastbins.
+       */
 
     assert(prev_inuse(p));
 }
@@ -240,7 +240,7 @@
 
     /* cannot run remaining checks until fully initialized */
     if (av->top == 0 || av->top == initial_top(av))
-		return;
+	return;
 
     /* pagesize is a power of 2 */
     assert((av->pagesize & (av->pagesize-1)) == 0);
@@ -253,64 +253,64 @@
     max_fast_bin = fastbin_index(av->max_fast);
 
     for (i = 0; i < NFASTBINS; ++i) {
-		p = av->fastbins[i];
+	p = av->fastbins[i];
 
-		/* all bins past max_fast are empty */
-		if (i > max_fast_bin)
-			assert(p == 0);
-
-		while (p != 0) {
-			/* each chunk claims to be inuse */
-			__do_check_inuse_chunk(p);
-			total += chunksize(p);
-			/* chunk belongs in this bin */
-			assert(fastbin_index(chunksize(p)) == i);
-			p = p->fd;
-		}
+	/* all bins past max_fast are empty */
+	if (i > max_fast_bin)
+	    assert(p == 0);
+
+	while (p != 0) {
+	    /* each chunk claims to be inuse */
+	    __do_check_inuse_chunk(p);
+	    total += chunksize(p);
+	    /* chunk belongs in this bin */
+	    assert(fastbin_index(chunksize(p)) == i);
+	    p = p->fd;
+	}
     }
 
     if (total != 0)
-		assert(have_fastchunks(av));
+	assert(have_fastchunks(av));
     else if (!have_fastchunks(av))
-		assert(total == 0);
+	assert(total == 0);
 
     /* check normal bins */
     for (i = 1; i < NBINS; ++i) {
-		b = bin_at(av,i);
-
-		/* binmap is accurate (except for bin 1 == unsorted_chunks) */
-		if (i >= 2) {
-			binbit = get_binmap(av,i);
-			empty = last(b) == b;
-			if (!binbit)
-				assert(empty);
-			else if (!empty)
-				assert(binbit);
-		}
+	b = bin_at(av,i);
 
-		for (p = last(b); p != b; p = p->bk) {
-			/* each chunk claims to be free */
-			__do_check_free_chunk(p);
-			size = chunksize(p);
-			total += size;
-			if (i >= 2) {
-				/* chunk belongs in bin */
-				idx = bin_index(size);
-				assert(idx == i);
-				/* lists are sorted */
-				if ((unsigned long) size >= (unsigned long)(FIRST_SORTED_BIN_SIZE)) {
-					assert(p->bk == b ||
-						   (unsigned long)chunksize(p->bk) >=
-						   (unsigned long)chunksize(p));
-				}
-			}
-			/* chunk is followed by a legal chain of inuse chunks */
-			for (q = next_chunk(p);
-				 (q != av->top && inuse(q) &&
-				  (unsigned long)(chunksize(q)) >= MINSIZE);
-				 q = next_chunk(q))
-				__do_check_inuse_chunk(q);
-		}
+	/* binmap is accurate (except for bin 1 == unsorted_chunks) */
+	if (i >= 2) {
+	    binbit = get_binmap(av,i);
+	    empty = last(b) == b;
+	    if (!binbit)
+		assert(empty);
+	    else if (!empty)
+		assert(binbit);
+	}
+
+	for (p = last(b); p != b; p = p->bk) {
+	    /* each chunk claims to be free */
+	    __do_check_free_chunk(p);
+	    size = chunksize(p);
+	    total += size;
+	    if (i >= 2) {
+		/* chunk belongs in bin */
+		idx = bin_index(size);
+		assert(idx == i);
+		/* lists are sorted */
+		if ((unsigned long) size >= (unsigned long)(FIRST_SORTED_BIN_SIZE)) {
+		    assert(p->bk == b ||
+			    (unsigned long)chunksize(p->bk) >=
+			    (unsigned long)chunksize(p));
+		}
+	    }
+	    /* chunk is followed by a legal chain of inuse chunks */
+	    for (q = next_chunk(p);
+		    (q != av->top && inuse(q) &&
+		     (unsigned long)(chunksize(q)) >= MINSIZE);
+		    q = next_chunk(q))
+		__do_check_inuse_chunk(q);
+	}
     }
 
     /* top chunk is OK */
@@ -323,13 +323,13 @@
     assert(av->n_mmaps <= av->max_n_mmaps);
 
     assert((unsigned long)(av->sbrked_mem) <=
-		   (unsigned long)(av->max_sbrked_mem));
+	    (unsigned long)(av->max_sbrked_mem));
 
     assert((unsigned long)(av->mmapped_mem) <=
-		   (unsigned long)(av->max_mmapped_mem));
+	    (unsigned long)(av->max_mmapped_mem));
 
     assert((unsigned long)(av->max_total_mem) >=
-		   (unsigned long)(av->mmapped_mem) + (unsigned long)(av->sbrked_mem));
+	    (unsigned long)(av->mmapped_mem) + (unsigned long)(av->sbrked_mem));
 }
 #endif
 
@@ -367,84 +367,84 @@
     size_t          pagemask  = av->pagesize - 1;
 
     /*
-	  If there is space available in fastbins, consolidate and retry
-	  malloc from scratch rather than getting memory from system.  This
-	  can occur only if nb is in smallbin range so we didn't consolidate
-	  upon entry to malloc. It is much easier to handle this case here
-	  than in malloc proper.
-	*/
+       If there is space available in fastbins, consolidate and retry
+       malloc from scratch rather than getting memory from system.  This
+       can occur only if nb is in smallbin range so we didn't consolidate
+       upon entry to malloc. It is much easier to handle this case here
+       than in malloc proper.
+       */
 
     if (have_fastchunks(av)) {
-		assert(in_smallbin_range(nb));
-		__malloc_consolidate(av);
-		return malloc(nb - MALLOC_ALIGN_MASK);
+	assert(in_smallbin_range(nb));
+	__malloc_consolidate(av);
+	return malloc(nb - MALLOC_ALIGN_MASK);
     }
 
 
     /*
-	  If have mmap, and the request size meets the mmap threshold, and
-	  the system supports mmap, and there are few enough currently
-	  allocated mmapped regions, try to directly map this request
-	  rather than expanding top.
-	*/
+       If have mmap, and the request size meets the mmap threshold, and
+       the system supports mmap, and there are few enough currently
+       allocated mmapped regions, try to directly map this request
+       rather than expanding top.
+       */
 
     if ((unsigned long)(nb) >= (unsigned long)(av->mmap_threshold) &&
 	    (av->n_mmaps < av->n_mmaps_max)) {
 
-		char* mm;             /* return value from mmap call*/
+	char* mm;             /* return value from mmap call*/
 
-		/*
-		  Round up size to nearest page.  For mmapped chunks, the overhead
-		  is one (sizeof(size_t)) unit larger than for normal chunks, because there
-		  is no following chunk whose prev_size field could be used.
-		*/
-		size = (nb + (sizeof(size_t)) + MALLOC_ALIGN_MASK + pagemask) & ~pagemask;
-
-		/* Don't try if size wraps around 0 */
-		if ((unsigned long)(size) > (unsigned long)(nb)) {
-
-			mm = (char*)(MMAP(0, size, PROT_READ|PROT_WRITE));
-
-			if (mm != (char*)(MORECORE_FAILURE)) {
-
-				/*
-				  The offset to the start of the mmapped region is stored
-				  in the prev_size field of the chunk. This allows us to adjust
-				  returned start address to meet alignment requirements here
-				  and in memalign(), and still be able to compute proper
-				  address argument for later munmap in free() and realloc().
-				*/
-
-				front_misalign = (size_t)chunk2mem(mm) & MALLOC_ALIGN_MASK;
-				if (front_misalign > 0) {
-					correction = MALLOC_ALIGNMENT - front_misalign;
-					p = (mchunkptr)(mm + correction);
-					p->prev_size = correction;
-					set_head(p, (size - correction) |IS_MMAPPED);
-				}
-				else {
-					p = (mchunkptr)mm;
-					p->prev_size = 0;
-					set_head(p, size|IS_MMAPPED);
-				}
-
-				/* update statistics */
-
-				if (++av->n_mmaps > av->max_n_mmaps)
-					av->max_n_mmaps = av->n_mmaps;
-
-				sum = av->mmapped_mem += size;
-				if (sum > (unsigned long)(av->max_mmapped_mem))
-					av->max_mmapped_mem = sum;
-				sum += av->sbrked_mem;
-				if (sum > (unsigned long)(av->max_total_mem))
-					av->max_total_mem = sum;
+	/*
+	   Round up size to nearest page.  For mmapped chunks, the overhead
+	   is one (sizeof(size_t)) unit larger than for normal chunks, because there
+	   is no following chunk whose prev_size field could be used.
+	   */
+	size = (nb + (sizeof(size_t)) + MALLOC_ALIGN_MASK + pagemask) & ~pagemask;
+
+	/* Don't try if size wraps around 0 */
+	if ((unsigned long)(size) > (unsigned long)(nb)) {
 
-				check_chunk(p);
+	    mm = (char*)(MMAP(0, size, PROT_READ|PROT_WRITE));
 
-				return chunk2mem(p);
-			}
+	    if (mm != (char*)(MORECORE_FAILURE)) {
+
+		/*
+		   The offset to the start of the mmapped region is stored
+		   in the prev_size field of the chunk. This allows us to adjust
+		   returned start address to meet alignment requirements here
+		   and in memalign(), and still be able to compute proper
+		   address argument for later munmap in free() and realloc().
+		   */
+
+		front_misalign = (size_t)chunk2mem(mm) & MALLOC_ALIGN_MASK;
+		if (front_misalign > 0) {
+		    correction = MALLOC_ALIGNMENT - front_misalign;
+		    p = (mchunkptr)(mm + correction);
+		    p->prev_size = correction;
+		    set_head(p, (size - correction) |IS_MMAPPED);
 		}
+		else {
+		    p = (mchunkptr)mm;
+		    p->prev_size = 0;
+		    set_head(p, size|IS_MMAPPED);
+		}
+
+		/* update statistics */
+
+		if (++av->n_mmaps > av->max_n_mmaps)
+		    av->max_n_mmaps = av->n_mmaps;
+
+		sum = av->mmapped_mem += size;
+		if (sum > (unsigned long)(av->max_mmapped_mem))
+		    av->max_mmapped_mem = sum;
+		sum += av->sbrked_mem;
+		if (sum > (unsigned long)(av->max_total_mem))
+		    av->max_total_mem = sum;
+
+		check_chunk(p);
+
+		return chunk2mem(p);
+	    }
+	}
     }
 
     /* Record incoming configuration of top */
@@ -459,8 +459,8 @@
      * be at least MINSIZE and to have prev_inuse set.  */
 
     assert((old_top == initial_top(av) && old_size == 0) ||
-		   ((unsigned long) (old_size) >= MINSIZE &&
-			prev_inuse(old_top)));
+	    ((unsigned long) (old_size) >= MINSIZE &&
+	     prev_inuse(old_top)));
 
     /* Precondition: not enough current space to satisfy nb request */
     assert((unsigned long)(old_size) < (unsigned long)(nb + MINSIZE));
@@ -474,272 +474,272 @@
     size = nb + av->top_pad + MINSIZE;
 
     /*
-	  If contiguous, we can subtract out existing space that we hope to
-	  combine with new space. We add it back later only if
-	  we don't actually get contiguous space.
-	*/
+       If contiguous, we can subtract out existing space that we hope to
+       combine with new space. We add it back later only if
+       we don't actually get contiguous space.
+       */
 
     if (contiguous(av))
-		size -= old_size;
+	size -= old_size;
 
     /*
-	  Round to a multiple of page size.
-	  If MORECORE is not contiguous, this ensures that we only call it
-	  with whole-page arguments.  And if MORECORE is contiguous and
-	  this is not first time through, this preserves page-alignment of
-	  previous calls. Otherwise, we correct to page-align below.
-	*/
+       Round to a multiple of page size.
+       If MORECORE is not contiguous, this ensures that we only call it
+       with whole-page arguments.  And if MORECORE is contiguous and
+       this is not first time through, this preserves page-alignment of
+       previous calls. Otherwise, we correct to page-align below.
+       */
 
     size = (size + pagemask) & ~pagemask;
 
     /*
-	  Don't try to call MORECORE if argument is so big as to appear
-	  negative. Note that since mmap takes size_t arg, it may succeed
-	  below even if we cannot call MORECORE.
-	*/
+       Don't try to call MORECORE if argument is so big as to appear
+       negative. Note that since mmap takes size_t arg, it may succeed
+       below even if we cannot call MORECORE.
+       */
 
     if (size > 0)
-		brk = (char*)(MORECORE(size));
+	brk = (char*)(MORECORE(size));
 
     /*
-	  If have mmap, try using it as a backup when MORECORE fails or
-	  cannot be used. This is worth doing on systems that have "holes" in
-	  address space, so sbrk cannot extend to give contiguous space, but
-	  space is available elsewhere.  Note that we ignore mmap max count
-	  and threshold limits, since the space will not be used as a
-	  segregated mmap region.
-	*/
+       If have mmap, try using it as a backup when MORECORE fails or
+       cannot be used. This is worth doing on systems that have "holes" in
+       address space, so sbrk cannot extend to give contiguous space, but
+       space is available elsewhere.  Note that we ignore mmap max count
+       and threshold limits, since the space will not be used as a
+       segregated mmap region.
+       */
 
     if (brk == (char*)(MORECORE_FAILURE)) {
 
-		/* Cannot merge with old top, so add its size back in */
-		if (contiguous(av))
-			size = (size + old_size + pagemask) & ~pagemask;
-
-		/* If we are relying on mmap as backup, then use larger units */
-		if ((unsigned long)(size) < (unsigned long)(MMAP_AS_MORECORE_SIZE))
-			size = MMAP_AS_MORECORE_SIZE;
-
-		/* Don't try if size wraps around 0 */
-		if ((unsigned long)(size) > (unsigned long)(nb)) {
-
-			brk = (char*)(MMAP(0, size, PROT_READ|PROT_WRITE));
-
-			if (brk != (char*)(MORECORE_FAILURE)) {
-
-				/* We do not need, and cannot use, another sbrk call to find end */
-				snd_brk = brk + size;
-
-				/* Record that we no longer have a contiguous sbrk region.
-				   After the first time mmap is used as backup, we do not
-				   ever rely on contiguous space since this could incorrectly
-				   bridge regions.
-				*/
-				set_noncontiguous(av);
-			}
-		}
+	/* Cannot merge with old top, so add its size back in */
+	if (contiguous(av))
+	    size = (size + old_size + pagemask) & ~pagemask;
+
+	/* If we are relying on mmap as backup, then use larger units */
+	if ((unsigned long)(size) < (unsigned long)(MMAP_AS_MORECORE_SIZE))
+	    size = MMAP_AS_MORECORE_SIZE;
+
+	/* Don't try if size wraps around 0 */
+	if ((unsigned long)(size) > (unsigned long)(nb)) {
+
+	    brk = (char*)(MMAP(0, size, PROT_READ|PROT_WRITE));
+
+	    if (brk != (char*)(MORECORE_FAILURE)) {
+
+		/* We do not need, and cannot use, another sbrk call to find end */
+		snd_brk = brk + size;
+
+		/* Record that we no longer have a contiguous sbrk region.
+		   After the first time mmap is used as backup, we do not
+		   ever rely on contiguous space since this could incorrectly
+		   bridge regions.
+		   */
+		set_noncontiguous(av);
+	    }
+	}
     }
 
     if (brk != (char*)(MORECORE_FAILURE)) {
-		av->sbrked_mem += size;
+	av->sbrked_mem += size;
 
-		/*
-		  If MORECORE extends previous space, we can likewise extend top size.
-		*/
+	/*
+	   If MORECORE extends previous space, we can likewise extend top size.
+	   */
+
+	if (brk == old_end && snd_brk == (char*)(MORECORE_FAILURE)) {
+	    set_head(old_top, (size + old_size) | PREV_INUSE);
+	}
+
+	/*
+	   Otherwise, make adjustments:
+
+	 * If the first time through or noncontiguous, we need to call sbrk
+	 just to find out where the end of memory lies.
+
+	 * We need to ensure that all returned chunks from malloc will meet
+	 MALLOC_ALIGNMENT
+
+	 * If there was an intervening foreign sbrk, we need to adjust sbrk
+	 request size to account for fact that we will not be able to
+	 combine new space with existing space in old_top.
+
+	 * Almost all systems internally allocate whole pages at a time, in
+	 which case we might as well use the whole last page of request.
+	 So we allocate enough more memory to hit a page boundary now,
+	 which in turn causes future contiguous calls to page-align.
+	 */
+
+	else {
+	    front_misalign = 0;
+	    end_misalign = 0;
+	    correction = 0;
+	    aligned_brk = brk;
+
+	    /*
+	       If MORECORE returns an address lower than we have seen before,
+	       we know it isn't really contiguous.  This and some subsequent
+	       checks help cope with non-conforming MORECORE functions and
+	       the presence of "foreign" calls to MORECORE from outside of
+	       malloc or by other threads.  We cannot guarantee to detect
+	       these in all cases, but cope with the ones we do detect.
+	       */
+	    if (contiguous(av) && old_size != 0 && brk < old_end) {
+		set_noncontiguous(av);
+	    }
+
+	    /* handle contiguous cases */
+	    if (contiguous(av)) {
+
+		/* We can tolerate forward non-contiguities here (usually due
+		   to foreign calls) but treat them as part of our space for
+		   stats reporting.  */
+		if (old_size != 0)
+		    av->sbrked_mem += brk - old_end;
+
+		/* Guarantee alignment of first new chunk made from this space */
+
+		front_misalign = (size_t)chunk2mem(brk) & MALLOC_ALIGN_MASK;
+		if (front_misalign > 0) {
+
+		    /*
+		       Skip over some bytes to arrive at an aligned position.
+		       We don't need to specially mark these wasted front bytes.
+		       They will never be accessed anyway because
+		       prev_inuse of av->top (and any chunk created from its start)
+		       is always true after initialization.
+		       */
 
-		if (brk == old_end && snd_brk == (char*)(MORECORE_FAILURE)) {
-			set_head(old_top, (size + old_size) | PREV_INUSE);
+		    correction = MALLOC_ALIGNMENT - front_misalign;
+		    aligned_brk += correction;
 		}
 
 		/*
-		  Otherwise, make adjustments:
-
-		  * If the first time through or noncontiguous, we need to call sbrk
-		  just to find out where the end of memory lies.
-
-		  * We need to ensure that all returned chunks from malloc will meet
-		  MALLOC_ALIGNMENT
-
-		  * If there was an intervening foreign sbrk, we need to adjust sbrk
-		  request size to account for fact that we will not be able to
-		  combine new space with existing space in old_top.
-
-		  * Almost all systems internally allocate whole pages at a time, in
-		  which case we might as well use the whole last page of request.
-		  So we allocate enough more memory to hit a page boundary now,
-		  which in turn causes future contiguous calls to page-align.
-		*/
-
-		else {
-			front_misalign = 0;
-			end_misalign = 0;
-			correction = 0;
-			aligned_brk = brk;
-
-			/*
-			  If MORECORE returns an address lower than we have seen before,
-			  we know it isn't really contiguous.  This and some subsequent
-			  checks help cope with non-conforming MORECORE functions and
-			  the presence of "foreign" calls to MORECORE from outside of
-			  malloc or by other threads.  We cannot guarantee to detect
-			  these in all cases, but cope with the ones we do detect.
-			*/
-			if (contiguous(av) && old_size != 0 && brk < old_end) {
-				set_noncontiguous(av);
-			}
-
-			/* handle contiguous cases */
-			if (contiguous(av)) {
-
-				/* We can tolerate forward non-contiguities here (usually due
-				   to foreign calls) but treat them as part of our space for
-				   stats reporting.  */
-				if (old_size != 0)
-					av->sbrked_mem += brk - old_end;
-
-				/* Guarantee alignment of first new chunk made from this space */
-
-				front_misalign = (size_t)chunk2mem(brk) & MALLOC_ALIGN_MASK;
-				if (front_misalign > 0) {
-
-					/*
-					  Skip over some bytes to arrive at an aligned position.
-					  We don't need to specially mark these wasted front bytes.
-					  They will never be accessed anyway because
-					  prev_inuse of av->top (and any chunk created from its start)
-					  is always true after initialization.
-					*/
-
-					correction = MALLOC_ALIGNMENT - front_misalign;
-					aligned_brk += correction;
-				}
-
-				/*
-				  If this isn't adjacent to existing space, then we will not
-				  be able to merge with old_top space, so must add to 2nd request.
-				*/
-
-				correction += old_size;
-
-				/* Extend the end address to hit a page boundary */
-				end_misalign = (size_t)(brk + size + correction);
-				correction += ((end_misalign + pagemask) & ~pagemask) - end_misalign;
-
-				assert(correction >= 0);
-				snd_brk = (char*)(MORECORE(correction));
-
-				if (snd_brk == (char*)(MORECORE_FAILURE)) {
-					/*
-					  If can't allocate correction, try to at least find out current
-					  brk.  It might be enough to proceed without failing.
-					*/
-					correction = 0;
-					snd_brk = (char*)(MORECORE(0));
-				}
-				else if (snd_brk < brk) {
-					/*
-					  If the second call gives noncontiguous space even though
-					  it says it won't, the only course of action is to ignore
-					  results of second call, and conservatively estimate where
-					  the first call left us. Also set noncontiguous, so this
-					  won't happen again, leaving at most one hole.
-
-					  Note that this check is intrinsically incomplete.  Because
-					  MORECORE is allowed to give more space than we ask for,
-					  there is no reliable way to detect a noncontiguity
-					  producing a forward gap for the second call.
-					*/
-					snd_brk = brk + size;
-					correction = 0;
-					set_noncontiguous(av);
-				}
-
-			}
-
-			/* handle non-contiguous cases */
-			else {
-				/* MORECORE/mmap must correctly align */
-				assert(aligned_OK(chunk2mem(brk)));
-
-				/* Find out current end of memory */
-				if (snd_brk == (char*)(MORECORE_FAILURE)) {
-					snd_brk = (char*)(MORECORE(0));
-					av->sbrked_mem += snd_brk - brk - size;
-				}
-			}
-
-			/* Adjust top based on results of second sbrk */
-			if (snd_brk != (char*)(MORECORE_FAILURE)) {
-				av->top = (mchunkptr)aligned_brk;
-				set_head(av->top, (snd_brk - aligned_brk + correction) | PREV_INUSE);
-				av->sbrked_mem += correction;
-
-				/*
-				  If not the first time through, we either have a
-				  gap due to foreign sbrk or a non-contiguous region.  Insert a
-				  double fencepost at old_top to prevent consolidation with space
-				  we don't own. These fenceposts are artificial chunks that are
-				  marked as inuse and are in any case too small to use.  We need
-				  two to make sizes and alignments work out.
-				*/
-
-				if (old_size != 0) {
-					/* Shrink old_top to insert fenceposts, keeping size a
-					   multiple of MALLOC_ALIGNMENT. We know there is at least
-					   enough space in old_top to do this.
-					*/
-					old_size = (old_size - 3*(sizeof(size_t))) & ~MALLOC_ALIGN_MASK;
-					set_head(old_top, old_size | PREV_INUSE);
-
-					/*
-					  Note that the following assignments completely overwrite
-					  old_top when old_size was previously MINSIZE.  This is
-					  intentional. We need the fencepost, even if old_top otherwise gets
-					  lost.
-					*/
-					chunk_at_offset(old_top, old_size          )->size =
-						(sizeof(size_t))|PREV_INUSE;
-
-					chunk_at_offset(old_top, old_size + (sizeof(size_t)))->size =
-						(sizeof(size_t))|PREV_INUSE;
-
-					/* If possible, release the rest, suppressing trimming.  */
-					if (old_size >= MINSIZE) {
-						size_t tt = av->trim_threshold;
-						av->trim_threshold = (size_t)(-1);
-						free(chunk2mem(old_top));
-						av->trim_threshold = tt;
-					}
-				}
-			}
-		}
-
-		/* Update statistics */
-		sum = av->sbrked_mem;
-		if (sum > (unsigned long)(av->max_sbrked_mem))
-			av->max_sbrked_mem = sum;
-
-		sum += av->mmapped_mem;
-		if (sum > (unsigned long)(av->max_total_mem))
-			av->max_total_mem = sum;
-
-		check_malloc_state();
+		   If this isn't adjacent to existing space, then we will not
+		   be able to merge with old_top space, so must add to 2nd request.
+		   */
+
+		correction += old_size;
+
+		/* Extend the end address to hit a page boundary */
+		end_misalign = (size_t)(brk + size + correction);
+		correction += ((end_misalign + pagemask) & ~pagemask) - end_misalign;
+
+		assert(correction >= 0);
+		snd_brk = (char*)(MORECORE(correction));
+
+		if (snd_brk == (char*)(MORECORE_FAILURE)) {
+		    /*
+		       If can't allocate correction, try to at least find out current
+		       brk.  It might be enough to proceed without failing.
+		       */
+		    correction = 0;
+		    snd_brk = (char*)(MORECORE(0));
+		}
+		else if (snd_brk < brk) {
+		    /*
+		       If the second call gives noncontiguous space even though
+		       it says it won't, the only course of action is to ignore
+		       results of second call, and conservatively estimate where
+		       the first call left us. Also set noncontiguous, so this
+		       won't happen again, leaving at most one hole.
+
+		       Note that this check is intrinsically incomplete.  Because
+		       MORECORE is allowed to give more space than we ask for,
+		       there is no reliable way to detect a noncontiguity
+		       producing a forward gap for the second call.
+		       */
+		    snd_brk = brk + size;
+		    correction = 0;
+		    set_noncontiguous(av);
+		}
+
+	    }
+
+	    /* handle non-contiguous cases */
+	    else {
+		/* MORECORE/mmap must correctly align */
+		assert(aligned_OK(chunk2mem(brk)));
+
+		/* Find out current end of memory */
+		if (snd_brk == (char*)(MORECORE_FAILURE)) {
+		    snd_brk = (char*)(MORECORE(0));
+		    av->sbrked_mem += snd_brk - brk - size;
+		}
+	    }
+
+	    /* Adjust top based on results of second sbrk */
+	    if (snd_brk != (char*)(MORECORE_FAILURE)) {
+		av->top = (mchunkptr)aligned_brk;
+		set_head(av->top, (snd_brk - aligned_brk + correction) | PREV_INUSE);
+		av->sbrked_mem += correction;
 
-		/* finally, do the allocation */
-
-		p = av->top;
-		size = chunksize(p);
-
-		/* check that one of the above allocation paths succeeded */
-		if ((unsigned long)(size) >= (unsigned long)(nb + MINSIZE)) {
-			remainder_size = size - nb;
-			remainder = chunk_at_offset(p, nb);
-			av->top = remainder;
-			set_head(p, nb | PREV_INUSE);
-			set_head(remainder, remainder_size | PREV_INUSE);
-			check_malloced_chunk(p, nb);
-			return chunk2mem(p);
-		}
+		/*
+		   If not the first time through, we either have a
+		   gap due to foreign sbrk or a non-contiguous region.  Insert a
+		   double fencepost at old_top to prevent consolidation with space
+		   we don't own. These fenceposts are artificial chunks that are
+		   marked as inuse and are in any case too small to use.  We need
+		   two to make sizes and alignments work out.
+		   */
+
+		if (old_size != 0) {
+		    /* Shrink old_top to insert fenceposts, keeping size a
+		       multiple of MALLOC_ALIGNMENT. We know there is at least
+		       enough space in old_top to do this.
+		       */
+		    old_size = (old_size - 3*(sizeof(size_t))) & ~MALLOC_ALIGN_MASK;
+		    set_head(old_top, old_size | PREV_INUSE);
+
+		    /*
+		       Note that the following assignments completely overwrite
+		       old_top when old_size was previously MINSIZE.  This is
+		       intentional. We need the fencepost, even if old_top otherwise gets
+		       lost.
+		       */
+		    chunk_at_offset(old_top, old_size          )->size =
+			(sizeof(size_t))|PREV_INUSE;
+
+		    chunk_at_offset(old_top, old_size + (sizeof(size_t)))->size =
+			(sizeof(size_t))|PREV_INUSE;
+
+		    /* If possible, release the rest, suppressing trimming.  */
+		    if (old_size >= MINSIZE) {
+			size_t tt = av->trim_threshold;
+			av->trim_threshold = (size_t)(-1);
+			free(chunk2mem(old_top));
+			av->trim_threshold = tt;
+		    }
+		}
+	    }
+	}
+
+	/* Update statistics */
+	sum = av->sbrked_mem;
+	if (sum > (unsigned long)(av->max_sbrked_mem))
+	    av->max_sbrked_mem = sum;
+
+	sum += av->mmapped_mem;
+	if (sum > (unsigned long)(av->max_total_mem))
+	    av->max_total_mem = sum;
+
+	check_malloc_state();
+
+	/* finally, do the allocation */
+
+	p = av->top;
+	size = chunksize(p);
+
+	/* check that one of the above allocation paths succeeded */
+	if ((unsigned long)(size) >= (unsigned long)(nb + MINSIZE)) {
+	    remainder_size = size - nb;
+	    remainder = chunk_at_offset(p, nb);
+	    av->top = remainder;
+	    set_head(p, nb | PREV_INUSE);
+	    set_head(remainder, remainder_size | PREV_INUSE);
+	    check_malloced_chunk(p, nb);
+	    return chunk2mem(p);
+	}
 
     }
 
@@ -764,25 +764,25 @@
 #if defined(__GNUC__) && defined(i386)
 
     __asm__("bsrl %1,%0\n\t"
-			: "=r" (m)
-			: "g"  (x));
+	    : "=r" (m)
+	    : "g"  (x));
 
 #else
     {
-		/*
-		  Based on branch-free nlz algorithm in chapter 5 of Henry
-		  S. Warren Jr's book "Hacker's Delight".
-		*/
-
-		unsigned int n = ((x - 0x100) >> 16) & 8;
-		x <<= n;
-		m = ((x - 0x1000) >> 16) & 4;
-		n += m;
-		x <<= m;
-		m = ((x - 0x4000) >> 16) & 2;
-		n += m;
-		x = (x << m) >> 14;
-		m = 13 - n + (x & ~(x>>1));
+	/*
+	   Based on branch-free nlz algorithm in chapter 5 of Henry
+	   S. Warren Jr's book "Hacker's Delight".
+	   */
+
+	unsigned int n = ((x - 0x100) >> 16) & 8;
+	x <<= n;
+	m = ((x - 0x1000) >> 16) & 4;
+	n += m;
+	x <<= m;
+	m = ((x - 0x4000) >> 16) & 2;
+	n += m;
+	x = (x << m) >> 14;
+	m = 13 - n + (x & ~(x>>1));
     }
 #endif
 
@@ -832,61 +832,61 @@
     __MALLOC_LOCK;
     av = get_malloc_state();
     /*
-	  Convert request size to internal form by adding (sizeof(size_t)) bytes
-	  overhead plus possibly more to obtain necessary alignment and/or
-	  to obtain a size of at least MINSIZE, the smallest allocatable
-	  size. Also, checked_request2size traps (returning 0) request sizes
-	  that are so large that they wrap around zero when padded and
-	  aligned.
-	*/
+       Convert request size to internal form by adding (sizeof(size_t)) bytes
+       overhead plus possibly more to obtain necessary alignment and/or
+       to obtain a size of at least MINSIZE, the smallest allocatable
+       size. Also, checked_request2size traps (returning 0) request sizes
+       that are so large that they wrap around zero when padded and
+       aligned.
+       */
 
     checked_request2size(bytes, nb);
 
     /*
-	  Bypass search if no frees yet
-	*/
+       Bypass search if no frees yet
+       */
     if (!have_anychunks(av)) {
-		if (av->max_fast == 0) /* initialization check */
-			__malloc_consolidate(av);
-		goto use_top;
+	if (av->max_fast == 0) /* initialization check */
+	    __malloc_consolidate(av);
+	goto use_top;
     }
 
     /*
-	  If the size qualifies as a fastbin, first check corresponding bin.
-	*/
+       If the size qualifies as a fastbin, first check corresponding bin.
+       */
 
     if ((unsigned long)(nb) <= (unsigned long)(av->max_fast)) {
-		fb = &(av->fastbins[(fastbin_index(nb))]);
-		if ( (victim = *fb) != 0) {
-			*fb = victim->fd;
-			check_remalloced_chunk(victim, nb);
+	fb = &(av->fastbins[(fastbin_index(nb))]);
+	if ( (victim = *fb) != 0) {
+	    *fb = victim->fd;
+	    check_remalloced_chunk(victim, nb);
 			retval = chunk2mem(victim);
 			goto DONE;
-		}
+	}
     }
 
     /*
-	  If a small request, check regular bin.  Since these "smallbins"
-	  hold one size each, no searching within bins is necessary.
-	  (For a large request, we need to wait until unsorted chunks are
-	  processed to find best fit. But for small ones, fits are exact
-	  anyway, so we can check now, which is faster.)
-	*/
+       If a small request, check regular bin.  Since these "smallbins"
+       hold one size each, no searching within bins is necessary.
+       (For a large request, we need to wait until unsorted chunks are
+       processed to find best fit. But for small ones, fits are exact
+       anyway, so we can check now, which is faster.)
+       */
 
     if (in_smallbin_range(nb)) {
-		idx = smallbin_index(nb);
-		bin = bin_at(av,idx);
+	idx = smallbin_index(nb);
+	bin = bin_at(av,idx);
 
-		if ( (victim = last(bin)) != bin) {
-			bck = victim->bk;
-			set_inuse_bit_at_offset(victim, nb);
-			bin->bk = bck;
-			bck->fd = bin;
+	if ( (victim = last(bin)) != bin) {
+	    bck = victim->bk;
+	    set_inuse_bit_at_offset(victim, nb);
+	    bin->bk = bck;
+	    bck->fd = bin;
 
-			check_malloced_chunk(victim, nb);
+	    check_malloced_chunk(victim, nb);
 			retval = chunk2mem(victim);
 			goto DONE;
-		}
+	}
     }
 
     /* If this is a large request, consolidate fastbins before continuing.
@@ -897,154 +897,154 @@
        large requests, but less often mixtures, so consolidation is not
        invoked all that often in most programs. And the programs that
        it is called frequently in otherwise tend to fragment.
-	*/
+       */
 
     else {
-		idx = __malloc_largebin_index(nb);
-		if (have_fastchunks(av)) 
-			__malloc_consolidate(av);
+	idx = __malloc_largebin_index(nb);
+	if (have_fastchunks(av)) 
+	    __malloc_consolidate(av);
     }
 
     /*
-	  Process recently freed or remaindered chunks, taking one only if
-	  it is exact fit, or, if this a small request, the chunk is remainder from
-	  the most recent non-exact fit.  Place other traversed chunks in
-	  bins.  Note that this step is the only place in any routine where
-	  chunks are placed in bins.
-	*/
+       Process recently freed or remaindered chunks, taking one only if
+       it is exact fit, or, if this a small request, the chunk is remainder from
+       the most recent non-exact fit.  Place other traversed chunks in
+       bins.  Note that this step is the only place in any routine where
+       chunks are placed in bins.
+       */
 
     while ( (victim = unsorted_chunks(av)->bk) != unsorted_chunks(av)) {
-		bck = victim->bk;
-		size = chunksize(victim);
+	bck = victim->bk;
+	size = chunksize(victim);
 
-		/* If a small request, try to use last remainder if it is the
-		   only chunk in unsorted bin.  This helps promote locality for
-		   runs of consecutive small requests. This is the only
-		   exception to best-fit, and applies only when there is
-		   no exact fit for a small chunk.
-		*/
-
-		if (in_smallbin_range(nb) &&
-			bck == unsorted_chunks(av) &&
-			victim == av->last_remainder &&
-			(unsigned long)(size) > (unsigned long)(nb + MINSIZE)) {
-
-			/* split and reattach remainder */
-			remainder_size = size - nb;
-			remainder = chunk_at_offset(victim, nb);
-			unsorted_chunks(av)->bk = unsorted_chunks(av)->fd = remainder;
-			av->last_remainder = remainder;
-			remainder->bk = remainder->fd = unsorted_chunks(av);
-
-			set_head(victim, nb | PREV_INUSE);
-			set_head(remainder, remainder_size | PREV_INUSE);
-			set_foot(remainder, remainder_size);
+	/* If a small request, try to use last remainder if it is the
+	   only chunk in unsorted bin.  This helps promote locality for
+	   runs of consecutive small requests. This is the only
+	   exception to best-fit, and applies only when there is
+	   no exact fit for a small chunk.
+	   */
+
+	if (in_smallbin_range(nb) &&
+		bck == unsorted_chunks(av) &&
+		victim == av->last_remainder &&
+		(unsigned long)(size) > (unsigned long)(nb + MINSIZE)) {
+
+	    /* split and reattach remainder */
+	    remainder_size = size - nb;
+	    remainder = chunk_at_offset(victim, nb);
+	    unsorted_chunks(av)->bk = unsorted_chunks(av)->fd = remainder;
+	    av->last_remainder = remainder;
+	    remainder->bk = remainder->fd = unsorted_chunks(av);
+
+	    set_head(victim, nb | PREV_INUSE);
+	    set_head(remainder, remainder_size | PREV_INUSE);
+	    set_foot(remainder, remainder_size);
 
-			check_malloced_chunk(victim, nb);
+	    check_malloced_chunk(victim, nb);
 			retval = chunk2mem(victim);
 			goto DONE;
-		}
+	}
+
+	/* remove from unsorted list */
+	unsorted_chunks(av)->bk = bck;
+	bck->fd = unsorted_chunks(av);
+
+	/* Take now instead of binning if exact fit */
 
-		/* remove from unsorted list */
-		unsorted_chunks(av)->bk = bck;
-		bck->fd = unsorted_chunks(av);
-
-		/* Take now instead of binning if exact fit */
-
-		if (size == nb) {
-			set_inuse_bit_at_offset(victim, size);
-			check_malloced_chunk(victim, nb);
+	if (size == nb) {
+	    set_inuse_bit_at_offset(victim, size);
+	    check_malloced_chunk(victim, nb);
 			retval = chunk2mem(victim);
 			goto DONE;
-		}
-
-		/* place chunk in bin */
+	}
 
-		if (in_smallbin_range(size)) {
-			victim_index = smallbin_index(size);
-			bck = bin_at(av, victim_index);
-			fwd = bck->fd;
-		}
-		else {
-			victim_index = __malloc_largebin_index(size);
-			bck = bin_at(av, victim_index);
-			fwd = bck->fd;
-
-			if (fwd != bck) {
-				/* if smaller than smallest, place first */
-				if ((unsigned long)(size) < (unsigned long)(bck->bk->size)) {
-					fwd = bck;
-					bck = bck->bk;
-				}
-				else if ((unsigned long)(size) >=
-						 (unsigned long)(FIRST_SORTED_BIN_SIZE)) {
-
-					/* maintain large bins in sorted order */
-					size |= PREV_INUSE; /* Or with inuse bit to speed comparisons */
-					while ((unsigned long)(size) < (unsigned long)(fwd->size))
-						fwd = fwd->fd;
-					bck = fwd->bk;
-				}
-			}
-		}
+	/* place chunk in bin */
 
-		mark_bin(av, victim_index);
-		victim->bk = bck;
-		victim->fd = fwd;
-		fwd->bk = victim;
-		bck->fd = victim;
+	if (in_smallbin_range(size)) {
+	    victim_index = smallbin_index(size);
+	    bck = bin_at(av, victim_index);
+	    fwd = bck->fd;
+	}
+	else {
+	    victim_index = __malloc_largebin_index(size);
+	    bck = bin_at(av, victim_index);
+	    fwd = bck->fd;
+
+	    if (fwd != bck) {
+		/* if smaller than smallest, place first */
+		if ((unsigned long)(size) < (unsigned long)(bck->bk->size)) {
+		    fwd = bck;
+		    bck = bck->bk;
+		}
+		else if ((unsigned long)(size) >=
+			(unsigned long)(FIRST_SORTED_BIN_SIZE)) {
+
+		    /* maintain large bins in sorted order */
+		    size |= PREV_INUSE; /* Or with inuse bit to speed comparisons */
+		    while ((unsigned long)(size) < (unsigned long)(fwd->size))
+			fwd = fwd->fd;
+		    bck = fwd->bk;
+		}
+	    }
+	}
+
+	mark_bin(av, victim_index);
+	victim->bk = bck;
+	victim->fd = fwd;
+	fwd->bk = victim;
+	bck->fd = victim;
     }
 
     /*
-	  If a large request, scan through the chunks of current bin to
-	  find one that fits.  (This will be the smallest that fits unless
-	  FIRST_SORTED_BIN_SIZE has been changed from default.)  This is
-	  the only step where an unbounded number of chunks might be
-	  scanned without doing anything useful with them. However the
-	  lists tend to be short.
-	*/
+       If a large request, scan through the chunks of current bin to
+       find one that fits.  (This will be the smallest that fits unless
+       FIRST_SORTED_BIN_SIZE has been changed from default.)  This is
+       the only step where an unbounded number of chunks might be
+       scanned without doing anything useful with them. However the
+       lists tend to be short.
+       */
 
     if (!in_smallbin_range(nb)) {
-		bin = bin_at(av, idx);
+	bin = bin_at(av, idx);
 
-		for (victim = last(bin); victim != bin; victim = victim->bk) {
-			size = chunksize(victim);
+	for (victim = last(bin); victim != bin; victim = victim->bk) {
+	    size = chunksize(victim);
 
-			if ((unsigned long)(size) >= (unsigned long)(nb)) {
-				remainder_size = size - nb;
-				unlink(victim, bck, fwd);
-
-				/* Exhaust */
-				if (remainder_size < MINSIZE)  {
-					set_inuse_bit_at_offset(victim, size);
-					check_malloced_chunk(victim, nb);
+	    if ((unsigned long)(size) >= (unsigned long)(nb)) {
+		remainder_size = size - nb;
+		unlink(victim, bck, fwd);
+
+		/* Exhaust */
+		if (remainder_size < MINSIZE)  {
+		    set_inuse_bit_at_offset(victim, size);
+		    check_malloced_chunk(victim, nb);
 					retval = chunk2mem(victim);
 					goto DONE;
-				}
-				/* Split */
-				else {
-					remainder = chunk_at_offset(victim, nb);
-					unsorted_chunks(av)->bk = unsorted_chunks(av)->fd = remainder;
-					remainder->bk = remainder->fd = unsorted_chunks(av);
-					set_head(victim, nb | PREV_INUSE);
-					set_head(remainder, remainder_size | PREV_INUSE);
-					set_foot(remainder, remainder_size);
-					check_malloced_chunk(victim, nb);
+		}
+		/* Split */
+		else {
+		    remainder = chunk_at_offset(victim, nb);
+		    unsorted_chunks(av)->bk = unsorted_chunks(av)->fd = remainder;
+		    remainder->bk = remainder->fd = unsorted_chunks(av);
+		    set_head(victim, nb | PREV_INUSE);
+		    set_head(remainder, remainder_size | PREV_INUSE);
+		    set_foot(remainder, remainder_size);
+		    check_malloced_chunk(victim, nb);
 					retval = chunk2mem(victim);
 					goto DONE;
-				}
-			}
 		}
+	    }
+	}
     }
 
     /*
-	  Search for a chunk by scanning bins, starting with next largest
-	  bin. This search is strictly by best-fit; i.e., the smallest
-	  (with ties going to approximately the least recently used) chunk
-	  that fits is selected.
+       Search for a chunk by scanning bins, starting with next largest
+       bin. This search is strictly by best-fit; i.e., the smallest
+       (with ties going to approximately the least recently used) chunk
+       that fits is selected.
 
-	  The bitmap avoids needing to check that most blocks are nonempty.
-	*/
+       The bitmap avoids needing to check that most blocks are nonempty.
+       */
 
     ++idx;
     bin = bin_at(av,idx);
@@ -1054,102 +1054,102 @@
 
     for (;;) {
 
-		/* Skip rest of block if there are no more set bits in this block.  */
-		if (bit > map || bit == 0) {
-			do {
-				if (++block >= BINMAPSIZE)  /* out of bins */
-					goto use_top;
-			} while ( (map = av->binmap[block]) == 0);
-
-			bin = bin_at(av, (block << BINMAPSHIFT));
-			bit = 1;
-		}
-
-		/* Advance to bin with set bit. There must be one. */
-		while ((bit & map) == 0) {
-			bin = next_bin(bin);
-			bit <<= 1;
-			assert(bit != 0);
-		}
-
-		/* Inspect the bin. It is likely to be non-empty */
-		victim = last(bin);
-
-		/*  If a false alarm (empty bin), clear the bit. */
-		if (victim == bin) {
-			av->binmap[block] = map &= ~bit; /* Write through */
-			bin = next_bin(bin);
-			bit <<= 1;
-		}
-
-		else {
-			size = chunksize(victim);
-
-			/*  We know the first chunk in this bin is big enough to use. */
-			assert((unsigned long)(size) >= (unsigned long)(nb));
-
-			remainder_size = size - nb;
-
-			/* unlink */
-			bck = victim->bk;
-			bin->bk = bck;
-			bck->fd = bin;
-
-			/* Exhaust */
-			if (remainder_size < MINSIZE) {
-				set_inuse_bit_at_offset(victim, size);
-				check_malloced_chunk(victim, nb);
+	/* Skip rest of block if there are no more set bits in this block.  */
+	if (bit > map || bit == 0) {
+	    do {
+		if (++block >= BINMAPSIZE)  /* out of bins */
+		    goto use_top;
+	    } while ( (map = av->binmap[block]) == 0);
+
+	    bin = bin_at(av, (block << BINMAPSHIFT));
+	    bit = 1;
+	}
+
+	/* Advance to bin with set bit. There must be one. */
+	while ((bit & map) == 0) {
+	    bin = next_bin(bin);
+	    bit <<= 1;
+	    assert(bit != 0);
+	}
+
+	/* Inspect the bin. It is likely to be non-empty */
+	victim = last(bin);
+
+	/*  If a false alarm (empty bin), clear the bit. */
+	if (victim == bin) {
+	    av->binmap[block] = map &= ~bit; /* Write through */
+	    bin = next_bin(bin);
+	    bit <<= 1;
+	}
+
+	else {
+	    size = chunksize(victim);
+
+	    /*  We know the first chunk in this bin is big enough to use. */
+	    assert((unsigned long)(size) >= (unsigned long)(nb));
+
+	    remainder_size = size - nb;
+
+	    /* unlink */
+	    bck = victim->bk;
+	    bin->bk = bck;
+	    bck->fd = bin;
+
+	    /* Exhaust */
+	    if (remainder_size < MINSIZE) {
+		set_inuse_bit_at_offset(victim, size);
+		check_malloced_chunk(victim, nb);
 				retval = chunk2mem(victim);
 				goto DONE;
-			}
+	    }
+
+	    /* Split */
+	    else {
+		remainder = chunk_at_offset(victim, nb);
+
+		unsorted_chunks(av)->bk = unsorted_chunks(av)->fd = remainder;
+		remainder->bk = remainder->fd = unsorted_chunks(av);
+		/* advertise as last remainder */
+		if (in_smallbin_range(nb))
+		    av->last_remainder = remainder;
 
-			/* Split */
-			else {
-				remainder = chunk_at_offset(victim, nb);
-
-				unsorted_chunks(av)->bk = unsorted_chunks(av)->fd = remainder;
-				remainder->bk = remainder->fd = unsorted_chunks(av);
-				/* advertise as last remainder */
-				if (in_smallbin_range(nb))
-					av->last_remainder = remainder;
-
-				set_head(victim, nb | PREV_INUSE);
-				set_head(remainder, remainder_size | PREV_INUSE);
-				set_foot(remainder, remainder_size);
-				check_malloced_chunk(victim, nb);
+		set_head(victim, nb | PREV_INUSE);
+		set_head(remainder, remainder_size | PREV_INUSE);
+		set_foot(remainder, remainder_size);
+		check_malloced_chunk(victim, nb);
 				retval = chunk2mem(victim);
 				goto DONE;
-			}
-		}
+	    }
+	}
     }
 
- use_top:
+use_top:
     /*
-	  If large enough, split off the chunk bordering the end of memory
-	  (held in av->top). Note that this is in accord with the best-fit
-	  search rule.  In effect, av->top is treated as larger (and thus
-	  less well fitting) than any other available chunk since it can
-	  be extended to be as large as necessary (up to system
-	  limitations).
-
-	  We require that av->top always exists (i.e., has size >=
-	  MINSIZE) after initialization, so if it would otherwise be
-	  exhuasted by current request, it is replenished. (The main
-	  reason for ensuring it exists is that we may need MINSIZE space
-	  to put in fenceposts in sysmalloc.)
-	*/
+       If large enough, split off the chunk bordering the end of memory
+       (held in av->top). Note that this is in accord with the best-fit
+       search rule.  In effect, av->top is treated as larger (and thus
+       less well fitting) than any other available chunk since it can
+       be extended to be as large as necessary (up to system
+       limitations).
+
+       We require that av->top always exists (i.e., has size >=
+       MINSIZE) after initialization, so if it would otherwise be
+       exhuasted by current request, it is replenished. (The main
+       reason for ensuring it exists is that we may need MINSIZE space
+       to put in fenceposts in sysmalloc.)
+       */
 
     victim = av->top;
     size = chunksize(victim);
 
     if ((unsigned long)(size) >= (unsigned long)(nb + MINSIZE)) {
-		remainder_size = size - nb;
-		remainder = chunk_at_offset(victim, nb);
-		av->top = remainder;
-		set_head(victim, nb | PREV_INUSE);
-		set_head(remainder, remainder_size | PREV_INUSE);
+	remainder_size = size - nb;
+	remainder = chunk_at_offset(victim, nb);
+	av->top = remainder;
+	set_head(victim, nb | PREV_INUSE);
+	set_head(remainder, remainder_size | PREV_INUSE);
 
-		check_malloced_chunk(victim, nb);
+	check_malloced_chunk(victim, nb);
 		retval = chunk2mem(victim);
 		goto DONE;
     }
diff -urN a/libc/stdlib/malloc-standard/mallopt.c b/libc/stdlib/malloc-standard/mallopt.c
--- a/libc/stdlib/malloc-standard/mallopt.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/stdlib/malloc-standard/mallopt.c	2012-04-10 13:55:23.000000000 +0800
@@ -8,7 +8,7 @@
   VERSION 2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
 
   Note: There may be an updated version of this malloc obtainable at
-  ftp://gee.cs.oswego.edu/pub/misc/malloc.c
+           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
   Check before installing!
 
   Hacked up for uClibc by Erik Andersen <andersen@codepoet.org>
@@ -31,32 +31,32 @@
     __malloc_consolidate(av);
 
     switch(param_number) {
-		case M_MXFAST:
-			if (value >= 0 && value <= MAX_FAST_SIZE) {
-				set_max_fast(av, value);
-				ret = 1;
-			}
-			break;
-
-		case M_TRIM_THRESHOLD:
-			av->trim_threshold = value;
-			ret = 1;
-			break;
-
-		case M_TOP_PAD:
-			av->top_pad = value;
-			ret = 1;
-			break;
-
-		case M_MMAP_THRESHOLD:
-			av->mmap_threshold = value;
-			ret = 1;
-			break;
-
-		case M_MMAP_MAX:
-			av->n_mmaps_max = value;
-			ret = 1;
-			break;
+	case M_MXFAST:
+	    if (value >= 0 && value <= MAX_FAST_SIZE) {
+		set_max_fast(av, value);
+		ret = 1;
+	    }
+	    break;
+
+	case M_TRIM_THRESHOLD:
+	    av->trim_threshold = value;
+	    ret = 1;
+	    break;
+
+	case M_TOP_PAD:
+	    av->top_pad = value;
+	    ret = 1;
+	    break;
+
+	case M_MMAP_THRESHOLD:
+	    av->mmap_threshold = value;
+	    ret = 1;
+	    break;
+
+	case M_MMAP_MAX:
+	    av->n_mmaps_max = value;
+	    ret = 1;
+	    break;
     }
     __MALLOC_UNLOCK;
     return ret;
diff -urN a/libc/stdlib/malloc-standard/memalign.c b/libc/stdlib/malloc-standard/memalign.c
--- a/libc/stdlib/malloc-standard/memalign.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/stdlib/malloc-standard/memalign.c	2012-04-10 13:55:23.000000000 +0800
@@ -8,7 +8,7 @@
   VERSION 2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
 
   Note: There may be an updated version of this malloc obtainable at
-  ftp://gee.cs.oswego.edu/pub/misc/malloc.c
+           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
   Check before installing!
 
   Hacked up for uClibc by Erik Andersen <andersen@codepoet.org>
@@ -47,9 +47,9 @@
 
     /* Make sure alignment is power of 2 (in case MINSIZE is not).  */
     if ((alignment & (alignment - 1)) != 0) {
-		size_t a = MALLOC_ALIGNMENT * 2;
-		while ((unsigned long)a < (unsigned long)alignment) a <<= 1;
-		alignment = a;
+	size_t a = MALLOC_ALIGNMENT * 2;
+	while ((unsigned long)a < (unsigned long)alignment) a <<= 1;
+	alignment = a;
     }
 
     __MALLOC_LOCK;
@@ -72,52 +72,52 @@
 
     if ((((unsigned long)(m)) % alignment) != 0) { /* misaligned */
 
-		/*
-		  Find an aligned spot inside chunk.  Since we need to give back
-		  leading space in a chunk of at least MINSIZE, if the first
-		  calculation places us at a spot with less than MINSIZE leader,
-		  we can move to the next aligned spot -- we've allocated enough
-		  total room so that this is always possible.
-		*/
-
-		brk = (char*)mem2chunk((unsigned long)(((unsigned long)(m + alignment - 1)) &
-											   -((signed long) alignment)));
-		if ((unsigned long)(brk - (char*)(p)) < MINSIZE)
-			brk += alignment;
-
-		newp = (mchunkptr)brk;
-		leadsize = brk - (char*)(p);
-		newsize = chunksize(p) - leadsize;
-
-		/* For mmapped chunks, just adjust offset */
-		if (chunk_is_mmapped(p)) {
-			newp->prev_size = p->prev_size + leadsize;
-			set_head(newp, newsize|IS_MMAPPED);
+	/*
+	   Find an aligned spot inside chunk.  Since we need to give back
+	   leading space in a chunk of at least MINSIZE, if the first
+	   calculation places us at a spot with less than MINSIZE leader,
+	   we can move to the next aligned spot -- we've allocated enough
+	   total room so that this is always possible.
+	   */
+
+	brk = (char*)mem2chunk((unsigned long)(((unsigned long)(m + alignment - 1)) &
+		    -((signed long) alignment)));
+	if ((unsigned long)(brk - (char*)(p)) < MINSIZE)
+	    brk += alignment;
+
+	newp = (mchunkptr)brk;
+	leadsize = brk - (char*)(p);
+	newsize = chunksize(p) - leadsize;
+
+	/* For mmapped chunks, just adjust offset */
+	if (chunk_is_mmapped(p)) {
+	    newp->prev_size = p->prev_size + leadsize;
+	    set_head(newp, newsize|IS_MMAPPED);
 			retval = chunk2mem(newp);
 			goto DONE;
-		}
+	}
 
-		/* Otherwise, give back leader, use the rest */
-		set_head(newp, newsize | PREV_INUSE);
-		set_inuse_bit_at_offset(newp, newsize);
-		set_head_size(p, leadsize);
-		free(chunk2mem(p));
-		p = newp;
+	/* Otherwise, give back leader, use the rest */
+	set_head(newp, newsize | PREV_INUSE);
+	set_inuse_bit_at_offset(newp, newsize);
+	set_head_size(p, leadsize);
+	free(chunk2mem(p));
+	p = newp;
 
-		assert (newsize >= nb &&
-				(((unsigned long)(chunk2mem(p))) % alignment) == 0);
+	assert (newsize >= nb &&
+		(((unsigned long)(chunk2mem(p))) % alignment) == 0);
     }
 
     /* Also give back spare room at the end */
     if (!chunk_is_mmapped(p)) {
-		size = chunksize(p);
-		if ((unsigned long)(size) > (unsigned long)(nb + MINSIZE)) {
-			remainder_size = size - nb;
-			remainder = chunk_at_offset(p, nb);
-			set_head(remainder, remainder_size | PREV_INUSE);
-			set_head_size(p, nb);
-			free(chunk2mem(remainder));
-		}
+	size = chunksize(p);
+	if ((unsigned long)(size) > (unsigned long)(nb + MINSIZE)) {
+	    remainder_size = size - nb;
+	    remainder = chunk_at_offset(p, nb);
+	    set_head(remainder, remainder_size | PREV_INUSE);
+	    set_head_size(p, nb);
+	    free(chunk2mem(remainder));
+	}
     }
 
     check_inuse_chunk(p);
diff -urN a/libc/stdlib/malloc-standard/realloc.c b/libc/stdlib/malloc-standard/realloc.c
--- a/libc/stdlib/malloc-standard/realloc.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/stdlib/malloc-standard/realloc.c	2012-04-10 13:55:23.000000000 +0800
@@ -8,7 +8,7 @@
   VERSION 2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
 
   Note: There may be an updated version of this malloc obtainable at
-  ftp://gee.cs.oswego.edu/pub/misc/malloc.c
+           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
   Check before installing!
 
   Hacked up for uClibc by Erik Andersen <andersen@codepoet.org>
@@ -23,14 +23,14 @@
 {
     mstate av;
 
-    size_t  nb;                       /* padded request size */
+    size_t  nb;              /* padded request size */
 
     mchunkptr        oldp;            /* chunk corresponding to oldmem */
-    size_t  oldsize;                  /* its size */
+    size_t  oldsize;         /* its size */
 
     mchunkptr        newp;            /* chunk to return */
-    size_t  newsize;                  /* its size */
-    void*          newmem;            /* corresponding user mem */
+    size_t  newsize;         /* its size */
+    void*          newmem;          /* corresponding user mem */
 
     mchunkptr        next;            /* next contiguous chunk after oldp */
 
@@ -40,20 +40,20 @@
     mchunkptr        bck;             /* misc temp for linking */
     mchunkptr        fwd;             /* misc temp for linking */
 
-    unsigned long     copysize;       /* bytes to copy */
+    unsigned long     copysize;        /* bytes to copy */
     unsigned int     ncopies;         /* size_t words to copy */
-    size_t* s;                        /* copy source */
-    size_t* d;                        /* copy destination */
+    size_t* s;               /* copy source */
+    size_t* d;               /* copy destination */
 
 	void *retval;
 
 
     /* Check for special cases.  */
     if (! oldmem)
-		return malloc(bytes);
+	return malloc(bytes);
     if (! bytes) {
-		free (oldmem);
-		return malloc(bytes);
+	free (oldmem);
+	return malloc(bytes);
     }
 
     __MALLOC_LOCK;
@@ -67,171 +67,171 @@
 
     if (!chunk_is_mmapped(oldp)) {
 
-		if ((unsigned long)(oldsize) >= (unsigned long)(nb)) {
-			/* already big enough; split below */
-			newp = oldp;
-			newsize = oldsize;
-		}
-
-		else {
-			next = chunk_at_offset(oldp, oldsize);
-
-			/* Try to expand forward into top */
-			if (next == av->top &&
-				(unsigned long)(newsize = oldsize + chunksize(next)) >=
-				(unsigned long)(nb + MINSIZE)) {
-				set_head_size(oldp, nb);
-				av->top = chunk_at_offset(oldp, nb);
-				set_head(av->top, (newsize - nb) | PREV_INUSE);
+	if ((unsigned long)(oldsize) >= (unsigned long)(nb)) {
+	    /* already big enough; split below */
+	    newp = oldp;
+	    newsize = oldsize;
+	}
+
+	else {
+	    next = chunk_at_offset(oldp, oldsize);
+
+	    /* Try to expand forward into top */
+	    if (next == av->top &&
+		    (unsigned long)(newsize = oldsize + chunksize(next)) >=
+		    (unsigned long)(nb + MINSIZE)) {
+		set_head_size(oldp, nb);
+		av->top = chunk_at_offset(oldp, nb);
+		set_head(av->top, (newsize - nb) | PREV_INUSE);
 				retval = chunk2mem(oldp);
 				goto DONE;
-			}
+	    }
 
-			/* Try to expand forward into next chunk;  split off remainder below */
-			else if (next != av->top &&
-					 !inuse(next) &&
-					 (unsigned long)(newsize = oldsize + chunksize(next)) >=
-					 (unsigned long)(nb)) {
-				newp = oldp;
-				unlink(next, bck, fwd);
-			}
-
-			/* allocate, copy, free */
-			else {
-				newmem = malloc(nb - MALLOC_ALIGN_MASK);
-				if (newmem == 0) {
+	    /* Try to expand forward into next chunk;  split off remainder below */
+	    else if (next != av->top &&
+		    !inuse(next) &&
+		    (unsigned long)(newsize = oldsize + chunksize(next)) >=
+		    (unsigned long)(nb)) {
+		newp = oldp;
+		unlink(next, bck, fwd);
+	    }
+
+	    /* allocate, copy, free */
+	    else {
+		newmem = malloc(nb - MALLOC_ALIGN_MASK);
+		if (newmem == 0) {
 					retval = 0; /* propagate failure */
 					goto DONE;
-				}
+		}
 
-				newp = mem2chunk(newmem);
-				newsize = chunksize(newp);
+		newp = mem2chunk(newmem);
+		newsize = chunksize(newp);
 
-				/*
-				  Avoid copy if newp is next chunk after oldp.
-				*/
-				if (newp == next) {
-					newsize += oldsize;
-					newp = oldp;
+		/*
+		   Avoid copy if newp is next chunk after oldp.
+		   */
+		if (newp == next) {
+		    newsize += oldsize;
+		    newp = oldp;
+		}
+		else {
+		    /*
+		       Unroll copy of <= 36 bytes (72 if 8byte sizes)
+		       We know that contents have an odd number of
+		       size_t-sized words; minimally 3.
+		       */
+
+		    copysize = oldsize - (sizeof(size_t));
+		    s = (size_t*)(oldmem);
+		    d = (size_t*)(newmem);
+		    ncopies = copysize / sizeof(size_t);
+		    assert(ncopies >= 3);
+
+		    if (ncopies > 9)
+			memcpy(d, s, copysize);
+
+		    else {
+			*(d+0) = *(s+0);
+			*(d+1) = *(s+1);
+			*(d+2) = *(s+2);
+			if (ncopies > 4) {
+			    *(d+3) = *(s+3);
+			    *(d+4) = *(s+4);
+			    if (ncopies > 6) {
+				*(d+5) = *(s+5);
+				*(d+6) = *(s+6);
+				if (ncopies > 8) {
+				    *(d+7) = *(s+7);
+				    *(d+8) = *(s+8);
 				}
-				else {
-					/*
-					  Unroll copy of <= 36 bytes (72 if 8byte sizes)
-					  We know that contents have an odd number of
-					  size_t-sized words; minimally 3.
-					*/
-
-					copysize = oldsize - (sizeof(size_t));
-					s = (size_t*)(oldmem);
-					d = (size_t*)(newmem);
-					ncopies = copysize / sizeof(size_t);
-					assert(ncopies >= 3);
-
-					if (ncopies > 9)
-						memcpy(d, s, copysize);
-
-					else {
-						*(d+0) = *(s+0);
-						*(d+1) = *(s+1);
-						*(d+2) = *(s+2);
-						if (ncopies > 4) {
-							*(d+3) = *(s+3);
-							*(d+4) = *(s+4);
-							if (ncopies > 6) {
-								*(d+5) = *(s+5);
-								*(d+6) = *(s+6);
-								if (ncopies > 8) {
-									*(d+7) = *(s+7);
-									*(d+8) = *(s+8);
-								}
-							}
-						}
-					}
+			    }
+			}
+		    }
 
-					free(oldmem);
-					check_inuse_chunk(newp);
+		    free(oldmem);
+		    check_inuse_chunk(newp);
 					retval = chunk2mem(newp);
 					goto DONE;
-				}
-			}
 		}
+	    }
+	}
 
-		/* If possible, free extra space in old or extended chunk */
+	/* If possible, free extra space in old or extended chunk */
 
-		assert((unsigned long)(newsize) >= (unsigned long)(nb));
+	assert((unsigned long)(newsize) >= (unsigned long)(nb));
 
-		remainder_size = newsize - nb;
+	remainder_size = newsize - nb;
 
-		if (remainder_size < MINSIZE) { /* not enough extra to split off */
-			set_head_size(newp, newsize);
-			set_inuse_bit_at_offset(newp, newsize);
-		}
-		else { /* split remainder */
-			remainder = chunk_at_offset(newp, nb);
-			set_head_size(newp, nb);
-			set_head(remainder, remainder_size | PREV_INUSE);
-			/* Mark remainder as inuse so free() won't complain */
-			set_inuse_bit_at_offset(remainder, remainder_size);
-			free(chunk2mem(remainder));
-		}
+	if (remainder_size < MINSIZE) { /* not enough extra to split off */
+	    set_head_size(newp, newsize);
+	    set_inuse_bit_at_offset(newp, newsize);
+	}
+	else { /* split remainder */
+	    remainder = chunk_at_offset(newp, nb);
+	    set_head_size(newp, nb);
+	    set_head(remainder, remainder_size | PREV_INUSE);
+	    /* Mark remainder as inuse so free() won't complain */
+	    set_inuse_bit_at_offset(remainder, remainder_size);
+	    free(chunk2mem(remainder));
+	}
 
-		check_inuse_chunk(newp);
+	check_inuse_chunk(newp);
 		retval = chunk2mem(newp);
 		goto DONE;
     }
 
     /*
-	  Handle mmap cases
-	*/
+       Handle mmap cases
+       */
 
     else {
-		size_t offset = oldp->prev_size;
-		size_t pagemask = av->pagesize - 1;
-		char *cp;
-		unsigned long  sum;
+	size_t offset = oldp->prev_size;
+	size_t pagemask = av->pagesize - 1;
+	char *cp;
+	unsigned long  sum;
 
-		/* Note the extra (sizeof(size_t)) overhead */
-		newsize = (nb + offset + (sizeof(size_t)) + pagemask) & ~pagemask;
+	/* Note the extra (sizeof(size_t)) overhead */
+	newsize = (nb + offset + (sizeof(size_t)) + pagemask) & ~pagemask;
 
-		/* don't need to remap if still within same page */
-		if (oldsize == newsize - offset) {
+	/* don't need to remap if still within same page */
+	if (oldsize == newsize - offset) {
 			retval = oldmem;
 			goto DONE;
-		}
+	}
 
-		cp = (char*)mremap((char*)oldp - offset, oldsize + offset, newsize, 1);
+	cp = (char*)mremap((char*)oldp - offset, oldsize + offset, newsize, 1);
 
-		if (cp != (char*)MORECORE_FAILURE) {
+	if (cp != (char*)MORECORE_FAILURE) {
 
-			newp = (mchunkptr)(cp + offset);
-			set_head(newp, (newsize - offset)|IS_MMAPPED);
+	    newp = (mchunkptr)(cp + offset);
+	    set_head(newp, (newsize - offset)|IS_MMAPPED);
 
-			assert(aligned_OK(chunk2mem(newp)));
-			assert((newp->prev_size == offset));
-
-			/* update statistics */
-			sum = av->mmapped_mem += newsize - oldsize;
-			if (sum > (unsigned long)(av->max_mmapped_mem))
-				av->max_mmapped_mem = sum;
-			sum += av->sbrked_mem;
-			if (sum > (unsigned long)(av->max_total_mem))
-				av->max_total_mem = sum;
+	    assert(aligned_OK(chunk2mem(newp)));
+	    assert((newp->prev_size == offset));
+
+	    /* update statistics */
+	    sum = av->mmapped_mem += newsize - oldsize;
+	    if (sum > (unsigned long)(av->max_mmapped_mem))
+		av->max_mmapped_mem = sum;
+	    sum += av->sbrked_mem;
+	    if (sum > (unsigned long)(av->max_total_mem))
+		av->max_total_mem = sum;
 
 			retval = chunk2mem(newp);
 			goto DONE;
-		}
+	}
 
-		/* Note the extra (sizeof(size_t)) overhead. */
-		if ((unsigned long)(oldsize) >= (unsigned long)(nb + (sizeof(size_t))))
-			newmem = oldmem; /* do nothing */
-		else {
-			/* Must alloc, copy, free. */
-			newmem = malloc(nb - MALLOC_ALIGN_MASK);
-			if (newmem != 0) {
-				memcpy(newmem, oldmem, oldsize - 2*(sizeof(size_t)));
-				free(oldmem);
-			}
-		}
+	/* Note the extra (sizeof(size_t)) overhead. */
+	if ((unsigned long)(oldsize) >= (unsigned long)(nb + (sizeof(size_t))))
+	    newmem = oldmem; /* do nothing */
+	else {
+	    /* Must alloc, copy, free. */
+	    newmem = malloc(nb - MALLOC_ALIGN_MASK);
+	    if (newmem != 0) {
+		memcpy(newmem, oldmem, oldsize - 2*(sizeof(size_t)));
+		free(oldmem);
+	    }
+	}
 		retval = newmem;
     }
 
diff -urN a/libc/stdlib/mkdtemp.c b/libc/stdlib/mkdtemp.c
--- a/libc/stdlib/mkdtemp.c	2007-01-28 12:33:37.000000000 +0700
+++ b/libc/stdlib/mkdtemp.c	2012-04-10 13:55:23.000000000 +0800
@@ -28,7 +28,7 @@
    (This function comes from OpenBSD.) */
 char * mkdtemp (char *template)
 {
-  if (__gen_tempname (template, __GT_DIR))
+    if (__gen_tempname (template, __GT_DIR))
     return NULL;
   else
     return template;
diff -urN a/libc/stdlib/posix_memalign.c b/libc/stdlib/posix_memalign.c
--- a/libc/stdlib/posix_memalign.c	1970-01-01 07:00:00.000000000 +0700
+++ b/libc/stdlib/posix_memalign.c	2012-04-10 13:55:23.000000000 +0800
@@ -0,0 +1,41 @@
+/* posix_memalign for uClibc
+ *
+ * Copyright (C) 1996-2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+ * Copyright (C) 2005 by Erik Andersen <andersen@uclibc.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Library General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <stdlib.h>
+#include <malloc.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <sys/param.h>
+
+int posix_memalign(void **memptr, size_t alignment, size_t size)
+{
+	/* Make sure alignment is correct. */
+	if (alignment % sizeof(void *) != 0)
+	    /* Skip these checks because the memalign() func does them for us
+	     || !powerof2(alignment / sizeof(void *)) != 0
+	     || alignment == 0
+	     */
+		return EINVAL;
+
+	*memptr = memalign(alignment, size);
+
+    return (*memptr != NULL ? 0 : ENOMEM);
+}
diff -urN a/libc/stdlib/realpath.c b/libc/stdlib/realpath.c
--- a/libc/stdlib/realpath.c	2007-02-09 04:08:37.000000000 +0700
+++ b/libc/stdlib/realpath.c	2012-04-10 13:55:23.000000000 +0800
@@ -51,6 +51,7 @@
 	char *max_path;
 	int readlinks = 0;
 	int n;
+	int is_buffer_malloc = 0;
 
 	if (path == NULL) {
 		__set_errno(EINVAL);
@@ -121,12 +122,21 @@
 		/* See if latest pathname component is a symlink. */
 		*new_path = '\0';
 		n = readlink(got_path, link_path, PATH_MAX - 1);
+		/* Add this to prevent from segmentation fault when resolved_path is NULL */
+		if(!resolved_path) {
+			resolved_path = malloc(PATH_MAX);
+			if(!resolved_path)
+				return NULL;
+			is_buffer_malloc = 1;
+		}
 		if (n < 0) {
 			/* EINVAL means the file exists but isn't a symlink. */
 			if (errno != EINVAL) {
 				/* Make sure it's null terminated. */
 				*new_path = '\0';
 				strcpy(resolved_path, got_path);
+				if(is_buffer_malloc)
+					free(resolved_path);
 				return NULL;
 			}
 		} else {
@@ -141,6 +151,8 @@
 			/* Safe sex check. */
 			if (strlen(path) + n >= PATH_MAX - 2) {
 				__set_errno(ENAMETOOLONG);
+				if(is_buffer_malloc)
+					free(resolved_path);
 				return NULL;
 			}
 			/* Insert symlink contents into path. */
diff -urN a/libc/stdlib/setenv.c b/libc/stdlib/setenv.c
--- a/libc/stdlib/setenv.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libc/stdlib/setenv.c	2012-04-10 13:55:23.000000000 +0800
@@ -17,7 +17,7 @@
    02111-1307 USA.  
    
    modified for uClibc by Erik Andersen <andersen@codepoet.org>
-*/
+   */
 
 #define _GNU_SOURCE
 #include <features.h>
@@ -42,7 +42,7 @@
    to reuse values once generated for a `setenv' call since we can never
    free the strings.  */
 int __add_to_environ (const char *name, const char *value, 
-					  const char *combined, int replace)
+	const char *combined, int replace)
 {
     register char **ep;
     register size_t size;
@@ -58,65 +58,65 @@
 
     size = 0;
     if (ep != NULL) {
-		for (; *ep != NULL; ++ep) {
-			if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')
-				break;
-			else
-				++size;
-		}
+	for (; *ep != NULL; ++ep) {
+	    if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')
+		break;
+	    else
+		++size;
+	}
     }
 
     if (ep == NULL || *ep == NULL) {
-		char **new_environ;
+	char **new_environ;
 
-		/* We allocated this space; we can extend it.  */
-		new_environ = (char **) realloc (last_environ,
-										 (size + 2) * sizeof (char *));
-		if (new_environ == NULL) {
+	/* We allocated this space; we can extend it.  */
+	new_environ = (char **) realloc (last_environ,
+		(size + 2) * sizeof (char *));
+	if (new_environ == NULL) {
 			goto DONE;
-		}
+	}
 
-		/* If the whole entry is given add it.  */
-		if (combined != NULL) {
-			/* We must not add the string to the search tree since it belongs
-			   to the user.  */
-			new_environ[size] = (char *) combined;
-		} else {
-			/* See whether the value is already known.  */
-			new_environ[size] = (char *) malloc (namelen + 1 + vallen);
-			if (new_environ[size] == NULL) {
-				__set_errno (ENOMEM);
+	/* If the whole entry is given add it.  */
+	if (combined != NULL) {
+	    /* We must not add the string to the search tree since it belongs
+	       to the user.  */
+	    new_environ[size] = (char *) combined;
+	} else {
+	    /* See whether the value is already known.  */
+	    new_environ[size] = (char *) malloc (namelen + 1 + vallen);
+	    if (new_environ[size] == NULL) {
+		__set_errno (ENOMEM);
 				goto DONE;
-			}
+	    }
 
-			memcpy (new_environ[size], name, namelen);
-			new_environ[size][namelen] = '=';
-			memcpy (&new_environ[size][namelen + 1], value, vallen);
-		}
-
-		if (__environ != last_environ) {
-			memcpy ((char *) new_environ, (char *) __environ,
-					size * sizeof (char *));
-		}
+	    memcpy (new_environ[size], name, namelen);
+	    new_environ[size][namelen] = '=';
+	    memcpy (&new_environ[size][namelen + 1], value, vallen);
+	}
+
+	if (__environ != last_environ) {
+	    memcpy ((char *) new_environ, (char *) __environ,
+		    size * sizeof (char *));
+	}
 
-		new_environ[size + 1] = NULL;
-		last_environ = __environ = new_environ;
+	new_environ[size + 1] = NULL;
+	last_environ = __environ = new_environ;
     } else if (replace) {
-		char *np;
+	char *np;
 
-		/* Use the user string if given.  */
-		if (combined != NULL) {
-			np = (char *) combined;
-		} else {
-			np = malloc (namelen + 1 + vallen);
-			if (np == NULL) {
+	/* Use the user string if given.  */
+	if (combined != NULL) {
+	    np = (char *) combined;
+	} else {
+	    np = malloc (namelen + 1 + vallen);
+	    if (np == NULL) {
 				goto DONE;
-			}
-			memcpy (np, name, namelen);
-			np[namelen] = '=';
-			memcpy (&np[namelen + 1], value, vallen);
-		}
-		*ep = np;
+	    }
+	    memcpy (np, name, namelen);
+	    np[namelen] = '=';
+	    memcpy (&np[namelen + 1], value, vallen);
+	}
+	*ep = np;
     }
 
     rv = 0;
@@ -137,24 +137,24 @@
     char **ep;
 
     if (name == NULL || *name == '\0' || strchr (name, '=') != NULL) {
-		__set_errno (EINVAL);
-		return -1;
+	__set_errno (EINVAL);
+	return -1;
     }
 
     len = strlen (name);
     __UCLIBC_MUTEX_LOCK(mylock);
     ep = __environ;
     while (*ep != NULL) {
-		if (!strncmp (*ep, name, len) && (*ep)[len] == '=') {
-			/* Found it.  Remove this pointer by moving later ones back.  */
-			char **dp = ep;
-			do {
-				dp[0] = dp[1];
-			} while (*dp++);
-			/* Continue the loop in case NAME appears again.  */
-		} else {
-			++ep;
-		}
+	if (!strncmp (*ep, name, len) && (*ep)[len] == '=') {
+	    /* Found it.  Remove this pointer by moving later ones back.  */
+	    char **dp = ep;
+	    do {
+		dp[0] = dp[1];
+	    } while (*dp++);
+	    /* Continue the loop in case NAME appears again.  */
+	} else {
+	    ++ep;
+	}
     }
     __UCLIBC_MUTEX_UNLOCK(mylock);
     return 0;
@@ -167,9 +167,9 @@
 {
     __UCLIBC_MUTEX_LOCK(mylock);
     if (__environ == last_environ && __environ != NULL) {
-		/* We allocated this environment so we can free it.  */
-		free (__environ);
-		last_environ = NULL;
+	/* We allocated this environment so we can free it.  */
+	free (__environ);
+	last_environ = NULL;
     }
     /* Clear the environment pointer removes the whole environment.  */
     __environ = NULL;
@@ -184,10 +184,10 @@
     const char *const name_end = strchr (string, '=');
 
     if (name_end != NULL) {
-		char *name = strndup(string, name_end - string);
-		result = __add_to_environ (name, NULL, string, 1);
-		free(name);
-		return(result);
+	char *name = strndup(string, name_end - string);
+	result = __add_to_environ (name, NULL, string, 1);
+	free(name);
+	return(result);
     }
     unsetenv (string);
     return 0;
diff -urN a/libc/string/generic/strlen.c b/libc/string/generic/strlen.c
--- a/libc/string/generic/strlen.c	2004-09-02 22:39:38.000000000 +0800
+++ b/libc/string/generic/strlen.c	2012-04-10 13:55:23.000000000 +0800
@@ -32,7 +32,7 @@
 {
   const char *char_ptr;
   const unsigned long int *longword_ptr;
-  unsigned long int longword, magic_bits, himagic, lomagic;
+  unsigned long int longword, himagic, lomagic;
 
   /* Handle the first few characters by reading one character at a time.
      Do this until CHAR_PTR is aligned on a longword boundary.  */
@@ -56,14 +56,12 @@
 
      The 1-bits make sure that carries propagate to the next 0-bit.
      The 0-bits provide holes for carries to fall into.  */
-  magic_bits = 0x7efefeffL;
   himagic = 0x80808080L;
   lomagic = 0x01010101L;
   if (sizeof (longword) > 4)
     {
       /* 64-bit version of the magic.  */
       /* Do the shift in two steps to avoid a warning if long has 32 bits.  */
-      magic_bits = ((0x7efefefeL << 16) << 16) | 0xfefefeffL;
       himagic = ((himagic << 16) << 16) | himagic;
       lomagic = ((lomagic << 16) << 16) | lomagic;
     }
@@ -106,22 +104,7 @@
 
       longword = *longword_ptr++;
 
-      if (
-#if 0
-	  /* Add MAGIC_BITS to LONGWORD.  */
-	  (((longword + magic_bits)
-
-	    /* Set those bits that were unchanged by the addition.  */
-	    ^ ~longword)
-
-	   /* Look at only the hole bits.  If any of the hole bits
-	      are unchanged, most likely one of the bytes was a
-	      zero.  */
-	   & ~magic_bits)
-#else
-	  ((longword - lomagic) & himagic)
-#endif
-	  != 0)
+      if (((longword - lomagic) & himagic) != 0)
 	{
 	  /* Which of the bytes was the zero?  If none of them were, it was
 	     a misfire; continue the search.  */
diff -urN a/libc/string/.indent.pro b/libc/string/.indent.pro
--- a/libc/string/.indent.pro	2000-10-08 07:37:03.000000000 +0800
+++ b/libc/string/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/sysdeps/linux/arm/crtn.S b/libc/sysdeps/linux/arm/crtn.S
--- a/libc/sysdeps/linux/arm/crtn.S	2003-11-05 07:43:09.000000000 +0700
+++ b/libc/sysdeps/linux/arm/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -5,13 +5,11 @@
 	.global	_init
 	.type	_init, %function
 	ldr	pc, [sp], #4
-	.size	_init, .-_init
 	
 	.section .fini
 	.align	2
 	.global	_fini
 	.type	_fini, %function
 	ldr	pc, [sp], #4
-	.size	_fini, .-_fini
 	
 	.ident	"GCC: (GNU) 3.3.2 20031005 (Debian prerelease)"
diff -urN a/libc/sysdeps/linux/bfin/crti.S b/libc/sysdeps/linux/bfin/crti.S
--- a/libc/sysdeps/linux/bfin/crti.S	2004-12-21 15:35:58.000000000 +0700
+++ b/libc/sysdeps/linux/bfin/crti.S	2012-04-10 13:55:23.000000000 +0800
@@ -19,7 +19,6 @@
 	SP += 12;
 	UNLINK;
 	rts;
-	.size	_dummy, .-_dummy
 .align 2
 .global __init;
 .type __init, STT_FUNC;
diff -urN a/libc/sysdeps/linux/bfin/crtn.S b/libc/sysdeps/linux/bfin/crtn.S
--- a/libc/sysdeps/linux/bfin/crtn.S	2004-12-21 15:35:58.000000000 +0700
+++ b/libc/sysdeps/linux/bfin/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -19,19 +19,16 @@
 	SP += 12;
 	UNLINK;
 	rts;
-	.size	_dummy, .-_dummy
 .align 2
 .global __init;
 .type __init, STT_FUNC;
 	SP += 12;
 	UNLINK;
 	rts;
-	.size	__init, .-__init
 .align 2
 .global __fini;
 .type __fini, STT_FUNC;
 	SP += 12;
 	UNLINK;
 	rts;
-	.size	__fini, .-__fini
 	.ident	"GCC: (GNU) 3.4.1"
diff -urN a/libc/sysdeps/linux/common/bits/in.h b/libc/sysdeps/linux/common/bits/in.h
--- a/libc/sysdeps/linux/common/bits/in.h	2007-02-02 08:37:43.000000000 +0700
+++ b/libc/sysdeps/linux/common/bits/in.h	2012-04-10 13:55:23.000000000 +0800
@@ -60,6 +60,7 @@
 #define IP_DEFAULT_MULTICAST_LOOP       1
 #define IP_MAX_MEMBERSHIPS              20
 
+#if defined __USE_MISC || defined __USE_GNU
 /* Structure used to describe IP options for IP_OPTIONS. The `ip_dst'
    field is used for the first-hop gateway when using a source route
    (this gets put into the header proper).  */
@@ -91,6 +92,7 @@
     struct in_addr ipi_spec_dst;	/* Routing destination address  */
     struct in_addr ipi_addr;		/* Header destination address  */
   };
+#endif
 
 /* Options for use with `getsockopt' and `setsockopt' at the IPv6 level.
    The first word in the comment at the right is the data type used;
diff -urN a/libc/sysdeps/linux/common/bits/uClibc_fpmax.h b/libc/sysdeps/linux/common/bits/uClibc_fpmax.h
--- a/libc/sysdeps/linux/common/bits/uClibc_fpmax.h	2003-08-02 04:08:59.000000000 +0800
+++ b/libc/sysdeps/linux/common/bits/uClibc_fpmax.h	2012-04-10 13:55:23.000000000 +0800
@@ -83,18 +83,11 @@
 #endif
 
 #ifndef DECIMAL_DIG
-
-#ifdef L___strtofpmax
-/* Emit warning only once. */
-#warning DECIMAL_DIG is not defined! If you are using gcc, it may not be defining __STDC_VERSION__ as it should.
-#endif
 #if !defined(FLT_RADIX) || (FLT_RADIX != 2)
 #error unable to compensate for missing DECIMAL_DIG!
 #endif
-
 /*  ceil (1 + #mantissa * log10 (FLT_RADIX)) */
 #define DECIMAL_DIG   (1 + (((FPMAX_MANT_DIG * 100) + 331) / 332))
-
 #endif /* DECIMAL_DIG */
 
 extern __fpmax_t __strtofpmax(const char *str, char **endptr, int exp_adjust);
diff -urN a/libc/sysdeps/linux/common/bits/uClibc_stdio.h b/libc/sysdeps/linux/common/bits/uClibc_stdio.h
--- a/libc/sysdeps/linux/common/bits/uClibc_stdio.h	2007-02-22 06:28:41.000000000 +0700
+++ b/libc/sysdeps/linux/common/bits/uClibc_stdio.h	2012-04-10 13:55:23.000000000 +0800
@@ -133,17 +133,17 @@
 #define __STDIO_AUTO_THREADLOCK_VAR						\
         __UCLIBC_MUTEX_AUTO_LOCK_VAR(__infunc_user_locking)
 
-#define __STDIO_AUTO_THREADLOCK(__stream)					\
+#define __STDIO_AUTO_THREADLOCK(__stream)								\
         __UCLIBC_MUTEX_AUTO_LOCK((__stream)->__lock, __infunc_user_locking,	\
 	(__stream)->__user_locking)
 
-#define __STDIO_AUTO_THREADUNLOCK(__stream)					\
+#define __STDIO_AUTO_THREADUNLOCK(__stream)				\
         __UCLIBC_MUTEX_AUTO_UNLOCK((__stream)->__lock, __infunc_user_locking)
 
-#define __STDIO_ALWAYS_THREADLOCK(__stream)					\
+#define __STDIO_ALWAYS_THREADLOCK(__stream)	\
         __UCLIBC_MUTEX_LOCK((__stream)->__lock)
 
-#define __STDIO_ALWAYS_THREADUNLOCK(__stream)					\
+#define __STDIO_ALWAYS_THREADUNLOCK(__stream) \
         __UCLIBC_MUTEX_UNLOCK((__stream)->__lock)
 
 #define __STDIO_ALWAYS_THREADLOCK_CANCEL_UNSAFE(__stream)			\
@@ -191,7 +191,7 @@
 
 /**********************************************************************/
 #ifdef __UCLIBC_HAS_LFS__
-typedef __off64_t __offmax_t;		/* TODO -- rename this? */
+typedef __off64_t __offmax_t;	/* TODO -- rename this? */
 #else
 typedef __off_t __offmax_t;		/* TODO -- rename this? */
 #endif
@@ -201,7 +201,7 @@
 
 typedef __ssize_t __io_read_fn(void *__cookie, char *__buf, size_t __bufsize);
 typedef __ssize_t __io_write_fn(void *__cookie,
-					__const char *__buf, size_t __bufsize);
+								__const char *__buf, size_t __bufsize);
 /* NOTE: GLIBC difference!!! -- fopencookie seek function
  * For glibc, the type of pos is always (__off64_t *) but in our case
  * it is type (__off_t *) when the lib is built without large file support.
@@ -304,24 +304,24 @@
 
 #define __MASK_READING		0x0003U /* (0x0001 | 0x0002) */
 #define __FLAG_READING		0x0001U
-#define __FLAG_UNGOT		0x0002U
-#define __FLAG_EOF		0x0004U
+#define __FLAG_UNGOT    	0x0002U
+#define __FLAG_EOF			0x0004U
 #define __FLAG_ERROR		0x0008U
-#define __FLAG_WRITEONLY	0x0010U
-#define __FLAG_READONLY		0x0020U /* (__FLAG_WRITEONLY << 1) */
+#define __FLAG_WRITEONLY  	0x0010U
+#define __FLAG_READONLY  	0x0020U /* (__FLAG_WRITEONLY << 1) */
 #define __FLAG_WRITING		0x0040U
-#define __FLAG_NARROW		0x0080U
+#define __FLAG_NARROW       0x0080U
 
-#define __FLAG_FBF		0x0000U /* must be 0 */
-#define __FLAG_LBF		0x0100U
-#define __FLAG_NBF		0x0200U /* (__FLAG_LBF << 1) */
-#define __MASK_BUFMODE		0x0300U /* (__FLAG_LBF|__FLAG_NBF) */
-#define __FLAG_APPEND		0x0400U /* fixed! == O_APPEND for linux */
-#define __FLAG_WIDE		0x0800U
-/* available slot		0x1000U */
+#define __FLAG_FBF          0x0000U /* must be 0 */
+#define __FLAG_LBF          0x0100U
+#define __FLAG_NBF          0x0200U /* (__FLAG_LBF << 1) */
+#define __MASK_BUFMODE      0x0300U /* (__FLAG_LBF|__FLAG_NBF) */
+#define __FLAG_APPEND       0x0400U /* fixed! == O_APPEND for linux */
+#define __FLAG_WIDE			0x0800U
+/* available slot           0x1000U */
 #define __FLAG_FREEFILE		0x2000U
 #define __FLAG_FREEBUF		0x4000U
-#define __FLAG_LARGEFILE	0x8000U /* fixed! == 0_LARGEFILE for linux */
+#define __FLAG_LARGEFILE    0x8000U /* fixed! == 0_LARGEFILE for linux */
 #define __FLAG_FAILED_FREOPEN	__FLAG_LARGEFILE
 
 /* Note: In no-buffer mode, it would be possible to pack the necessary
@@ -366,17 +366,17 @@
 #endif
 /**********************************************************************/
 
-#define __CLEARERR_UNLOCKED(__stream)					\
+#define __CLEARERR_UNLOCKED(__stream) \
 	((void)((__stream)->__modeflags &= ~(__FLAG_EOF|__FLAG_ERROR)))
 #define __FEOF_UNLOCKED(__stream)	((__stream)->__modeflags & __FLAG_EOF)
 #define __FERROR_UNLOCKED(__stream)	((__stream)->__modeflags & __FLAG_ERROR)
 
 #ifdef __UCLIBC_HAS_THREADS__
-# define __CLEARERR(__stream)		(clearerr)(__stream)
+# define __CLEARERR(__stream)	(clearerr)(__stream)
 # define __FERROR(__stream)		(ferror)(__stream)
 # define __FEOF(__stream)		(feof)(__stream)
 #else
-# define __CLEARERR(__stream)		__CLEARERR_UNLOCKED(__stream)
+# define __CLEARERR(__stream)	__CLEARERR_UNLOCKED(__stream)
 # define __FERROR(__stream)		__FERROR_UNLOCKED(__stream)
 # define __FEOF(__stream)		__FEOF_UNLOCKED(__stream)
 #endif
@@ -387,15 +387,15 @@
 /* First define the default definitions.
    They are overridden below as necessary. */
 #define __FGETC_UNLOCKED(__stream)		(__fgetc_unlocked)((__stream))
-#define __FGETC(__stream)			(fgetc)((__stream))
-#define __GETC_UNLOCKED_MACRO(__stream)		(__fgetc_unlocked)((__stream))
+#define __FGETC(__stream)				(fgetc)((__stream))
+#define __GETC_UNLOCKED_MACRO(__stream)	(__fgetc_unlocked)((__stream))
 #define __GETC_UNLOCKED(__stream)		(__fgetc_unlocked)((__stream))
-#define __GETC(__stream)			(fgetc)((__stream))
+#define __GETC(__stream)				(fgetc)((__stream))
 
-#define __FPUTC_UNLOCKED(__c, __stream)		(__fputc_unlocked)((__c),(__stream))
+#define __FPUTC_UNLOCKED(__c, __stream)	(__fputc_unlocked)((__c),(__stream))
 #define __FPUTC(__c, __stream)			(fputc)((__c),(__stream))
-#define __PUTC_UNLOCKED_MACRO(__c, __stream)	(__fputc_unlocked)((__c),(__stream))
-#define __PUTC_UNLOCKED(__c, __stream)		(__fputc_unlocked)((__c),(__stream))
+#define __PUTC_UNLOCKED_MACRO(__c, __stream) (__fputc_unlocked)((__c),(__stream))
+#define __PUTC_UNLOCKED(__c, __stream)	(__fputc_unlocked)((__c),(__stream))
 #define __PUTC(__c, __stream)			(fputc)((__c),(__stream))
 
 
@@ -404,9 +404,9 @@
 extern FILE *__stdin;			/* For getchar() macro. */
 
 # undef  __GETC_UNLOCKED_MACRO
-# define __GETC_UNLOCKED_MACRO(__stream)				\
+# define __GETC_UNLOCKED_MACRO(__stream)					\
 		( ((__stream)->__bufpos < (__stream)->__bufgetc_u)	\
-		  ? (*(__stream)->__bufpos++)				\
+		  ? (*(__stream)->__bufpos++)						\
 		  : __fgetc_unlocked(__stream) )
 
 # if 0
@@ -421,10 +421,10 @@
 # else
 	/* Using gcc extension for safety and additional inlining. */
 #  undef  __FGETC_UNLOCKED
-#  define __FGETC_UNLOCKED(__stream)					\
+#  define __FGETC_UNLOCKED(__stream)		\
 		(__extension__ ({					\
-			FILE *__S = (__stream);				\
-			__GETC_UNLOCKED_MACRO(__S);			\
+			FILE *__S = (__stream);			\
+			__GETC_UNLOCKED_MACRO(__S);		\
 		}) )
 
 #  undef  __GETC_UNLOCKED
@@ -432,23 +432,23 @@
 
 #  ifdef __UCLIBC_HAS_THREADS__
 #   undef  __FGETC
-#   define __FGETC(__stream)						\
+#   define __FGETC(__stream)				\
 		(__extension__ ({					\
-			FILE *__S = (__stream);				\
-			((__S->__user_locking )				\
-			 ? __GETC_UNLOCKED_MACRO(__S)			\
+			FILE *__S = (__stream);			\
+			((__S->__user_locking )			\
+			 ? __GETC_UNLOCKED_MACRO(__S)	\
 			 : (fgetc)(__S));				\
 		}) )
 
 #   undef  __GETC
-#   define __GETC(__stream)			__FGETC((__stream))
+#   define __GETC(__stream)				__FGETC((__stream))
 
-#  else
+#  else 
 
 #   undef  __FGETC
 #   define __FGETC(__stream)			__FGETC_UNLOCKED((__stream))
 #   undef  __GETC
-#   define __GETC(__stream)			__FGETC_UNLOCKED((__stream))
+#   define __GETC(__stream)				__FGETC_UNLOCKED((__stream))
 
 #  endif
 # endif
@@ -463,16 +463,16 @@
 extern FILE *__stdout;			/* For putchar() macro. */
 
 # undef  __PUTC_UNLOCKED_MACRO
-# define __PUTC_UNLOCKED_MACRO(__c, __stream)				\
+# define __PUTC_UNLOCKED_MACRO(__c, __stream)						\
 		( ((__stream)->__bufpos < (__stream)->__bufputc_u)	\
-		  ? (*(__stream)->__bufpos++) = (__c)			\
+		  ? (*(__stream)->__bufpos++) = (__c)				\
 		  : __fputc_unlocked((__c),(__stream)) )
 
 # if 0
 	/* Classic macro approach.  putc{_unlocked} can have side effects.*/
 #  undef  __PUTC_UNLOCKED
-#  define __PUTC_UNLOCKED(__c, __stream)				\
-					__PUTC_UNLOCKED_MACRO((__c), (__stream))
+#  define __PUTC_UNLOCKED(__c, __stream) \
+									__PUTC_UNLOCKED_MACRO((__c), (__stream))
 #  ifndef __UCLIBC_HAS_THREADS__
 #   undef  __PUTC
 #   define __PUTC(__c, __stream)	__PUTC_UNLOCKED_MACRO((__c), (__stream))
@@ -482,10 +482,10 @@
 	/* Using gcc extension for safety and additional inlining. */
 
 #  undef  __FPUTC_UNLOCKED
-#  define __FPUTC_UNLOCKED(__c, __stream)				\
-		(__extension__ ({					\
+#  define __FPUTC_UNLOCKED(__c, __stream)		\
+		(__extension__ ({						\
 			FILE *__S = (__stream);				\
-			__PUTC_UNLOCKED_MACRO((__c),__S);		\
+			__PUTC_UNLOCKED_MACRO((__c),__S);	\
 		}) )
 
 #  undef  __PUTC_UNLOCKED
@@ -493,11 +493,11 @@
 
 #  ifdef __UCLIBC_HAS_THREADS__
 #   undef  __FPUTC
-#   define __FPUTC(__c, __stream)					\
-		(__extension__ ({					\
+#   define __FPUTC(__c, __stream)				\
+		(__extension__ ({						\
 			FILE *__S = (__stream);				\
 			((__S->__user_locking)				\
-			 ? __PUTC_UNLOCKED_MACRO((__c),__S)		\
+			 ? __PUTC_UNLOCKED_MACRO((__c),__S)	\
 			 : (fputc)((__c),__S));				\
 		}) )
 
@@ -507,9 +507,9 @@
 #  else
 
 #   undef  __FPUTC
-#   define __FPUTC(__c, __stream)		__FPUTC_UNLOCKED((__c),(__stream))
+#   define __FPUTC(__c, __stream) 		__FPUTC_UNLOCKED((__c),(__stream))
 #   undef  __PUTC
-#   define __PUTC(__c, __stream)		__FPUTC_UNLOCKED((__c),(__stream))
+#   define __PUTC(__c, __stream) 		__FPUTC_UNLOCKED((__c),(__stream))
 
 #  endif
 # endif
diff -urN a/libc/sysdeps/linux/common/_exit.c b/libc/sysdeps/linux/common/_exit.c
--- a/libc/sysdeps/linux/common/_exit.c	2005-01-06 06:11:28.000000000 +0700
+++ b/libc/sysdeps/linux/common/_exit.c	2012-04-10 13:55:23.000000000 +0800
@@ -28,12 +28,15 @@
 
 #ifndef INLINE_SYSCALL
 #define INLINE_SYSCALL(name, nr, args...) __syscall_exit (args)
+#undef __NR___syscall_exit
 #define __NR___syscall_exit __NR_exit
 static inline _syscall1(void, __syscall_exit, int, status);
 #endif
 
 void _exit(int status)
 {
-	INLINE_SYSCALL(exit, 1, status);
+	/* The loop is added only to keep gcc happy. */
+	while(1)
+		INLINE_SYSCALL(exit, 1, status);
 }
-
+weak_alias(_exit,_Exit)
diff -urN a/libc/sysdeps/linux/common/.indent.pro b/libc/sysdeps/linux/common/.indent.pro
--- a/libc/sysdeps/linux/common/.indent.pro	2000-10-29 12:47:04.000000000 +0700
+++ b/libc/sysdeps/linux/common/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/sysdeps/linux/common/inotify.c b/libc/sysdeps/linux/common/inotify.c
--- a/libc/sysdeps/linux/common/inotify.c	1970-01-01 07:00:00.000000000 +0700
+++ b/libc/sysdeps/linux/common/inotify.c	2012-09-07 05:28:12.000000000 +0800
@@ -0,0 +1,24 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * inotify interface for uClibc
+ *
+ * Copyright (C) 2006 Austin Morgan <admorgan@morgancomputers.net>
+ * Copyright (C) 2006 by Erik Andersen <andersen@codepoet.org>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#include "syscalls.h"
+#include <sys/inotify.h>
+
+#ifdef __NR_inotify_init
+_syscall0(int, inotify_init);
+#endif
+
+#ifdef __NR_inotify_add_watch
+_syscall3(int, inotify_add_watch, int, fd, const char *, path, uint32_t, mask);
+#endif
+
+#ifdef __NR_inotify_rm_watch
+_syscall2(int, inotify_rm_watch, int, fd, uint32_t, wd);
+#endif
diff -urN a/libc/sysdeps/linux/common/mincore.c b/libc/sysdeps/linux/common/mincore.c
--- a/libc/sysdeps/linux/common/mincore.c	2004-12-20 07:10:51.000000000 +0700
+++ b/libc/sysdeps/linux/common/mincore.c	2012-04-10 13:55:23.000000000 +0800
@@ -1,6 +1,6 @@
 /* 
  * Distributed under the terms of the GNU General Public License v2
- * $Header: /var/cvs/uClibc/libc/sysdeps/linux/common/mincore.c,v 1.1 2004/12/20 00:10:51 solar Exp $
+ * $Header: /home/cvsroot/RT288x_SDK/source/lib/libc/sysdeps/linux/common/mincore.c,v 1.1.1.1 2007-01-09 06:46:10 steven Exp $
  *
  * This file provides the mincore() system call to uClibc.
  * 20041215 - <solar@gentoo.org>
diff -urN a/libc/sysdeps/linux/common/open.c b/libc/sysdeps/linux/common/open.c
--- a/libc/sysdeps/linux/common/open.c	2005-01-06 06:11:28.000000000 +0700
+++ b/libc/sysdeps/linux/common/open.c	2012-04-10 13:55:23.000000000 +0800
@@ -22,7 +22,7 @@
 {
 	/* gcc may warn about mode being uninitialized.
 	 * Just ignore that, since gcc is wrong. */
-	mode_t mode;
+	mode_t mode = 0;
 
 	if (flags & O_CREAT) {
 		va_list ap;
diff -urN a/libc/sysdeps/linux/common/pselect.c b/libc/sysdeps/linux/common/pselect.c
--- a/libc/sysdeps/linux/common/pselect.c	1970-01-01 07:00:00.000000000 +0700
+++ b/libc/sysdeps/linux/common/pselect.c	2012-04-10 13:55:23.000000000 +0800
@@ -0,0 +1,64 @@
+/* Copyright (C) 1996-1998,2001,2002,2003,2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define _GNU_SOURCE
+#include <errno.h>
+#include <signal.h>
+#include <stddef.h>	/* For NULL.  */
+#include <time.h>
+#include <sys/time.h>
+#include <sys/select.h>
+
+/* Check the first NFDS descriptors each in READFDS (if not NULL) for read
+   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS
+   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out
+   after waiting the interval specified therein.  Additionally set the sigmask
+   SIGMASK for this call.  Returns the number of ready descriptors, or -1 for
+   errors.  */
+int
+pselect (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+	   const struct timespec *timeout, const sigset_t *sigmask)
+{
+  struct timeval tval;
+  int retval;
+  sigset_t savemask;
+
+  /* Change nanosecond number to microseconds.  This might mean losing
+     precision and therefore the `pselect` should be available.  But
+     for now it is hardly found.  */
+  if (timeout != NULL)
+    TIMESPEC_TO_TIMEVAL (&tval, timeout);
+
+  /* The setting and restoring of the signal mask and the select call
+     should be an atomic operation.  This can't be done without kernel
+     help.  */
+  if (sigmask != NULL)
+    sigprocmask (SIG_SETMASK, sigmask, &savemask);
+
+  /* Note the pselect() is a cancellation point.  But since we call
+     select() which itself is a cancellation point we do not have
+     to do anything here.  */
+  retval = select (nfds, readfds, writefds, exceptfds,
+		     timeout != NULL ? &tval : NULL);
+
+  if (sigmask != NULL)
+    sigprocmask (SIG_SETMASK, &savemask, NULL);
+
+  return retval;
+}
diff -urN a/libc/sysdeps/linux/common/ssp.c b/libc/sysdeps/linux/common/ssp.c
--- a/libc/sysdeps/linux/common/ssp.c	2005-06-07 08:58:04.000000000 +0800
+++ b/libc/sysdeps/linux/common/ssp.c	2012-04-10 13:55:23.000000000 +0800
@@ -1,6 +1,6 @@
 /*
  * Distributed under the terms of the GNU General Public License v2
- * $Header: /var/cvs/uClibc/libc/sysdeps/linux/common/ssp.c,v 1.6 2005/01/11 17:01:53 vapier Exp $
+ * $Header: /home/cvsroot/RT288x_SDK/source/lib/libc/sysdeps/linux/common/ssp.c,v 1.1.1.1 2007-01-09 06:46:10 steven Exp $
  *
  * This is a modified version of Hiroaki Etoh's stack smashing routines
  * implemented for glibc.
diff -urN a/libc/sysdeps/linux/common/sys/inotify.h b/libc/sysdeps/linux/common/sys/inotify.h
--- a/libc/sysdeps/linux/common/sys/inotify.h	1970-01-01 07:00:00.000000000 +0700
+++ b/libc/sysdeps/linux/common/sys/inotify.h	2012-09-07 05:28:12.000000000 +0800
@@ -0,0 +1,92 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_INOTIFY_H
+#define	_SYS_INOTIFY_H	1
+
+#include <stdint.h>
+
+
+/* Structure describing an inotify event.  */
+struct inotify_event
+{
+  int wd;		/* Watch descriptor.  */
+  uint32_t mask;	/* Watch mask.  */
+  uint32_t cookie;	/* Cookie to synchronize two events.  */
+  uint32_t len;		/* Length (including NULs) of name.  */
+  char name __flexarr;	/* Name.  */
+};
+
+
+/* Supported events suitable for MASK parameter of INOTIFY_ADD_WATCH.  */
+#define IN_ACCESS	 0x00000001	/* File was accessed.  */
+#define IN_MODIFY	 0x00000002	/* File was modified.  */
+#define IN_ATTRIB	 0x00000004	/* Metadata changed.  */
+#define IN_CLOSE_WRITE	 0x00000008	/* Writtable file was closed.  */
+#define IN_CLOSE_NOWRITE 0x00000010	/* Unwrittable file closed.  */
+#define IN_CLOSE	 (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE) /* Close.  */
+#define IN_OPEN		 0x00000020	/* File was opened.  */
+#define IN_MOVED_FROM	 0x00000040	/* File was moved from X.  */
+#define IN_MOVED_TO      0x00000080	/* File was moved to Y.  */
+#define IN_MOVE		 (IN_MOVED_FROM | IN_MOVED_TO) /* Moves.  */
+#define IN_CREATE	 0x00000100	/* Subfile was created.  */
+#define IN_DELETE	 0x00000200	/* Subfile was deleted.  */
+#define IN_DELETE_SELF	 0x00000400	/* Self was deleted.  */
+#define IN_MOVE_SELF	 0x00000800	/* Self was moved.  */
+
+/* Events sent by the kernel.  */
+#define IN_UNMOUNT	 0x00002000	/* Backing fs was unmounted.  */
+#define IN_Q_OVERFLOW	 0x00004000	/* Event queued overflowed.  */
+#define IN_IGNORED	 0x00008000	/* File was ignored.  */
+
+/* Helper events.  */
+#define IN_CLOSE	 (IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)	/* Close.  */
+#define IN_MOVE		 (IN_MOVED_FROM | IN_MOVED_TO)		/* Moves.  */
+
+/* Special flags.  */
+#define IN_ONLYDIR	 0x01000000	/* Only watch the path if it is a
+					   directory.  */
+#define IN_DONT_FOLLOW	 0x02000000	/* Do not follow a sym link.  */
+#define IN_MASK_ADD	 0x20000000	/* Add to the mask of an already
+					   existing watch.  */
+#define IN_ISDIR	 0x40000000	/* Event occurred against dir.  */
+#define IN_ONESHOT	 0x80000000	/* Only send event once.  */
+
+/* All events which a program can wait on.  */
+#define IN_ALL_EVENTS	 (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE  \
+			  | IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM	      \
+			  | IN_MOVED_TO | IN_CREATE | IN_DELETE		      \
+			  | IN_DELETE_SELF | IN_MOVE_SELF)
+
+
+__BEGIN_DECLS
+
+/* Create and initialize inotify instance.  */
+extern int inotify_init (void) __THROW;
+
+/* Add watch of object NAME to inotify instance FD.  Notify about
+   events specified by MASK.  */
+extern int inotify_add_watch (int __fd, const char *__name, uint32_t __mask)
+  __THROW;
+
+/* Remove the watch specified by WD from the inotify instance FD.  */
+extern int inotify_rm_watch (int __fd, uint32_t __wd) __THROW;
+
+__END_DECLS
+
+#endif /* sys/inotify.h */
diff -urN a/libc/sysdeps/linux/common/utime.c b/libc/sysdeps/linux/common/utime.c
--- a/libc/sysdeps/linux/common/utime.c	2007-01-28 12:32:51.000000000 +0700
+++ b/libc/sysdeps/linux/common/utime.c	2012-04-10 13:55:23.000000000 +0800
@@ -23,7 +23,7 @@
 		timevals[1].tv_usec = 0L;
 		timevals[0].tv_sec = (long int) times->actime;
 		timevals[1].tv_sec = (long int) times->modtime;
-	}
+		}
 	return utimes(file, times ? timevals : NULL);
 }
 #endif
diff -urN a/libc/sysdeps/linux/common/xattr.c b/libc/sysdeps/linux/common/xattr.c
--- a/libc/sysdeps/linux/common/xattr.c	2004-12-23 02:53:11.000000000 +0700
+++ b/libc/sysdeps/linux/common/xattr.c	2012-04-10 13:55:23.000000000 +0800
@@ -1,6 +1,6 @@
 /* 
  * Distributed under the terms of the GNU General Public License v2
- * $Header: /var/cvs/uClibc/libc/sysdeps/linux/common/xattr.c,v 1.2 2004/12/22 19:53:11 andersen Exp $
+ * $Header: /home/cvsroot/RT288x_SDK/source/lib/libc/sysdeps/linux/common/xattr.c,v 1.1.1.1 2007-01-09 06:46:10 steven Exp $
  *
  * This file provides the following Extended Attribute system calls to uClibc.
  *
diff -urN a/libc/sysdeps/linux/cris/crtn.S b/libc/sysdeps/linux/cris/crtn.S
--- a/libc/sysdeps/linux/cris/crtn.S	2003-11-05 09:21:28.000000000 +0700
+++ b/libc/sysdeps/linux/cris/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -10,7 +10,6 @@
 #NO_APP
 	movem [$sp+],$r0
 	Jump [$sp+]
-	.size	_init, .-_init
 #APP
 	
 	.section .fini
@@ -21,7 +20,6 @@
 #NO_APP
 	movem [$sp+],$r0
 	Jump [$sp+]
-	.size	_fini, .-_fini
 #APP
 	
 /*@TRAILER_BEGINS*/
diff -urN a/libc/sysdeps/linux/frv/crt0.S b/libc/sysdeps/linux/frv/crt0.S
--- a/libc/sysdeps/linux/frv/crt0.S	2004-08-27 07:36:04.000000000 +0800
+++ b/libc/sysdeps/linux/frv/crt0.S	2012-04-10 13:55:23.000000000 +0800
@@ -113,7 +113,6 @@
 
 	/* Crash if somehow `exit' returns anyways.  */
 	jmpl	@(gr0,gr0)
-.size _start,.-_start
 
 /* Define a symbol for the first piece of initialized data.  */
 	.data
diff -urN a/libc/sysdeps/linux/frv/crtn.S b/libc/sysdeps/linux/frv/crtn.S
--- a/libc/sysdeps/linux/frv/crtn.S	2004-08-27 07:36:04.000000000 +0800
+++ b/libc/sysdeps/linux/frv/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -32,7 +32,6 @@
 	ld @(sp,gr0), fp
 	addi sp,#16,sp
 	jmpl @(gr5,gr0)
-	.size	_init, .-_init
 	
 	.section .fini,"x"
 	.globl _fini
@@ -41,4 +40,3 @@
 	ld @(sp,gr0), fp
 	addi sp,#16,sp
 	jmpl @(gr5,gr0)
-	.size	_fini, .-_fini
diff -urN a/libc/sysdeps/linux/h8300/crtn.S b/libc/sysdeps/linux/h8300/crtn.S
--- a/libc/sysdeps/linux/h8300/crtn.S	2004-07-15 15:34:00.000000000 +0800
+++ b/libc/sysdeps/linux/h8300/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -14,7 +14,6 @@
 ; #NO_APP
 	mov.l	@er7+,er6
 	rts
-	.size	__init, .-__init
 ; #APP
 
 	.section .fini
@@ -24,7 +23,6 @@
 ; #NO_APP
 	mov.l	@er7+,er6
 	rts
-	.size	__fini, .-__fini
 ; #APP
 
 	.end
diff -urN a/libc/sysdeps/linux/i386/bits/kernel_types.h b/libc/sysdeps/linux/i386/bits/kernel_types.h
--- a/libc/sysdeps/linux/i386/bits/kernel_types.h	2007-03-01 04:18:52.000000000 +0700
+++ b/libc/sysdeps/linux/i386/bits/kernel_types.h	2012-04-10 13:55:23.000000000 +0800
@@ -1,6 +1,6 @@
 /* Note that we use the exact same include guard #define names
- * as asm/posix_types.h.  This will avoid gratuitous conflicts
- * with the posix_types.h kernel header, and will ensure that
+ * as asm/posix_types.h.  This will avoid gratuitous conflicts 
+ * with the posix_types.h kernel header, and will ensure that 
  * our private content, and not the kernel header, will win.
  *  -Erik
  */
diff -urN a/libc/sysdeps/linux/i386/bits/syscalls.h b/libc/sysdeps/linux/i386/bits/syscalls.h
--- a/libc/sysdeps/linux/i386/bits/syscalls.h	2007-01-26 07:22:03.000000000 +0700
+++ b/libc/sysdeps/linux/i386/bits/syscalls.h	2012-04-10 13:55:23.000000000 +0800
@@ -12,7 +12,7 @@
 #include <bits/sysnum.h>
 
 /*
-   Some of the sneaky macros in the code were taken from
+   Some of the sneaky macros in the code were taken from 
    glibc-2.2.5/sysdeps/unix/sysv/linux/i386/sysdep.h
 */
 
@@ -87,7 +87,7 @@
 type name (type1 arg1, type2 arg2, type3 arg3, type4 arg4) \
 { \
 return (type) (INLINE_SYSCALL(name, 4, arg1, arg2, arg3, arg4)); \
-}
+} 
 
 #undef _syscall5
 #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4, \
diff -urN a/libc/sysdeps/linux/i386/crt1.S b/libc/sysdeps/linux/i386/crt1.S
--- a/libc/sysdeps/linux/i386/crt1.S	2005-07-07 06:22:22.000000000 +0800
+++ b/libc/sysdeps/linux/i386/crt1.S	2012-04-10 13:55:23.000000000 +0800
@@ -129,7 +129,6 @@
 #endif
 
 	hlt			/* Crash if somehow `exit' does return.  */
-.size _start,.-_start
 
 /* Define a symbol for the first piece of initialized data.  */
 .data
diff -urN a/libc/sysdeps/linux/i386/crtn.S b/libc/sysdeps/linux/i386/crtn.S
--- a/libc/sysdeps/linux/i386/crtn.S	2005-07-07 06:22:22.000000000 +0800
+++ b/libc/sysdeps/linux/i386/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -6,7 +6,6 @@
 	popl	%ebx
 	popl	%ebp
 	ret
-.size _init,.-_init
 
 
 
@@ -16,7 +15,6 @@
 	popl	%ebx
 	popl	%ebp
 	ret
-.size _fini,.-_fini
 
 
 
diff -urN a/libc/sysdeps/linux/m68k/crtn.S b/libc/sysdeps/linux/m68k/crtn.S
--- a/libc/sysdeps/linux/m68k/crtn.S	2003-11-05 10:32:14.000000000 +0700
+++ b/libc/sysdeps/linux/m68k/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -9,7 +9,6 @@
 #NO_APP
 	unlk %a6
 	rts
-	.size	_init, .-_init
 #APP
 	
 	.section .fini
@@ -20,7 +19,6 @@
 #NO_APP
 	unlk %a6
 	rts
-	.size	_fini, .-_fini
 #APP
 	
 	.ident	"GCC: (GNU) 3.3.2"
diff -urN a/libc/sysdeps/linux/mips/bits/kernel_stat.h b/libc/sysdeps/linux/mips/bits/kernel_stat.h
--- a/libc/sysdeps/linux/mips/bits/kernel_stat.h	2003-02-23 12:39:26.000000000 +0700
+++ b/libc/sysdeps/linux/mips/bits/kernel_stat.h	2012-04-10 13:55:23.000000000 +0800
@@ -8,6 +8,8 @@
 #if __WORDSIZE == 64
 #define kernel_stat kernel_stat64
 #else
+#endif
+
 struct kernel_stat {
 	__kernel_dev_t	st_dev;
 	long		st_pad1[3];
@@ -30,7 +32,6 @@
 	long		st_blocks;
 	long		st_pad4[14];
 };
-#endif
 
 struct kernel_stat64 {
 	unsigned long	st_dev;
diff -urN a/libc/sysdeps/linux/mips/bits/kernel_types.h b/libc/sysdeps/linux/mips/bits/kernel_types.h
--- a/libc/sysdeps/linux/mips/bits/kernel_types.h	2004-02-06 14:07:16.000000000 +0700
+++ b/libc/sysdeps/linux/mips/bits/kernel_types.h	2012-04-10 13:55:23.000000000 +0800
@@ -7,6 +7,8 @@
 #ifndef _ASM_POSIX_TYPES_H
 #define _ASM_POSIX_TYPES_H
 
+#include <bits/wordsize.h>
+
 # if __WORDSIZE == 64
 typedef unsigned int	__kernel_dev_t;
 typedef unsigned int	__kernel_ino_t;
diff -urN a/libc/sysdeps/linux/mips/clone.S b/libc/sysdeps/linux/mips/clone.S
--- a/libc/sysdeps/linux/mips/clone.S	2005-07-31 12:31:58.000000000 +0800
+++ b/libc/sysdeps/linux/mips/clone.S	2012-09-07 06:39:11.000000000 +0800
@@ -24,7 +24,7 @@
 #include <sys/regdef.h>
 #define _ERRNO_H	1
 #include <bits/errno.h>
-#include <asm/asm.h>
+#include <sys/asm.h>
 
 /* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg) */
 
diff -urN a/libc/sysdeps/linux/mips/crt1.S b/libc/sysdeps/linux/mips/crt1.S
--- a/libc/sysdeps/linux/mips/crt1.S	2005-06-10 17:31:21.000000000 +0800
+++ b/libc/sysdeps/linux/mips/crt1.S	2012-04-10 13:55:23.000000000 +0800
@@ -111,7 +111,6 @@
 hlt:
 	/* Crash if somehow `__uClibc_main' returns anyway.  */
 	b   hlt
-.size __start,.-__start
 
 /* Define a symbol for the first piece of initialized data.  */
 	.data
diff -urN a/libc/sysdeps/linux/mips/crtn.S b/libc/sysdeps/linux/mips/crtn.S
--- a/libc/sysdeps/linux/mips/crtn.S	2003-11-05 08:44:16.000000000 +0700
+++ b/libc/sysdeps/linux/mips/crtn.S	2012-09-07 05:50:09.000000000 +0800
@@ -21,6 +21,7 @@
 	.set	reorder
 
 	.end	_init
+	.size	_init,.-.init
 #APP
 	
 	.section .fini
@@ -40,6 +41,7 @@
 	.set	reorder
 
 	.end	_fini
+	.size	_fini,.-.fini
 #APP
 	
 	.ident	"GCC: (GNU) 3.3.2"
diff -urN a/libc/sysdeps/linux/mips/pipe.S b/libc/sysdeps/linux/mips/pipe.S
--- a/libc/sysdeps/linux/mips/pipe.S	2007-01-26 07:01:55.000000000 +0700
+++ b/libc/sysdeps/linux/mips/pipe.S	2012-09-07 06:39:06.000000000 +0800
@@ -3,9 +3,9 @@
 /*see uClibc's sh/pipe.c and glibc-2.2.4's mips/pipe.S */
 
 #include <features.h>
-#include <asm/asm.h>
+#include <sys/asm.h>
 #include <asm/unistd.h>
-#include <asm/regdef.h>
+#include <sys/regdef.h>
 
         .globl  pipe
         .ent    pipe, 0
diff -urN a/libc/sysdeps/linux/mips/sigaction.c b/libc/sysdeps/linux/mips/sigaction.c
--- a/libc/sysdeps/linux/mips/sigaction.c	2007-02-02 09:15:09.000000000 +0700
+++ b/libc/sysdeps/linux/mips/sigaction.c	2012-04-10 13:55:23.000000000 +0800
@@ -59,6 +59,7 @@
 	kact.k_sa_handler = act->sa_handler;
 	memcpy (&kact.sa_mask, &act->sa_mask, sizeof (kact.sa_mask));
 	kact.sa_flags = act->sa_flags;
+
 #ifdef HAVE_SA_RESTORER
 #  if _MIPS_SIM == _ABIO32
 	kact.sa_restorer = act->sa_restorer;
diff -urN a/libc/sysdeps/linux/mips/sys/ucontext.h b/libc/sysdeps/linux/mips/sys/ucontext.h
--- a/libc/sysdeps/linux/mips/sys/ucontext.h	2004-07-31 03:23:55.000000000 +0800
+++ b/libc/sysdeps/linux/mips/sys/ucontext.h	2012-04-10 13:55:23.000000000 +0800
@@ -23,6 +23,7 @@
 
 #include <features.h>
 #include <signal.h>
+#include <sgidefs.h>
 
 /* Type for general register.  */
 #if _MIPS_SIM == _MIPS_SIM_ABI32
diff -urN a/libc/sysdeps/linux/mips/syscall.S b/libc/sysdeps/linux/mips/syscall.S
--- a/libc/sysdeps/linux/mips/syscall.S	2004-10-27 04:48:18.000000000 +0800
+++ b/libc/sysdeps/linux/mips/syscall.S	2012-09-07 06:38:55.000000000 +0800
@@ -17,8 +17,8 @@
    02111-1307 USA.  */
 
 #include <features.h>
-#include <asm/asm.h>
-#include <asm/regdef.h>
+#include <sys/asm.h>
+#include <sys/regdef.h>
 
 #ifdef __PIC__
 	.option pic2
diff -urN a/libc/sysdeps/linux/nios2/crtn.S b/libc/sysdeps/linux/nios2/crtn.S
--- a/libc/sysdeps/linux/nios2/crtn.S	2004-07-16 19:09:34.000000000 +0800
+++ b/libc/sysdeps/linux/nios2/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -11,7 +11,6 @@
     ldw fp, 4(sp)
     addi sp, sp, 8
     ret
-   .size   _init, .-_init
 #APP
     
    .section .fini
@@ -24,7 +23,6 @@
     ldw fp, 4(sp)
     addi sp, sp, 8
     ret
-   .size   _fini, .-_fini
 #APP
     
    .ident  "GCC: (GNU) 3.3.2"
diff -urN a/libc/sysdeps/linux/powerpc/bits/syscalls.h b/libc/sysdeps/linux/powerpc/bits/syscalls.h
--- a/libc/sysdeps/linux/powerpc/bits/syscalls.h	2007-01-26 07:01:55.000000000 +0700
+++ b/libc/sysdeps/linux/powerpc/bits/syscalls.h	2012-04-10 13:55:23.000000000 +0800
@@ -123,7 +123,7 @@
 # define ASM_INPUT_6 ASM_INPUT_5, "6" (r8)
 
 #undef _syscall0
-#define _syscall0(type,name) \
+#define _syscall0(type,name)				\
 type name(void){ \
   return (type) INLINE_SYSCALL(name, 0); \
 }
diff -urN a/libc/sysdeps/linux/powerpc/crt1.S b/libc/sysdeps/linux/powerpc/crt1.S
--- a/libc/sysdeps/linux/powerpc/crt1.S	2007-01-26 07:01:55.000000000 +0700
+++ b/libc/sysdeps/linux/powerpc/crt1.S	2012-04-10 13:55:23.000000000 +0800
@@ -56,7 +56,7 @@
 # else
 	bl	_GLOBAL_OFFSET_TABLE_-4@local
 	mflr	r31
-# endif
+#endif
 #endif
 	/* Set up an initial stack frame, and clear the LR.  */
 	li	r0,0
@@ -85,7 +85,6 @@
 	b	__uClibc_main
 #endif
 
-.size _start,.-_start
 
 /* Define a symbol for the first piece of initialized data.  */
 	.data
diff -urN a/libc/sysdeps/linux/powerpc/crtn.S b/libc/sysdeps/linux/powerpc/crtn.S
--- a/libc/sysdeps/linux/powerpc/crtn.S	2003-11-05 07:43:09.000000000 +0700
+++ b/libc/sysdeps/linux/powerpc/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -11,7 +11,6 @@
 	addi 1,1,32
 	mtlr 0
 	blr
-	.size	_init, .-_init
 #APP
 	
 	.section .fini
@@ -24,7 +23,6 @@
 	addi 1,1,32
 	mtlr 0
 	blr
-	.size	_fini, .-_fini
 #APP
 	
 	.ident	"GCC: (GNU) 3.3.1 20030626 (Debian prerelease)"
diff -urN a/libc/sysdeps/linux/powerpc/sys/procfs.h b/libc/sysdeps/linux/powerpc/sys/procfs.h
--- a/libc/sysdeps/linux/powerpc/sys/procfs.h	2007-01-26 07:01:55.000000000 +0700
+++ b/libc/sysdeps/linux/powerpc/sys/procfs.h	2012-04-10 13:55:23.000000000 +0800
@@ -39,7 +39,7 @@
 #define ELF_NGREG       48      /* includes nip, msr, lr, etc. */
 #define ELF_NFPREG      33      /* includes fpscr */
 #if __WORDSIZE == 32
-# define ELF_NVRREG      33      /* includes vscr */
+#define ELF_NVRREG      33      /* includes vscr */
 #else
 # define ELF_NVRREG      34      /* includes vscr */
 #endif
diff -urN a/libc/sysdeps/linux/sh/bits/setjmp.h b/libc/sysdeps/linux/sh/bits/setjmp.h
--- a/libc/sysdeps/linux/sh/bits/setjmp.h	2007-01-26 07:01:55.000000000 +0700
+++ b/libc/sysdeps/linux/sh/bits/setjmp.h	2012-04-10 13:55:23.000000000 +0800
@@ -45,7 +45,7 @@
 #endif
 
 #if defined __USE_MISC || defined _ASM
-# define JB_SIZE		(4 * 15)
+#define JB_SIZE		(4 * 15)
 #endif
 
 /* Test if longjmp to JMPBUF would unwind the frame
diff -urN a/libc/sysdeps/linux/sh/crt1.S b/libc/sysdeps/linux/sh/crt1.S
--- a/libc/sysdeps/linux/sh/crt1.S	2005-08-09 12:54:18.000000000 +0800
+++ b/libc/sysdeps/linux/sh/crt1.S	2012-04-10 13:55:23.000000000 +0800
@@ -68,7 +68,6 @@
 	jmp @r1
 	nop
 
-	.size _start,.-_start
 	.align	2
 
 L_main:
diff -urN a/libc/sysdeps/linux/sh/crtn.S b/libc/sysdeps/linux/sh/crtn.S
--- a/libc/sysdeps/linux/sh/crtn.S	2003-11-12 03:49:46.000000000 +0700
+++ b/libc/sysdeps/linux/sh/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -15,7 +15,6 @@
 	.align 2
 .L6:
 .L7:
-	.size	_init, .-_init
 	
 	.section .fini
 	.hidden  _fini
@@ -31,6 +30,5 @@
 	.align 2
 .L11:
 .L12:
-	.size	_fini, .-_fini
 	
 	.ident	"GCC: (GNU) 3.3.2"
diff -urN a/libc/sysdeps/linux/sh64/crtn.S b/libc/sysdeps/linux/sh64/crtn.S
--- a/libc/sysdeps/linux/sh64/crtn.S	2003-11-05 12:57:19.000000000 +0700
+++ b/libc/sysdeps/linux/sh64/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -14,7 +14,6 @@
 	ptabs	r18, tr0
 	addi.l	r15, 16, r15
 	blink	tr0, r63
-	.size	_init, .-_init
 	
 	.section .fini
 	.hidden  _fini
@@ -28,6 +27,5 @@
 	ptabs	r18, tr0
 	addi.l	r15, 16, r15
 	blink	tr0, r63
-	.size	_fini, .-_fini
 	
 	.ident	"GCC: (GNU) 3.3.2"
diff -urN a/libc/sysdeps/linux/sparc/crt1.S b/libc/sysdeps/linux/sparc/crt1.S
--- a/libc/sysdeps/linux/sparc/crt1.S	2005-07-09 08:54:07.000000000 +0800
+++ b/libc/sysdeps/linux/sparc/crt1.S	2012-04-10 13:55:23.000000000 +0800
@@ -123,7 +123,6 @@
 	illtrap 0
 #endif
 
-.size _start,.-_start
 
 /* Define a symbol for the first piece of initialized data. */
 .data
diff -urN a/libc/sysdeps/linux/sparc/crtn.S b/libc/sysdeps/linux/sparc/crtn.S
--- a/libc/sysdeps/linux/sparc/crtn.S	2005-07-09 08:47:30.000000000 +0800
+++ b/libc/sysdeps/linux/sparc/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -7,7 +7,6 @@
 	.proc	020
 	ret
 	restore
-	.size	_init, .-_init
 	
 	.section .fini
 	.align 4
@@ -16,4 +15,3 @@
 	.proc	020
 	ret
 	restore
-	.size	_fini, .-_fini
diff -urN a/libc/sysdeps/linux/v850/crtn.S b/libc/sysdeps/linux/v850/crtn.S
--- a/libc/sysdeps/linux/v850/crtn.S	2003-11-05 12:30:07.000000000 +0700
+++ b/libc/sysdeps/linux/v850/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -8,7 +8,6 @@
 	.type	__init, @function
 #NO_APP
 	jr __return_r31
-	.size	__init, .-__init
 #APP
 	
 	.section .fini
@@ -18,7 +17,6 @@
 	.type	__fini, @function
 #NO_APP
 	jr __return_r31
-	.size	__fini, .-__fini
 #APP
 	
 	.ident	"GCC: (GNU) 3.3.2"
diff -urN a/libc/sysdeps/linux/x86_64/crt1.S b/libc/sysdeps/linux/x86_64/crt1.S
--- a/libc/sysdeps/linux/x86_64/crt1.S	2005-07-14 08:04:54.000000000 +0800
+++ b/libc/sysdeps/linux/x86_64/crt1.S	2012-04-10 13:55:23.000000000 +0800
@@ -129,7 +129,6 @@
 #endif
 
 	hlt        /* Crash if somehow `exit' does return.  */
-.size _start,.-_start
 
 /* Define a symbol for the first piece of initialized data. */
 .data
diff -urN a/libc/sysdeps/linux/x86_64/crtn.S b/libc/sysdeps/linux/x86_64/crtn.S
--- a/libc/sysdeps/linux/x86_64/crtn.S	2005-07-06 09:24:17.000000000 +0800
+++ b/libc/sysdeps/linux/x86_64/crtn.S	2012-04-10 13:55:23.000000000 +0800
@@ -7,7 +7,6 @@
 .type    _init, %function
 	addq $8, %rsp
 	ret
-.size _init,.-_init
 
 
 .section .fini
@@ -15,4 +14,3 @@
 .type    _fini, %function
 	addq $8, %rsp
 	ret
-.size _fini, .-_fini
diff -urN a/libc/termios/.indent.pro b/libc/termios/.indent.pro
--- a/libc/termios/.indent.pro	2000-10-10 04:06:30.000000000 +0800
+++ b/libc/termios/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libc/unistd/.indent.pro b/libc/unistd/.indent.pro
--- a/libc/unistd/.indent.pro	2000-10-28 05:40:35.000000000 +0800
+++ b/libc/unistd/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/libcrypt/des.c b/libcrypt/des.c
--- a/libcrypt/des.c	2007-01-26 07:47:48.000000000 +0700
+++ b/libcrypt/des.c	2012-04-10 13:55:23.000000000 +0800
@@ -456,7 +456,7 @@
 	/*
 	 *	l_in, r_in, l_out, and r_out are in pseudo-"big-endian" format.
 	 */
-	u_int32_t	l, r, *kl, *kr, *kl1, *kr1;
+	u_int32_t	l=0, r=0, *kl, *kr, *kl1, *kr1;
 	u_int32_t	f, r48l, r48r;
 	int		round;
 
diff -urN a/libm/math_private.h b/libm/math_private.h
--- a/libm/math_private.h	2005-08-15 11:31:00.000000000 +0800
+++ b/libm/math_private.h	2012-04-10 13:55:23.000000000 +0800
@@ -11,7 +11,7 @@
 
 /*
  * from: @(#)fdlibm.h 5.1 93/09/24
- * $Id: math_private.h,v 1.3 2004/02/09 07:10:38 andersen Exp $
+ * $Id: math_private.h,v 1.1.1.1 2007-01-09 06:46:10 steven Exp $
  */
 
 #ifndef _MATH_PRIVATE_H_
diff -urN a/libpthread/linuxthreads/manager.c b/libpthread/linuxthreads/manager.c
--- a/libpthread/linuxthreads/manager.c	2005-07-01 08:26:56.000000000 +0800
+++ b/libpthread/linuxthreads/manager.c	2012-04-10 13:55:23.000000000 +0800
@@ -188,7 +188,7 @@
     {
 
       PDEBUG("before __libc_read\n");
-      n = __libc_read(reqfd, (char *)&request, sizeof(request));
+      n = TEMP_FAILURE_RETRY(__libc_read(reqfd, (char *)&request, sizeof(request)));
       PDEBUG("after __libc_read, n=%d\n", n);
       ASSERT(n == sizeof(request));
       switch(request.req_kind) {
@@ -479,7 +479,6 @@
   char *guardaddr = NULL;
   size_t guardsize = 0;
   int pagesize = __getpagesize();
-  int saved_errno = 0;
 
   /* First check whether we have to change the policy and if yes, whether
      we can  do this.  Normally this should be done by examining the
@@ -582,7 +581,6 @@
 			CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
 			__pthread_sig_cancel, new_thread);
 
-	  saved_errno = errno;
 	  if (pid != -1)
 	    {
 	      /* Now fill in the information about the new thread in
@@ -612,7 +610,6 @@
       pid = clone(pthread_start_thread, (void **) new_thread,
 		    CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
 		    __pthread_sig_cancel, new_thread);
-      saved_errno = errno;
     }
   /* Check if cloning succeeded */
   if (pid == -1) {
@@ -677,13 +674,17 @@
 {
   pthread_handle handle;
   pthread_readlock_info *iter, *next;
+#ifndef __ARCH_HAS_MMU__
   char *h_bottom_save;
+#endif
 
   ASSERT(th->p_exited);
   /* Make the handle invalid */
   handle =  thread_handle(th->p_tid);
   __pthread_lock(&handle->h_lock, NULL);
+#ifndef __ARCH_HAS_MMU__
   h_bottom_save = handle->h_bottom;
+#endif
   handle->h_descr = NULL;
   handle->h_bottom = (char *)(-1L);
   __pthread_unlock(&handle->h_lock);
diff -urN a/libpthread/linuxthreads/sysdeps/mips/pt-machine.h b/libpthread/linuxthreads/sysdeps/mips/pt-machine.h
--- a/libpthread/linuxthreads/sysdeps/mips/pt-machine.h	2003-02-28 15:20:00.000000000 +0700
+++ b/libpthread/linuxthreads/sysdeps/mips/pt-machine.h	2012-04-10 13:55:23.000000000 +0800
@@ -25,10 +25,14 @@
 
 #include <features.h>
 
+#ifndef PT_EI
+# define PT_EI extern inline
+#endif
+
 /* Copyright (C) 2000, 2002 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Maciej W. Rozycki <macro@ds2.pg.gda.pl>, 2000.  */
-static inline int
+PT_EI int
 _test_and_set (int *p, int v) __THROW
 {
   int r, t;
@@ -54,9 +58,6 @@
 }
 
 
-#ifndef PT_EI
-# define PT_EI extern inline
-#endif
 
 extern long int testandset (int *spinlock);
 extern int __compare_and_swap (long int *p, long int oldval, long int newval);
diff -urN a/libpthread/Makefile b/libpthread/Makefile
--- a/libpthread/Makefile	2005-05-29 07:22:12.000000000 +0800
+++ b/libpthread/Makefile	2012-04-10 13:55:23.000000000 +0800
@@ -86,7 +86,7 @@
 		$(TOPDIR)lib/$(LIBPTHREAD_SHARED).$(MAJOR_VERSION)
 endif
 ifeq ($(strip $(PTHREADS_DEBUG_SUPPORT)),y)
-	$(LD) $(LIBTHREAD_DB_LDFLAGS) --warn-unresolved-symbols -soname=$(LIBTHREAD_DB_SHARED).1 \
+	$(LD) $(LIBTHREAD_DB_LDFLAGS) -soname=$(LIBTHREAD_DB_SHARED).1 \
 		-o $(LIBTHREAD_DB_SHARED_FULLNAME) --whole-archive $(LIBTHREAD_DB) \
 		--no-whole-archive $(TOPDIR)libc/misc/internals/interp.o \
 		-L$(TOPDIR)lib -lc $(LDADD_LIBFLOAT) $(LIBGCC)
diff -urN a/libresolv/Makefile b/libresolv/Makefile
--- a/libresolv/Makefile	2005-01-19 06:30:31.000000000 +0700
+++ b/libresolv/Makefile	2012-04-10 13:55:23.000000000 +0800
@@ -31,7 +31,7 @@
 LIBRESOLV_SHARED=libresolv.so
 LIBRESOLV_SHARED_FULLNAME=libresolv-$(MAJOR_VERSION).$(MINOR_VERSION).$(SUBLEVEL).so
 
-CSRC = resolv.c
+CSRC = resolv.c ns_name.c
 OBJS=$(patsubst %.c,%.o, $(CSRC))
 
 all: $(LIBRESOLV)
diff -urN a/libresolv/ns_name.c b/libresolv/ns_name.c
--- a/libresolv/ns_name.c	1970-01-01 07:00:00.000000000 +0700
+++ b/libresolv/ns_name.c	2012-04-10 13:55:23.000000000 +0800
@@ -0,0 +1,745 @@
+/*
+ * Copyright (c) 1996,1999 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
+ * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
+ * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+ * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#if !defined(_LIBC) && !defined(lint)
+static const char rcsid[] = "$BINDId: ns_name.c,v 8.15 2000/03/30 22:53:46 vixie Exp $";
+#endif
+
+#include <sys/types.h>
+
+#include <netinet/in.h>
+#include <arpa/nameser.h>
+
+#include <ctype.h>
+#include <errno.h>
+#include <resolv.h>
+#include <string.h>
+#include <ctype.h>
+
+/* Data. */
+
+static const char	digits[] = "0123456789";
+
+/* Forward. */
+
+static int		special(int);
+static int		printable(int);
+static int		dn_find(const u_char *, const u_char *,
+				const u_char * const *,
+				const u_char * const *);
+
+/* Public. */
+
+/*
+ * ns_name_ntop(src, dst, dstsiz)
+ *	Convert an encoded domain name to printable ascii as per RFC1035.
+ * return:
+ *	Number of bytes written to buffer, or -1 (with errno set)
+ * notes:
+ *	The root is returned as "."
+ *	All other domains are returned in non absolute form
+ */
+int
+ns_name_ntop(const u_char *src, char *dst, size_t dstsiz) {
+	const u_char *cp;
+	char *dn, *eom;
+	u_char c;
+	u_int n;
+
+	cp = src;
+	dn = dst;
+	eom = dst + dstsiz;
+
+	while ((n = *cp++) != 0) {
+		if ((n & NS_CMPRSFLGS) != 0 && n != 0x41) {
+			/* Some kind of compression pointer. */
+			__set_errno (EMSGSIZE);
+			return (-1);
+		}
+		if (dn != dst) {
+			if (dn >= eom) {
+				__set_errno (EMSGSIZE);
+				return (-1);
+			}
+			*dn++ = '.';
+		}
+
+		if (n == 0x41) {
+			n = *cp++ / 8;
+			if (dn + n * 2 + 4 >= eom) {
+				__set_errno (EMSGSIZE);
+				return (-1);
+			}
+			*dn++ = '\\';
+			*dn++ = '[';
+			*dn++ = 'x';
+
+			while (n-- > 0) {
+				c = *cp++;
+				unsigned u = c >> 4;
+				*dn++ = u > 9 ? 'a' + u - 10 : '0' + u;
+				u = c & 0xf;
+				*dn++ = u > 9 ? 'a' + u - 10 : '0' + u;
+			}
+
+			*dn++ = ']';
+			continue;
+		}
+
+		if (dn + n >= eom) {
+			__set_errno (EMSGSIZE);
+			return (-1);
+		}
+		for ((void)NULL; n > 0; n--) {
+			c = *cp++;
+			if (special(c)) {
+				if (dn + 1 >= eom) {
+					__set_errno (EMSGSIZE);
+					return (-1);
+				}
+				*dn++ = '\\';
+				*dn++ = (char)c;
+			} else if (!printable(c)) {
+				if (dn + 3 >= eom) {
+					__set_errno (EMSGSIZE);
+					return (-1);
+				}
+				*dn++ = '\\';
+				*dn++ = digits[c / 100];
+				*dn++ = digits[(c % 100) / 10];
+				*dn++ = digits[c % 10];
+			} else {
+				if (dn >= eom) {
+					__set_errno (EMSGSIZE);
+					return (-1);
+				}
+				*dn++ = (char)c;
+			}
+		}
+	}
+	if (dn == dst) {
+		if (dn >= eom) {
+			__set_errno (EMSGSIZE);
+			return (-1);
+		}
+		*dn++ = '.';
+	}
+	if (dn >= eom) {
+		__set_errno (EMSGSIZE);
+		return (-1);
+	}
+	*dn++ = '\0';
+	return (dn - dst);
+}
+
+/*
+ * ns_name_pton(src, dst, dstsiz)
+ *	Convert a ascii string into an encoded domain name as per RFC1035.
+ * return:
+ *	-1 if it fails
+ *	1 if string was fully qualified
+ *	0 is string was not fully qualified
+ * notes:
+ *	Enforces label and domain length limits.
+ */
+
+int
+ns_name_pton(const char *src, u_char *dst, size_t dstsiz) {
+	u_char *label, *bp, *eom;
+	int c, n, escaped;
+	char *cp;
+
+	escaped = 0;
+	bp = dst;
+	eom = dst + dstsiz;
+	label = bp++;
+
+	while ((c = *src++) != 0) {
+		if (escaped) {
+			if ((cp = strchr(digits, c)) != NULL) {
+				n = (cp - digits) * 100;
+				if ((c = *src++) == 0 ||
+				    (cp = strchr(digits, c)) == NULL) {
+					__set_errno (EMSGSIZE);
+					return (-1);
+				}
+				n += (cp - digits) * 10;
+				if ((c = *src++) == 0 ||
+				    (cp = strchr(digits, c)) == NULL) {
+					__set_errno (EMSGSIZE);
+					return (-1);
+				}
+				n += (cp - digits);
+				if (n > 255) {
+					__set_errno (EMSGSIZE);
+					return (-1);
+				}
+				c = n;
+			} else if (c == '[' && label == bp - 1 && *src == 'x') {
+				/* Theoretically we would have to handle \[o
+				   as well but we do not since we do not need
+				   it internally.  */
+				*label = 0x41;
+				label = bp++;
+				++src;
+				while (isxdigit (*src)) {
+					n = *src > '9' ? *src - 'a' + 10 : *src - '0';
+					++src;
+					if (! isxdigit(*src)) {
+						__set_errno (EMSGSIZE);
+						return (-1);
+					}
+					n <<= 4;
+					n += *src > '9' ? *src - 'a' + 10 : *src - '0';
+					if (bp + 1 >= eom) {
+						__set_errno (EMSGSIZE);
+						return (-1);
+					}
+					*bp++ = n;
+					++src;
+				}
+				*label = (bp - label - 1) * 8;
+				if (*src++ != ']' || *src++ != '.') {
+					__set_errno (EMSGSIZE);
+					return (-1);
+				}
+				escaped = 0;
+				label = bp++;
+				if (bp >= eom) {
+					__set_errno (EMSGSIZE);
+					return (-1);
+				}
+				continue;
+			}
+			escaped = 0;
+		} else if (c == '\\') {
+			escaped = 1;
+			continue;
+		} else if (c == '.') {
+			c = (bp - label - 1);
+			if ((c & NS_CMPRSFLGS) != 0) {	/* Label too big. */
+				__set_errno (EMSGSIZE);
+				return (-1);
+			}
+			if (label >= eom) {
+				__set_errno (EMSGSIZE);
+				return (-1);
+			}
+			*label = c;
+			/* Fully qualified ? */
+			if (*src == '\0') {
+				if (c != 0) {
+					if (bp >= eom) {
+						__set_errno (EMSGSIZE);
+						return (-1);
+					}
+					*bp++ = '\0';
+				}
+				if ((bp - dst) > MAXCDNAME) {
+					__set_errno (EMSGSIZE);
+					return (-1);
+				}
+				return (1);
+			}
+			if (c == 0 || *src == '.') {
+				__set_errno (EMSGSIZE);
+				return (-1);
+			}
+			label = bp++;
+			continue;
+		}
+		if (bp >= eom) {
+			__set_errno (EMSGSIZE);
+			return (-1);
+		}
+		*bp++ = (u_char)c;
+	}
+	c = (bp - label - 1);
+	if ((c & NS_CMPRSFLGS) != 0) {		/* Label too big. */
+		__set_errno (EMSGSIZE);
+		return (-1);
+	}
+	if (label >= eom) {
+		__set_errno (EMSGSIZE);
+		return (-1);
+	}
+	*label = c;
+	if (c != 0) {
+		if (bp >= eom) {
+			__set_errno (EMSGSIZE);
+			return (-1);
+		}
+		*bp++ = 0;
+	}
+	if ((bp - dst) > MAXCDNAME) {	/* src too big */
+		__set_errno (EMSGSIZE);
+		return (-1);
+	}
+	return (0);
+}
+
+/*
+ * ns_name_ntol(src, dst, dstsiz)
+ *	Convert a network strings labels into all lowercase.
+ * return:
+ *	Number of bytes written to buffer, or -1 (with errno set)
+ * notes:
+ *	Enforces label and domain length limits.
+ */
+
+int
+ns_name_ntol(const u_char *src, u_char *dst, size_t dstsiz) {
+	const u_char *cp;
+	u_char *dn, *eom;
+	u_char c;
+	u_int n;
+
+	cp = src;
+	dn = dst;
+	eom = dst + dstsiz;
+
+	while ((n = *cp++) != 0) {
+		if ((n & NS_CMPRSFLGS) != 0) {
+			/* Some kind of compression pointer. */
+			__set_errno (EMSGSIZE);
+			return (-1);
+		}
+		*dn++ = n;
+		if (dn + n >= eom) {
+			__set_errno (EMSGSIZE);
+			return (-1);
+		}
+		for ((void)NULL; n > 0; n--) {
+			c = *cp++;
+			if (isupper(c))
+				*dn++ = tolower(c);
+			else
+				*dn++ = c;
+		}
+	}
+	*dn++ = '\0';
+	return (dn - dst);
+}
+
+/*
+ * ns_name_unpack(msg, eom, src, dst, dstsiz)
+ *	Unpack a domain name from a message, source may be compressed.
+ * return:
+ *	-1 if it fails, or consumed octets if it succeeds.
+ */
+int
+ns_name_unpack(const u_char *msg, const u_char *eom, const u_char *src,
+	       u_char *dst, size_t dstsiz)
+{
+	const u_char *srcp, *dstlim;
+	u_char *dstp;
+	int n, len, checked;
+
+	len = -1;
+	checked = 0;
+	dstp = dst;
+	srcp = src;
+	dstlim = dst + dstsiz;
+	if (srcp < msg || srcp >= eom) {
+		__set_errno (EMSGSIZE);
+		return (-1);
+	}
+	/* Fetch next label in domain name. */
+	while ((n = *srcp++) != 0) {
+		/* Check for indirection. */
+		switch (n & NS_CMPRSFLGS) {
+		case 0x40:
+			if (n == 0x41) {
+				if (dstp + 1 >= dstlim) {
+					__set_errno (EMSGSIZE);
+					return (-1);
+			  	}
+				*dstp++ = 0x41;
+				n = *srcp++ / 8;
+				++checked;
+			} else {
+				__set_errno (EMSGSIZE);
+				return (-1);		/* flag error */
+			}
+			/* FALLTHROUGH */
+		case 0:
+			/* Limit checks. */
+			if (dstp + n + 1 >= dstlim || srcp + n >= eom) {
+				__set_errno (EMSGSIZE);
+				return (-1);
+			}
+			checked += n + 1;
+			dstp = mempcpy(dstp, srcp - 1, n + 1);
+			srcp += n;
+			break;
+
+		case NS_CMPRSFLGS:
+			if (srcp >= eom) {
+				__set_errno (EMSGSIZE);
+				return (-1);
+			}
+			if (len < 0)
+				len = srcp - src + 1;
+			srcp = msg + (((n & 0x3f) << 8) | (*srcp & 0xff));
+			if (srcp < msg || srcp >= eom) {  /* Out of range. */
+				__set_errno (EMSGSIZE);
+				return (-1);
+			}
+			checked += 2;
+			/*
+			 * Check for loops in the compressed name;
+			 * if we've looked at the whole message,
+			 * there must be a loop.
+			 */
+			if (checked >= eom - msg) {
+				__set_errno (EMSGSIZE);
+				return (-1);
+			}
+			break;
+
+		default:
+			__set_errno (EMSGSIZE);
+			return (-1);			/* flag error */
+		}
+	}
+	*dstp = '\0';
+	if (len < 0)
+		len = srcp - src;
+	return (len);
+}
+
+/*
+ * ns_name_pack(src, dst, dstsiz, dnptrs, lastdnptr)
+ *	Pack domain name 'domain' into 'comp_dn'.
+ * return:
+ *	Size of the compressed name, or -1.
+ * notes:
+ *	'dnptrs' is an array of pointers to previous compressed names.
+ *	dnptrs[0] is a pointer to the beginning of the message. The array
+ *	ends with NULL.
+ *	'lastdnptr' is a pointer to the end of the array pointed to
+ *	by 'dnptrs'.
+ * Side effects:
+ *	The list of pointers in dnptrs is updated for labels inserted into
+ *	the message as we compress the name.  If 'dnptr' is NULL, we don't
+ *	try to compress names. If 'lastdnptr' is NULL, we don't update the
+ *	list.
+ */
+int
+ns_name_pack(const u_char *src, u_char *dst, int dstsiz,
+	     const u_char **dnptrs, const u_char **lastdnptr)
+{
+	u_char *dstp;
+	const u_char **cpp, **lpp, *eob, *msg;
+	const u_char *srcp;
+	int n, l, first = 1;
+
+	srcp = src;
+	dstp = dst;
+	eob = dstp + dstsiz;
+	lpp = cpp = NULL;
+	if (dnptrs != NULL) {
+		if ((msg = *dnptrs++) != NULL) {
+			for (cpp = dnptrs; *cpp != NULL; cpp++)
+				(void)NULL;
+			lpp = cpp;	/* end of list to search */
+		}
+	} else
+		msg = NULL;
+
+	/* make sure the domain we are about to add is legal */
+	l = 0;
+	do {
+		n = *srcp;
+		if ((n & NS_CMPRSFLGS) != 0 && n != 0x41) {
+			__set_errno (EMSGSIZE);
+			return (-1);
+		}
+		if (n == 0x41)
+			n = *++srcp / 8;
+		l += n + 1;
+		if (l > MAXCDNAME) {
+			__set_errno (EMSGSIZE);
+			return (-1);
+		}
+		srcp += n + 1;
+	} while (n != 0);
+
+	/* from here on we need to reset compression pointer array on error */
+	srcp = src;
+	do {
+		/* Look to see if we can use pointers. */
+		n = *srcp;
+		if (n != 0 && n != 0x41 && msg != NULL) {
+			l = dn_find(srcp, msg, (const u_char * const *)dnptrs,
+				    (const u_char * const *)lpp);
+			if (l >= 0) {
+				if (dstp + 1 >= eob) {
+					goto cleanup;
+				}
+				*dstp++ = (l >> 8) | NS_CMPRSFLGS;
+				*dstp++ = l % 256;
+				return (dstp - dst);
+			}
+			/* Not found, save it. */
+			if (lastdnptr != NULL && cpp < lastdnptr - 1 &&
+			    (dstp - msg) < 0x4000 && first) {
+				*cpp++ = dstp;
+				*cpp = NULL;
+				first = 0;
+			}
+		}
+		/* copy label to buffer */
+		if ((n & NS_CMPRSFLGS) != 0 && n != 0x41) {		/* Should not happen. */
+			goto cleanup;
+		}
+		if (n == 0x41) {
+			n = *++srcp / 8;
+			if (dstp + 1 >= eob)
+				goto cleanup;
+			*dstp++ = 0x41;
+		}
+		if (dstp + 1 + n >= eob) {
+			goto cleanup;
+		}
+		memcpy(dstp, srcp, n + 1);
+		srcp += n + 1;
+		dstp += n + 1;
+	} while (n != 0);
+
+	if (dstp > eob) {
+cleanup:
+		if (msg != NULL)
+			*lpp = NULL;
+		__set_errno (EMSGSIZE);
+		return (-1);
+	}
+	return (dstp - dst);
+}
+
+/*
+ * ns_name_uncompress(msg, eom, src, dst, dstsiz)
+ *	Expand compressed domain name to presentation format.
+ * return:
+ *	Number of bytes read out of `src', or -1 (with errno set).
+ * note:
+ *	Root domain returns as "." not "".
+ */
+int
+ns_name_uncompress(const u_char *msg, const u_char *eom, const u_char *src,
+		   char *dst, size_t dstsiz)
+{
+	u_char tmp[NS_MAXCDNAME];
+	int n;
+
+	if ((n = ns_name_unpack(msg, eom, src, tmp, sizeof tmp)) == -1)
+		return (-1);
+	if (ns_name_ntop(tmp, dst, dstsiz) == -1)
+		return (-1);
+	return (n);
+}
+
+/*
+ * ns_name_compress(src, dst, dstsiz, dnptrs, lastdnptr)
+ *	Compress a domain name into wire format, using compression pointers.
+ * return:
+ *	Number of bytes consumed in `dst' or -1 (with errno set).
+ * notes:
+ *	'dnptrs' is an array of pointers to previous compressed names.
+ *	dnptrs[0] is a pointer to the beginning of the message.
+ *	The list ends with NULL.  'lastdnptr' is a pointer to the end of the
+ *	array pointed to by 'dnptrs'. Side effect is to update the list of
+ *	pointers for labels inserted into the message as we compress the name.
+ *	If 'dnptr' is NULL, we don't try to compress names. If 'lastdnptr'
+ *	is NULL, we don't update the list.
+ */
+int
+ns_name_compress(const char *src, u_char *dst, size_t dstsiz,
+		 const u_char **dnptrs, const u_char **lastdnptr)
+{
+	u_char tmp[NS_MAXCDNAME];
+
+	if (ns_name_pton(src, tmp, sizeof tmp) == -1)
+		return (-1);
+	return (ns_name_pack(tmp, dst, dstsiz, dnptrs, lastdnptr));
+}
+
+/*
+ * Reset dnptrs so that there are no active references to pointers at or
+ * after src.
+ */
+void
+ns_name_rollback(const u_char *src, const u_char **dnptrs,
+		 const u_char **lastdnptr)
+{
+	while (dnptrs < lastdnptr && *dnptrs != NULL) {
+		if (*dnptrs >= src) {
+			*dnptrs = NULL;
+			break;
+		}
+		dnptrs++;
+	}
+}
+
+/*
+ * ns_name_skip(ptrptr, eom)
+ *	Advance *ptrptr to skip over the compressed name it points at.
+ * return:
+ *	0 on success, -1 (with errno set) on failure.
+ */
+int
+ns_name_skip(const u_char **ptrptr, const u_char *eom) {
+	const u_char *cp;
+	u_int n;
+
+	cp = *ptrptr;
+	while (cp < eom && (n = *cp++) != 0) {
+		/* Check for indirection. */
+		switch (n & NS_CMPRSFLGS) {
+		case 0:			/* normal case, n == len */
+			cp += n;
+			continue;
+		case NS_CMPRSFLGS:	/* indirection */
+			cp++;
+			break;
+		default:		/* illegal type */
+			__set_errno (EMSGSIZE);
+			return (-1);
+		}
+		break;
+	}
+	if (cp > eom) {
+		__set_errno (EMSGSIZE);
+		return (-1);
+	}
+	*ptrptr = cp;
+	return (0);
+}
+
+/* Private. */
+
+/*
+ * special(ch)
+ *	Thinking in noninternationalized USASCII (per the DNS spec),
+ *	is this characted special ("in need of quoting") ?
+ * return:
+ *	boolean.
+ */
+static int
+special(int ch) {
+	switch (ch) {
+	case 0x22: /* '"' */
+	case 0x2E: /* '.' */
+	case 0x3B: /* ';' */
+	case 0x5C: /* '\\' */
+	/* Special modifiers in zone files. */
+	case 0x40: /* '@' */
+	case 0x24: /* '$' */
+		return (1);
+	default:
+		return (0);
+	}
+}
+
+/*
+ * printable(ch)
+ *	Thinking in noninternationalized USASCII (per the DNS spec),
+ *	is this character visible and not a space when printed ?
+ * return:
+ *	boolean.
+ */
+static int
+printable(int ch) {
+	return (ch > 0x20 && ch < 0x7f);
+}
+
+/*
+ *	Thinking in noninternationalized USASCII (per the DNS spec),
+ *	convert this character to lower case if it's upper case.
+ */
+static int
+mklower(int ch) {
+	if (ch >= 0x41 && ch <= 0x5A)
+		return (ch + 0x20);
+	return (ch);
+}
+
+/*
+ * dn_find(domain, msg, dnptrs, lastdnptr)
+ *	Search for the counted-label name in an array of compressed names.
+ * return:
+ *	offset from msg if found, or -1.
+ * notes:
+ *	dnptrs is the pointer to the first name on the list,
+ *	not the pointer to the start of the message.
+ */
+static int
+dn_find(const u_char *domain, const u_char *msg,
+	const u_char * const *dnptrs,
+	const u_char * const *lastdnptr)
+{
+	const u_char *dn, *cp, *sp;
+	const u_char * const *cpp;
+	u_int n;
+
+	for (cpp = dnptrs; cpp < lastdnptr; cpp++) {
+		sp = *cpp;
+		/*
+		 * terminate search on:
+		 * root label
+		 * compression pointer
+		 * unusable offset
+		 */
+		while (*sp != 0 && (*sp & NS_CMPRSFLGS) == 0 &&
+		       (sp - msg) < 0x4000) {
+			dn = domain;
+			cp = sp;
+			while ((n = *cp++) != 0) {
+				/*
+				 * check for indirection
+				 */
+				switch (n & NS_CMPRSFLGS) {
+				case 0:		/* normal case, n == len */
+					if (n != *dn++)
+						goto next;
+					for ((void)NULL; n > 0; n--)
+						if (mklower(*dn++) !=
+						    mklower(*cp++))
+							goto next;
+					/* Is next root for both ? */
+					if (*dn == '\0' && *cp == '\0')
+						return (sp - msg);
+					if (*dn)
+						continue;
+					goto next;
+
+				case NS_CMPRSFLGS:	/* indirection */
+					cp = msg + (((n & 0x3f) << 8) | *cp);
+					break;
+
+				default:	/* illegal type */
+					__set_errno (EMSGSIZE);
+					return (-1);
+				}
+			}
+ next:
+			sp += *sp + 1;
+		}
+	}
+	__set_errno (ENOENT);
+	return (-1);
+}
diff -urN a/libresolv/resolv.c b/libresolv/resolv.c
--- a/libresolv/resolv.c	2002-12-12 08:56:48.000000000 +0700
+++ b/libresolv/resolv.c	2012-04-10 13:55:23.000000000 +0800
@@ -20,11 +20,27 @@
  *
  */
 
-#include <features.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <arpa/nameser.h>
+#include <ctype.h>
+#include <errno.h>
+#include <resolv.h>
+#include <string.h>
+#include <ctype.h>
 
-void __stub1(void)
+
+/*
+ * Pack domain name 'exp_dn' in presentation form into 'comp_dn'.
+ * Return the size of the compressed name or -1.
+ * 'length' is the size of the array pointed to by 'comp_dn'.
+ */
+int
+dn_comp(const char *src, u_char *dst, int dstsiz,
+        u_char **dnptrs, u_char **lastdnptr)
 {
-	return;
+        return (ns_name_compress(src, dst, (size_t)dstsiz,
+                                 (const u_char **)dnptrs,
+                                 (const u_char **)lastdnptr));
 }
-link_warning (__stub1, "the `libresolv' library is a stub.  Do you really need it?")
 
diff -urN a/Makefile b/Makefile
--- a/Makefile	2007-02-02 09:24:29.000000000 +0700
+++ b/Makefile	2012-04-17 19:28:25.000000000 +0800
@@ -30,7 +30,7 @@
 
 DIRS = ldso libc libcrypt libresolv libnsl libutil libm libpthread librt
 ifeq ($(strip $(UCLIBC_HAS_GETTEXT_AWARENESS)),y)
-	DIRS += libintl
+    DIRS += libintl
 endif
 
 ifeq ($(strip $(HAVE_DOT_CONFIG)),y)
@@ -72,7 +72,7 @@
 	@if [ ! -x ./extra/config/conf ] ; then \
 	    $(MAKE) -C extra/config conf; \
 	fi;
-	$(RM) -r include/bits
+	$(RM) -rf include/bits
 	$(INSTALL) -d include/bits
 	@./extra/config/conf -o extra/Configs/Config.in
 
@@ -224,7 +224,7 @@
 	-@for i in `find  $(PREFIX)$(DEVEL_PREFIX) -type d` ; do \
 	    chmod 755 $$i; chmod 644 $$i/*.h > /dev/null 2>&1; \
 	done;
-	-find $(PREFIX)$(DEVEL_PREFIX) -name .svn | xargs $(RM) -r;
+	-find $(PREFIX)$(DEVEL_PREFIX) -name .svn | xargs $(RM) -rf;
 	-chown -R `id | sed 's/^uid=\([0-9]*\).*gid=\([0-9]*\).*$$/\1:\2/'` $(PREFIX)$(DEVEL_PREFIX)
 ifeq ($(strip $(HAVE_SHARED)),y)
 	for i in `find lib/ -type l -name 'lib[a-zA-Z]*.so' | \
@@ -299,27 +299,27 @@
 	$(MAKE) -C extra/config ncurses mconf
 
 menuconfig: extra/config/mconf
-	$(RM) -r include/bits
+	$(RM) -rf include/bits
 	$(INSTALL) -d include/bits
 	@./extra/config/mconf extra/Configs/Config.in
 
 config: extra/config/conf
-	$(RM) -r include/bits
+	$(RM) -rf include/bits
 	$(INSTALL) -d include/bits
 	@./extra/config/conf extra/Configs/Config.in
 
 oldconfig: extra/config/conf
-	$(RM) -r include/bits
+	$(RM) -rf include/bits
 	$(INSTALL) -d include/bits
 	@./extra/config/conf -o extra/Configs/Config.in
 
 randconfig: extra/config/conf
-	$(RM) -r include/bits
+	$(RM) -rf include/bits
 	$(INSTALL) -d include/bits
 	@./extra/config/conf -r extra/Configs/Config.in
 
 allyesconfig: extra/config/conf
-	$(RM) -r include/bits
+	$(RM) -rf include/bits
 	$(INSTALL) -d include/bits
 	@./extra/config/conf -y extra/Configs/Config.in
 	sed -i -e "s/^DODEBUG=.*/# DODEBUG is not set/" .config
@@ -330,12 +330,12 @@
 	@./extra/config/conf -o extra/Configs/Config.in
 
 allnoconfig: extra/config/conf
-	$(RM) -r include/bits
+	$(RM) -rf include/bits
 	$(INSTALL) -d include/bits
 	@./extra/config/conf -n extra/Configs/Config.in
 
 defconfig: extra/config/conf
-	$(RM) -r include/bits
+	$(RM) -rf include/bits
 	$(INSTALL) -d include/bits
 	@./extra/config/conf -d extra/Configs/Config.in
 
@@ -368,7 +368,7 @@
 distclean: clean
 	$(RM) .config .config.old .config.cmd
 	$(MAKE) -C extra clean
-
+ 
 dist release:
 	$(RM) -r ../uClibc-$(VERSION) ../uClibc-$(VERSION).tar.bz2
 	svn -q export . ../uClibc-$(VERSION)
diff -urN a/Rules.mak b/Rules.mak
--- a/Rules.mak	2007-03-01 04:12:06.000000000 +0700
+++ b/Rules.mak	2012-09-07 04:56:33.000000000 +0800
@@ -167,7 +167,7 @@
 	CPU_CFLAGS-$(CONFIG_MIPS_ISA_2)+=-mips2 -mtune=mips2
 	CPU_CFLAGS-$(CONFIG_MIPS_ISA_3)+=-mips3 -mtune=mips3
 	CPU_CFLAGS-$(CONFIG_MIPS_ISA_4)+=-mips4 -mtune=mips4
-	CPU_CFLAGS-$(CONFIG_MIPS_ISA_MIPS32)+=-mips32 -mtune=mips32
+	CPU_CFLAGS-$(CONFIG_MIPS_ISA_MIPS32)+=-mips32r2 -march=mips32r2
 	CPU_CFLAGS-$(CONFIG_MIPS_ISA_MIPS64)+=-mips64 -mtune=mips32
 endif
 
@@ -259,7 +259,7 @@
 OPTIMIZATION+=$(call check_gcc,-funit-at-a-time,)
 
 # Add a bunch of extra pedantic annoyingly strict checks
-XWARNINGS=$(subst ",, $(strip $(WARNINGS))) -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing
+XWARNINGS=$(subst ",, $(strip $(WARNINGS))) -Wstrict-prototypes -Wno-trigraphs
 XARCH_CFLAGS=$(subst ",, $(strip $(ARCH_CFLAGS)))
 CPU_CFLAGS=$(subst ",, $(strip $(CPU_CFLAGS-y)))
 
@@ -309,9 +309,7 @@
 LDFLAGS+=-z now
 endif
 
-# Sigh, some stupid versions of gcc can't seem to cope with '-iwithprefix include'
-#CFLAGS+=-iwithprefix include
-CFLAGS+=-isystem $(shell $(CC) -print-file-name=include)
+CFLAGS += -iwithprefix include-fixed -iwithprefix include
 
 ifneq ($(DOASSERTS),y)
     CFLAGS += -DNDEBUG
diff -urN a/test/pwd_grp/.indent.pro b/test/pwd_grp/.indent.pro
--- a/test/pwd_grp/.indent.pro	2000-10-19 07:38:13.000000000 +0800
+++ b/test/pwd_grp/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/test/signal/.indent.pro b/test/signal/.indent.pro
--- a/test/signal/.indent.pro	2000-10-19 07:38:13.000000000 +0800
+++ b/test/signal/.indent.pro	1970-01-01 07:00:00.000000000 +0700
@@ -1,33 +0,0 @@
---blank-lines-after-declarations
---blank-lines-after-procedures
---break-before-boolean-operator
---no-blank-lines-after-commas
---braces-on-if-line
---braces-on-struct-decl-line
---comment-indentation25
---declaration-comment-column25
---no-comment-delimiters-on-blank-lines
---cuddle-else
---continuation-indentation4
---case-indentation0
---else-endif-column33
---space-after-cast
---line-comments-indentation0
---declaration-indentation1
---dont-format-first-column-comments
---dont-format-comments
---honour-newlines
---indent-level4
-/* changed from 0 to 4 */
---parameter-indentation4
---line-length78 /* changed from 75 */
---continue-at-parentheses
---no-space-after-function-call-names
---dont-break-procedure-type
---dont-star-comments
---leave-optional-blank-lines
---dont-space-special-semicolon
---tab-size4
-/* additions by Mark */
---case-brace-indentation0
---leave-preprocessor-space
diff -urN a/utils/ldconfig.c b/utils/ldconfig.c
--- a/utils/ldconfig.c	2007-01-26 07:22:03.000000000 +0700
+++ b/utils/ldconfig.c	2012-04-10 13:55:23.000000000 +0800
@@ -773,7 +773,7 @@
 	    lib_ptr = (libentry_t *)cur_lib;
 	}
 	if (write(cachefd, lib_ptr, sizeof (libentry_t)) !=
-	    sizeof (libentry_t))
+		sizeof (libentry_t))
 	err(EXIT_FATAL,"can't write %s~ (%s)", cachefile, strerror(errno));
     }
 
@@ -968,12 +968,12 @@
     if (chroot_dir && *chroot_dir) {
 	if (chroot(chroot_dir) < 0) {
 	    if (chdir(chroot_dir) < 0)
-		err(EXIT_FATAL,"couldn't chroot to %s (%s)", chroot_dir, strerror(errno));
+	    err(EXIT_FATAL,"couldn't chroot to %s (%s)", chroot_dir, strerror(errno));
 	}
 	else
 	{
-	    if (chdir("/") < 0)
-		err(EXIT_FATAL,"couldn't chdir to / (%s)", strerror(errno));
+	if (chdir("/") < 0)
+	    err(EXIT_FATAL,"couldn't chdir to / (%s)", strerror(errno));
 	    chroot_dir = NULL;
 	}
     }
diff -urN a/utils/Makefile b/utils/Makefile
--- a/utils/Makefile	2007-01-26 07:22:03.000000000 +0700
+++ b/utils/Makefile	2012-09-07 08:33:41.000000000 +0800
@@ -86,19 +86,19 @@
 endif
 
 ldd.host: ldd.c
-	$(HOSTCC) $(HOSTCFLAGS) -Wl,-s \
+	$(HOSTCC) $(HOSTCFLAGS) $(BUILD_LDFLAGS) \
  		-DUCLIBC_RUNTIME_PREFIX=\"$(RUNTIME_PREFIX)\" $(HOST_LDSO_CACHE_FLAG) \
 		-DUCLIBC_LDSO=$(UCLIBC_LDSO) -I. -I../ldso/include \
 		$^ -o $@
 
 ldconfig.host: ldconfig.c chroot_realpath.c
-	$(HOSTCC) $(HOSTCFLAGS) -Wl,-s \
+	$(HOSTCC) $(HOSTCFLAGS) $(BUILD_LDFLAGS) \
  		-DUCLIBC_RUNTIME_PREFIX=\"$(RUNTIME_PREFIX)\" $(HOST_LDSO_CACHE_FLAG) \
 		-DUCLIBC_LDSO=$(UCLIBC_LDSO) -I. -I../ldso/include \
 		$^ -o $@
 
 readelf.host: readelf.c
-	$(HOSTCC) $(HOSTCFLAGS) -Wl,-s $^ -o $@
+	$(HOSTCC) $(HOSTCFLAGS) $(BUILD_LDFLAGS) $^ -o $@
 
 clean:
 	$(RM) $(TARGETS) *.o *~ core *.target elf.h iconv *.host
@@ -106,11 +106,11 @@
 install: all
 ifeq ($(strip $(HAVE_SHARED)),y)
 	$(INSTALL) -d $(PREFIX)$(RUNTIME_PREFIX)sbin
-	$(INSTALL) -d $(PREFIX)$(RUNTIME_PREFIX)usr/bin
-	$(INSTALL) -m 755 ldd $(PREFIX)$(RUNTIME_PREFIX)usr/bin/ldd
+	$(INSTALL) -d $(PREFIX)$(RUNTIME_PREFIX)bin
+	$(INSTALL) -m 755 ldd $(PREFIX)$(RUNTIME_PREFIX)bin/ldd
 	$(INSTALL) -m 755 ldconfig $(PREFIX)$(RUNTIME_PREFIX)sbin/ldconfig;
-	#$(INSTALL) -m 755 readelf $(PREFIX)$(RUNTIME_PREFIX)usr/bin/readelf
+	#$(INSTALL) -m 755 readelf $(PREFIX)$(RUNTIME_PREFIX)bin/readelf
 endif
 ifeq ($(strip $(UCLIBC_HAS_LOCALE)),y)
-	$(INSTALL) -m 755 iconv $(PREFIX)$(RUNTIME_PREFIX)usr/bin/iconv
+	$(INSTALL) -m 755 iconv $(PREFIX)$(RUNTIME_PREFIX)bin/iconv
 endif
